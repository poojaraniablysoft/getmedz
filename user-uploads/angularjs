//
// General Utils
//
Array.prototype.chunk = function(chunkSize) {

    var array = this;
    return [].concat.apply([],
        array.map(function(elem, i) {
            return i % chunkSize ? [] : [array.slice(i, i + chunkSize)];
        })
    );
};


// Polyfill map in IE8
// Production steps of ECMA-262, Edition 5, 15.4.4.19
// Reference: http://es5.github.com/#x15.4.4.19
if (!Array.prototype.map) {
    Array.prototype.map = function(callback, thisArg) {

        var T, A, k;

        if (this == null) {
            throw new TypeError(" this is null or not defined");
        }

        // 1. Let O be the result of calling ToObject passing the |this| value as the argument.
        var O = Object(this);

        // 2. Let lenValue be the result of calling the Get internal method of O with the argument "length".
        // 3. Let len be ToUint32(lenValue).
        var len = O.length >>> 0;

        // 4. If IsCallable(callback) is false, throw a TypeError exception.
        // See: http://es5.github.com/#x9.11
        if (typeof callback !== "function") {
            throw new TypeError(callback + " is not a function");
        }

        // 5. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (thisArg) {
            T = thisArg;
        }

        // 6. Let A be a new array created as if by the expression new Array(len) where Array is
        // the standard built-in constructor with that name and len is the value of len.
        A = new Array(len);

        // 7. Let k be 0
        k = 0;

        // 8. Repeat, while k < len
        while(k < len) {

            var kValue, mappedValue;

            // a. Let Pk be ToString(k).
            //   This is implicit for LHS operands of the in operator
            // b. Let kPresent be the result of calling the HasProperty internal method of O with argument Pk.
            //   This step can be combined with c
            // c. If kPresent is true, then
            if (k in O) {

                // i. Let kValue be the result of calling the Get internal method of O with argument Pk.
                kValue = O[ k ];

                // ii. Let mappedValue be the result of calling the Call internal method of callback
                // with T as the this value and argument list containing kValue, k, and O.
                mappedValue = callback.call(T, kValue, k, O);

                // iii. Call the DefineOwnProperty internal method of A with arguments
                // Pk, Property Descriptor {Value: mappedValue, : true, Enumerable: true, Configurable: true},
                // and false.

                // In browsers that support Object.defineProperty, use the following:
                // Object.defineProperty(A, Pk, { value: mappedValue, writable: true, enumerable: true, configurable: true });

                // For best browser support, use the following:
                A[ k ] = mappedValue;
            }
            // d. Increase k by 1.
            k++;
        }

        // 9. return A
        return A;
    };
}
"use strict";

angular.module("mtApp", [
    "ngCookies",
    "ngResource",
    "ngSanitize",
    "ngAnimate",
    "ui.router",
    "ui.utils",
    "ngDialog",
    "ccFilters",
    "restangular"
])
.config(function ($stateProvider, $urlRouterProvider, $locationProvider, $parseProvider, $httpProvider, USER_ROLES, ROUTES) {

        // Disable cache - required for Ajax calls in IE (to match modern-browser functionality)
    $httpProvider.defaults.headers.common["If-Modified-Since"] = "0";

    // Redirect "" URL to "/" - this is true when hitting
    // the home page in IE8 (as IE8 must use hash bang mode not
    // HTML5 mode and the root URL is interpreted as "")
    $urlRouterProvider.when("", "/");

    // Set up states...
    $stateProvider
        .state(ROUTES.ERROR_400, {

            url: "/400",
            templateUrl: "/partials/400",
            data: {
                access:  [USER_ROLES.visitor, USER_ROLES.user, USER_ROLES.admin, USER_ROLES.rep]
            },
            title: "Bad Request - Error 400"

        })
        .state(ROUTES.ERROR_401, {

            url: "/401",
            templateUrl: "<div></div>",
            data: {
                access:  [USER_ROLES.visitor, USER_ROLES.user, USER_ROLES.admin, USER_ROLES.rep],
                pageName: "error"
            },
            title: "Not Authenticated - Error 401",
            controller: function($state, AuthService) {

                AuthService.killLocalSession();
                $state.go(ROUTES.LOGIN);
            }
        })
        .state(ROUTES.ERROR_403, {

            url: "/403",
            templateUrl: "/partials/403",
            data: {
                access:  [USER_ROLES.visitor, USER_ROLES.user, USER_ROLES.admin, USER_ROLES.rep]
            },
            title: "Not Authorized - Error 403"

        })
        .state(ROUTES.ERROR_404, {

            url: "/404",
            templateUrl: "/partials/404",
            data: {
                access:  [USER_ROLES.visitor, USER_ROLES.user, USER_ROLES.admin, USER_ROLES.rep]
            },
            title: "Not Found - Error 404!"

        })
        .state(ROUTES.ERROR_422CODE,{

            url: "/422/:minorCode",
            templateUrl: "/partials/422",
            data: {
                access:  [USER_ROLES.visitor, USER_ROLES.user, USER_ROLES.admin, USER_ROLES.rep]
            },
            title: "Client Error - Error 422",
            controller: "ErrorController"

        })
        .state(ROUTES.ERROR_422,{

            url: "/422",
            templateUrl: "/partials/422",
            data: {
                access:  [USER_ROLES.visitor, USER_ROLES.user, USER_ROLES.admin, USER_ROLES.rep]
            },
            title: "Client Error - Error 422",
            controller: "ErrorController"

        })
        .state(ROUTES.ERROR_500, {

            url: "/500",
            templateUrl: "/partials/500",
            data: {
                access:  [USER_ROLES.visitor, USER_ROLES.user, USER_ROLES.admin, USER_ROLES.rep]
            },
            title: "server Error - Error 500"

        })
        .state(ROUTES.LOGIN_ACTIVATE,{

           url: "/login/activate",
           templateUrl: "/partials/login",
           controller: "LoginController",
           data: {
               access: USER_ROLES.visitor,
               activate: true
           },
           title: "Login"


        })
        .state(ROUTES.LOGIN_RESET,{

           url: "/login/reset",
           templateUrl: "/partials/login",
           controller: "LoginController",
           data: {
               access: USER_ROLES.visitor,
               reset: true
           },
           title: "Login"


        })
        .state(ROUTES.LOGIN, {

            url: "/login",
            templateUrl: "/partials/login",
            controller: "LoginController",
            data: {
                access: USER_ROLES.visitor
            },
            title: "Login"

        })
        .state(ROUTES.LOGOUT, {

            url: "/logout",
            controller: function($scope, AuthService) {

                AuthService.logout().then(function() {

                    window.location.replace("/logout");
                });
            },
            template : "<div></div>",
            data: {
                access: [USER_ROLES.visitor, USER_ROLES.user, USER_ROLES.admin, USER_ROLES.rep]
            }
        })
        .state(ROUTES.REQ_PASSSWORD_RESET, {

           url: "/user/password/request-reset",
           title: "reset Password",
           templateUrl: "/partials/forgot.html",
           controller: "LoginController",
           data: {
               access: USER_ROLES.visitor
           }

        })
        .state(ROUTES.RESET_PASSWORD, {

           title:"reset Password",
           url: "/user/password/reset/:forgotKey",
           templateUrl : "/partials/reset-password",
           controller: "LoginController",
           data: {
               access: USER_ROLES.visitor
           }

        })
        .state(ROUTES.HOME, {

            url: "/app",
            title: "Surgical Workflow Technology in Healthcare",
            templateUrl: "/partials/site/index",
            data: {
                access:[]
            },
            controller: "HomeController"

        })
        .state(ROUTES.CASES, {

            abstract: true,
            url: "/cases",
            title: "Cases",
            template: "<div ui-view>",
            controller: "AbstractCasesController",
            data: {
                access: [USER_ROLES.user, USER_ROLES.rep]
            },
            resolve: {
                favoritesEnabled: function(USER_ROLES, AuthService, PersonService) {

                    if ( AuthService.isAuthorized(USER_ROLES.rep) ) {
                        return false;
                    }

                    return PersonService.isFavoritesEnabled();
                }
            }
        })
        .state(ROUTES.CASES_ACTIVE, {

            url: "/active",
            title: "Active Cases",
            templateUrl: "/partials/cases/case-index",
            data: {
                access: [USER_ROLES.user, USER_ROLES.rep]
            },
            controller: "ActiveCasesController",
            resolve: {
                cases: function(QMService, UserSession, CaseService, favoritesEnabled) {

                    var user = UserSession.user;
                    var qm = QMService.getInstance("ACTIVE_CASE");

                    return CaseService.findActiveCases(qm, favoritesEnabled.enabled, user);
                },
                totalCaseCount: function (QMService, UserSession, CaseService, favoritesEnabled)  {

                    var user = UserSession.user;
                    var qm = QMService.getInstance("ACTIVE_CASE");

                    return CaseService.countActiveCases(qm, favoritesEnabled.enabled, user);
                },
                unconfirmedCaseCount: function(UserSession, AuthService, CaseService) {

                    if ( !AuthService.isAuthorized(USER_ROLES.rep) ) {
                        return false;
                    }

                    return CaseService.countRepUnconfirmedCases(UserSession.user._id);
                }
            }
        })
        .state(ROUTES.CASES_FILTER, {

            url: "/filter/:filterType",
            title: "Active Cases",
            templateUrl: "/partials/cases/case-index",
            data: {
                access: [USER_ROLES.user, USER_ROLES.rep]
            },
            controller: "ActiveCasesController",
            resolve: {
                cases: function($stateParams, QMService, UserSession, CaseService, favoritesEnabled) {

                    //implantConfirmationType, favoritesEnabled, user, next
                    var user = UserSession.user;
                    var qm = QMService.getInstance("ACTIVE_CASE");

                    return CaseService.findActiveCasesWithUnconfirmedImplants(qm, $stateParams.filterType, favoritesEnabled.enabled, user);
                },
                totalCaseCount: function ($stateParams, QMService, UserSession, CaseService, favoritesEnabled)  {

                    var user = UserSession.user;
                    var qm = QMService.getInstance("ACTIVE_CASE");

                    return CaseService.countActiveCasesWithUnconfirmedImplants(qm, $stateParams.filterType, favoritesEnabled.enabled, user);
                },
                unconfirmedCaseCount: function() {

                    // Reps currently do not have the capability to filter
                    // cases - return false here as the user will always be
                    // a scheduler
                    return false;
                }
            }
        })
        .state(ROUTES.CASES_ACTIVE_SHOW, {

            url: "/emr-notes/:id",
            onEnter: function($stateParams, ngDialog, CaseService) {

                CaseService.findCaseById($stateParams.id, function(kase) {

                ngDialog.open({
                    template:"/partials/cases/emr-notes",
                    className: "ngdialog-default mt-dialog emr-notes wide",
                    controller: "CaseEMRSummaryController",
                    data: angular.toJson(kase),
                    closeByEscape: false,
                    closeByDocument: false
                });
            });
            }
        })
        .state(ROUTES.CASES_ARCHIVED, {

            url: "/archived",
            title: "Closed and Canceled Cases",
            templateUrl: "/partials/cases/case-index",
            controller: "ArchivedCasesController",
            resolve: {
                cases: function(QMService, UserSession, CaseService, favoritesEnabled) {

                    var qm = QMService.getInstance("INACTIVE_CASE");
                    return CaseService.findClosedAndCanceledCases(qm, favoritesEnabled.enabled, UserSession.user);
                },
                totalCaseCount: function (QMService, UserSession, CaseService, favoritesEnabled)  {

                    var qm = QMService.getInstance("INACTIVE_CASE");
                    return CaseService.countClosedAndCanceledCases(qm, favoritesEnabled.enabled, UserSession.user);
                }
            }
        })
        .state(ROUTES.CASE_NEW, {

            url: "/new",
            title: "Create Case",
            templateUrl: "/partials/cases/case-new",
            data: {
                access: USER_ROLES.user
            },
            controller: "CaseFormController",
            resolve: {
                hospitals: function(UserSession, OrganizationService, favoritesEnabled) {

                    // Query for the hospitals associated with the
                    // user's practice - we need these to select the hospital
                    // at which the surgery will take place
                    return OrganizationService.findUserHospitals(favoritesEnabled.enabled, UserSession.user);
                },
                procedures: function(ProcedureService, favoritesEnabled) {

                    return ProcedureService.findUserProcedures(favoritesEnabled.enabled);
                },
                kase: function() {

                    // Create new case object
                    return {};
                }
            }
        })
        .state(ROUTES.CASE_SHOW, {

            url: "/cases/:id",
            title: "View Case Detail",
            templateUrl: "/partials/cases/case-show",
            data: {
                access: [USER_ROLES.user, USER_ROLES.rep]
            },
            controller: "CaseController",
            resolve: {
                kase: function($stateParams, CaseService) {

                    return CaseService.showCase($stateParams.id);
                }
            }
        })
        .state(ROUTES.CASE_ACTIVITY, {

            url: "/activity",
            views: {
                "activity": {
                    templateUrl: "/partials/cases/case-show-activity.html",
                    controller: "CaseActivityController"
                }
            },
            resolve: {
                comments: function($stateParams, CommentService) {

                    return CommentService.getCommentCaseById($stateParams.id);
                }
            }
        })
        .state(ROUTES.CASE_EDIT, {

            url: "/cases/:id/edit",
            title: "Edit Case",
            templateUrl: "/partials/cases/case-new",
            data: {
                access: USER_ROLES.user
            },
            controller: "CaseFormController",
            resolve: {
                favoritesEnabled: function(PersonService) {

                    return PersonService.isFavoritesEnabled();
                },
                hospitals: function(UserSession, OrganizationService, favoritesEnabled) {

                    // Query for the hospitals associated with the
                    // user's practice - we need these to select the hospital
                    // at which the surgery will take place
                    return OrganizationService.findUserHospitals(favoritesEnabled.enabled, UserSession.user);
                },
                procedures: function(ProcedureService, favoritesEnabled) {

                    return ProcedureService.findUserProcedures(favoritesEnabled.enabled);
                },
                kase: function($stateParams, CaseService) {

                    return CaseService.editCase($stateParams.id);
                }
            }
        })
        .state(ROUTES.CASE_CONFIRM, {

            url: "/cases/:id/confirm",
            title: "Confirm Case",
            templateUrl: "/partials/cases/case-show-confirmation",
            data: {
                access: USER_ROLES.rep
            },
            controller: "CaseConfirmationController",
            resolve: {
                surgeon: function(PersonService, kase) {

                    return PersonService.findPersonById(kase.surgeon);
                },
                kase: function($stateParams, CaseService) {

                    return CaseService.editCase($stateParams.id);
                }
            }
        })
        .state(ROUTES.PRINT_TRAYS, {

            url: "/cases/:id/implants/:implantId/trays",
            title: "Print Trays",
            templateUrl: "/partials/tray/print-tray-details",
            data: {
                access: USER_ROLES.user
            },
            controller: "TrayPrintController",
             resolve: {
                 kase: function($stateParams, CaseService) {

                    return CaseService.findCaseById($stateParams.id);
                 },
                 implant: function($stateParams, kase) {

                     var implantId = $stateParams.implantId;
                     var implant;
                     for ( var i  = 0 ; i < kase.implants.length ; i++ ) {

                         implant = kase.implants[i];
                         if ( implant._id === implantId ) {
                             break;
                         }
                     }

                     return implant;
                 },
                 trays: function(TrayService, implant) {

                    // Find the implant on the case and find the trays for the
                    // corresponding product
                     if ( implant ) {
                         return TrayService.findTraysByProductId(implant.product._id);
                     }

                     return [];
                 }
             }
        })
        .state(ROUTES.PROFILE, {

            abstract:true,
            url: "/profile",
            templateUrl: "/partials/users/person-show",
            data: {
                access: USER_ROLES.user
            },
            resolve: {
                profile: function(PersonService, UserSession) {
                    return PersonService.findPersonProfile(UserSession.user._id);
                }
            },
            controller: "ProfileController"
        })
        .state(ROUTES.PROFILE_INFO, {

            url: "/info",
            title: "Profile",
            templateUrl: "/partials/users/_person-show-info",
            data: {
                access: [USER_ROLES.user, USER_ROLES.rep]
            },
            controller: "ProfileInfoController",
            resolve: {
                organization: function (OrganizationService, UserSession) {
                    return OrganizationService.findOrganizationById(UserSession.user.organizations.home._id);
                }
            }
        })
        .state(ROUTES.PROFILE_EMAILS, {
            url: "/emails",
            title: "Email Preferences",
            data: {
                access: [USER_ROLES.user, USER_ROLES.rep]
            },
            views: {
                "": {
                    templateUrl: "/partials/users/_edit-email-alerts",
                    controller: "ProfileEmailFormController"
                }
            }
        })
        .state(ROUTES.PROFILE_FAVORITES, {
            url: "/favorites",
            title: "Favorites",
            data: {
                access: USER_ROLES.user
            },
            resolve: {
                favoriteOrganizations: function(UserSession, OrganizationService) {

                    // If the user's organization is a hospital and
                    // the user's hospital is not part of a hospital group,
                    // just return the user's home hospital - we need this to
                    // trigger the ng repeat of favorites per organization
                    var user = UserSession.user;
                    if ( !OrganizationService.findAffiliatedHospitals(user).length ) {
                        return [user.organizations.home];
                    }

                    // Otherwise query for organizations the current user has
                    // selected as favorite
                    return OrganizationService.findFavoriteHospitals();
                }
            },
            views: {
                "": {
                    templateUrl: "/partials/users/_edit-favorites",
                    controller: "ProfileFavoriteFormController"
                },
                "procedures@profile.favorites": {
                    templateUrl: "/partials/users/_edit-favorite-procedures",
                    controller: "FavoriteProcedureController",
                    resolve: {
                        procedures: function(ProcedureService) {

                            return ProcedureService.findActiveProcedures();
                        },
                        favorites: function(ProcedureService) {

                            return ProcedureService.findFavoriteProcedures();
                        }
                    }
                },
                "hospitals@profile.favorites": {
                    templateUrl: "/partials/users/_edit-favorite-hospitals",
                    controller: "FavoriteHospitalController"
                }
            }
        })
        .state(ROUTES.PROFILE_FAVORITES_HOSPITAL, {
            url: "/:id",
            title: "My Favorite Surgical Dashboard",
            data: {
                access: USER_ROLES.user
            }
        })
        .state(ROUTES.ADMIN,{
            abstract:true,
            url: "/admin",
            title: "Admin ",
            templateUrl: "/partials/admin/index",
            data: {
                access: USER_ROLES.admin
            }
        })

        .state(ROUTES.ADMIN_ZAPS, {
            url: "/zaps",
            title: "Zaps",
            templateUrl: "/partials/admin/zap/zap-index",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminZapsController"
        })

        .state(ROUTES.ADMIN_REPORTS, {
            url: "/reports",
            title: "Reports",
            templateUrl: "/partials/admin/report/report-index",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminReportsController"
        })

        .state(ROUTES.ADMIN_PROCEDURES,{

            url: "/procedures",
            title: "Procedures",
            templateUrl: "/partials/admin/adminbody",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminEntitiesController",
            resolve: {
                metadataKey: function() {
                    return "procedure";
                },
                urlKey: function() {
                    return "procedures";
                },
                entityTypeDisplayName: function() {
                    return "Procedure";
                },
                service:"AdminProcedureService",
                query: function() {
                    return "findActiveProcedures";
                },
                listModel: function (QMService, AdminProcedureService) {

                    var qm = QMService.getInstance("ADMIN");
                    qm.setOffset(0);
                    return AdminProcedureService.findActiveProcedures(qm);
                },
                capabilities: function () {
                    return {
                        create: true,
                        edit: false,
                        retire: true
                    };
                }
            }
        })
        .state(ROUTES.ADMIN_PROCEDURES_CREATE, {

            url:"/procedures/new",
            title: "Create Procedure",
            templateUrl: "/partials/admin/procedure/procedure-new",
            data: {
                access: [USER_ROLES.admin],
                action: "Create"
            },
            controller: "AdminProcedureController",
            resolve: {
                data: function () {

                    // We're creating a new procedure - just return
                    return;
                }
            }

        })
        .state(ROUTES.ADMIN_PROCEDURES_EDIT, {

            url:"/procedures/:id/edit",
            title: "Edit Procedure",
            templateUrl: "/partials/admin/procedure/procedure-new",
            data: {
                access: [USER_ROLES.admin],
                action: "Update"
            },
            controller: "AdminProcedureController",
            resolve: {
                data: function ($stateParams, ProcedureService) {

                    // Return the procedure we are editing
                    return ProcedureService.findProcedureById($stateParams.id);
                }
            }
        })
        .state(ROUTES.ADMIN_PRODUCT_INDEX, {

            url: "/products",
            title: "Products",
            templateUrl: "/partials/admin/adminbody",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminEntitiesController",
            resolve: {
                metadataKey: function() {
                    return "product";
                },
                urlKey: function() {
                    return "products";
                },
                entityTypeDisplayName: function() {
                    return "Product";
                },
                service:"AdminProductService",
                query: function() {
                    return "findActiveProducts";
                },
                listModel: function (QMService, AdminProductService) {

                    var qm = QMService.getInstance("ADMIN");
                    qm.setOffset(0);
                    return AdminProductService.findActiveProducts(qm);
                },
                capabilities: function () {
                    return {
                        create: true,
                        edit: false,
                        retire: true,
                        show: true
                    };
                }
            }
        })
        .state(ROUTES.ADMIN_PRODUCT_CREATE, {

            url:"/products/new",
            title: "Create Product",
            templateUrl: "/partials/admin/product/product-new",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminProductFormController",
            resolve: {
                data : function () {

                    // We're creating a new product - just return
                    return;
                },
                manufacturers: function (OrganizationService) {
                   return OrganizationService.findAllAdminManufacturers(0);
                },
                trays : function () {
                    // return empty trays on creating
                    return [];
                }
            }

        })
        .state(ROUTES.ADMIN_PRODUCT_SHOW, {
            url:"/products/:id",
            title: "Product Detail",
            templateUrl: "/partials/admin/product/product-show",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminProductController",
            resolve: {
                product : function ($stateParams, AdminProductService) {

                    // Find the product we are editing
                    return AdminProductService.findProductById($stateParams.id);
                },
                manufacturer: function (AdminOrganizationService, product) {

                    return AdminOrganizationService.findOrganizationById(product.manufacturer);
                },
                trays : function ($stateParams, TrayService, product) {
                    return (product.productType === "IMPLANT") ? TrayService.findTraysByProductId($stateParams.id) : [] ;
                }
            }
        })
        .state(ROUTES.ADMIN_MANUFACTURER, {

            url: "/manufacturers",
            title: "Manufacturers",
            templateUrl: "/partials/admin/adminbody",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminController",
            resolve: {
                metadataKey: function() {
                    return "organization";
                },
                urlKey: function() {
                    return "manufacturers";
                },
                entityTypeDisplayName: function() {
                    return "Manufacturer";
                },
                service:"OrganizationService",
                query: function() {
                    return "findAdminManufacturers";
                },
                count: function(OrganizationService) {

                    return OrganizationService.countAllManufacturerOrganizations();
                },
                data: function (OrganizationService) {

                    return OrganizationService.findAdminManufacturers(0);
                },
                capabilities: function () {
                    return {
                        create: true,
                        edit: true
                    };
                }
            }
        })
        .state(ROUTES.ADMIN_MANUFACTURER_CREATE, {

            url:"/manufacturers/new",
            title: "Create Manufacturer",
            templateUrl: "/partials/admin/organization/organization-new",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminOrganizationController",
            resolve: {
                data : function () {

                    // We're creating a new organization - just return
                    return;
                },
                organizationsRoute: function (ROUTES) {
                    return ROUTES.ADMIN_MANUFACTURER;
                },
                organizationType: function () {
                    return "Manufacturer";
                },
                products: function () {
                    // return empty array of objects
                    return [];
                },
                users: function () {
                    // return empty array of users on create
                    return [];
                }
            }

        })
        .state(ROUTES.ADMIN_MANUFACTURER_EDIT, {

            url:"/manufacturers/:id/edit",
            title: "Edit Manufacturer",
            templateUrl: "/partials/admin/organization/organization-new",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminOrganizationController",
            resolve: {
                data : function (AdminOrganizationService, $stateParams) {

                    return AdminOrganizationService.findOrganizationById($stateParams.id);
                },
                organizationsRoute: function (ROUTES) {
                    return ROUTES.ADMIN_MANUFACTURER;
                },
                organizationType: function () {
                    return "Manufacturer";
                },
                products: function () {
                    // return empty array of objects
                    return [];
                },
                users: function (AdminPersonService, $stateParams) {
                    // return list of manufacturer's users on edit
                    return AdminPersonService.findAdminRepsByManufacturer($stateParams.id);
                }
            }

        })
        //.state(ROUTES.ADMIN_HOSPITAL_GROUP_INDEX, {
        //
        //    url: "/hospital-groups",
        //    title: "Hospital Groups",
        //    templateUrl: "/partials/admin/adminbody",
        //    data: {
        //        access: [USER_ROLES.admin]
        //    },
        //    controller: "AdminController",
        //    resolve: {
        //        metadataKey: function() {
        //            return "organization";
        //        },
        //        urlKey: function() {
        //            return "hospital-groups";
        //        },
        //        entityTypeDisplayName: function() {
        //            return "Hospital Group";
        //        },
        //        service:"OrganizationService",
        //        query: function() {
        //            return "findAdminHospitalGroups";
        //        },
        //        count: function(OrganizationService) {
        //
        //            return OrganizationService.countAllHospitalGroupsOrganizations();
        //        },
        //        data: function (OrganizationService) {
        //
        //            return OrganizationService.findAdminHospitalGroups();
        //        },
        //        capabilities: function () {
        //            return {
        //                create: true,
        //                edit: true
        //            };
        //        }
        //    }
        //})
        //
        //.state(ROUTES.ADMIN_HOSPITAL_GROUP_CREATE, {
        //
        //    url:"/hospital-groups/new",
        //    title: "Create Hospital Group",
        //    templateUrl: "/partials/admin/hospitalgroup/hospitalgroup-new",
        //    data: {
        //        access: [USER_ROLES.admin]
        //    },
        //    controller: "AdminHospitalGroupController",
        //    resolve: {
        //        hospitalGroup : function () {
        //
        //            // We're creating a new organization - just return
        //            return;
        //        },
        //        organizationIndexRoute: function (ROUTES) {
        //            return ROUTES.ADMIN_HOSPITAL_GROUP_INDEX;
        //        },
        //        organizationType: function () {
        //            return "HOSPITAL_GROUP";
        //        },
        //        entityTypeDisplayName: function () {
        //            return "Hospital Group";
        //        },
        //        hospitalsNotInGroup: function (AdminOrganizationService) {
        //            return AdminOrganizationService.findHospitalsNotInGroup();
        //        }
        //    }
        //
        //})
        //.state(ROUTES.ADMIN_HOSPITAL_GROUP_EDIT, {
        //
        //    url:"/hospital-groups/:id/edit",
        //    title: "Edit Hospital Group",
        //    templateUrl: "/partials/admin/hospitalgroup/hospitalgroup-new",
        //    data: {
        //        access: [USER_ROLES.admin]
        //    },
        //    controller: "AdminHospitalGroupController",
        //    resolve: {
        //        hospitalGroup : function (AdminOrganizationService, $stateParams) {
        //
        //            return AdminOrganizationService.findOrganizationById($stateParams.id);
        //        },
        //        organizationIndexRoute: function (ROUTES) {
        //            return ROUTES.ADMIN_HOSPITAL_GROUP_INDEX;
        //        },
        //        organizationType: function () {
        //            return "HOSPITAL_GROUP";
        //        },
        //        entityTypeDisplayName: function () {
        //            return "Hospital Group";
        //        },
        //        hospitalsNotInGroup: function (AdminOrganizationService) {
        //            return AdminOrganizationService.findHospitalsNotInGroup();
        //        }
        //    }
        //
        //})

        .state(ROUTES.ADMIN_REP_GROUPS, {

            url: "/rep-groups",
            title: "Rep Groups",
            templateUrl: "/partials/admin/adminbody",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminController",
            resolve: {
                metadataKey: function() {
                    return "organization";
                },
                urlKey: function() {
                    return "rep-groups";
                },
                entityTypeDisplayName: function() {
                    return "rep Group";
                },
                service:"OrganizationService",
                query: function() {
                    return "findAdminRepGroups";
                },
                count: function(OrganizationService) {

                    return OrganizationService.countAllRepGroupsOrganizations();
                },
                data: function (OrganizationService) {

                    return OrganizationService.findAdminRepGroups(0);
                },
                capabilities: function () {
                    return {
                        create: false,
                        edit: false,
                        show: true
                    };
                }
            }
        })
        .state(ROUTES.ADMIN_REP_GROUP_SHOW, {

            url: "/rep-groups/:id",
            title: "Rep Group",
            templateUrl: "/partials/admin/repgroup/repgroup-show",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminRepGroupController",
            resolve: {
                repGroup: function($stateParams, AdminOrganizationService) {

                    return AdminOrganizationService.findOrganizationById($stateParams.id);
                },
                primaryRep: function($q, $stateParams, AdminPersonService) {

                    var defer = $q.defer();

                    AdminPersonService.findAdminRepPrimaryForRepGroup($stateParams.id, function(people) {

                        if ( people.length ) {
                            defer.resolve(people[0]);
                        }
                        else {
                            defer.resolve({});
                        }
                    });

                    return defer.promise;
                },
                backupReps: function($stateParams, AdminPersonService) {

                    return AdminPersonService.findAdminRepBackupsForRepGroup($stateParams.id);
                }
            }
        })





        .state(ROUTES.ADMIN_HOSPITAL_INDEX, {

            url: "/hospitals",
            title: "Hospitals",
            templateUrl: "/partials/admin/adminbody",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminController",
            resolve: {
                metadataKey: function() {
                    return "organization";
                },
                urlKey: function() {
                    return "hospitals";
                },
                entityTypeDisplayName: function() {
                    return "Hospital";
                },
                service:"OrganizationService",
                query: function() {
                    return "findAdminHospitals";
                },
                count: function(OrganizationService) {
                    return OrganizationService.countAllHospitalOrganizations(); // TODO move to admin service
                },
                data: function (OrganizationService) {
                    return OrganizationService.findAdminHospitals(0); // TODO move to admin service
                },
                capabilities: function () {
                    return {
                        create: true,
                        edit: true
                    };
                }
            }
        })
        .state(ROUTES.ADMIN_HOSPITAL_CREATE, {

            url:"/hospitals/new",
            title: "Create Hospital",
            templateUrl: "/partials/admin/hospital/hospital-new",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminHospitalFormController",
            resolve: {
                data : function () {

                    // We're creating a new organization - just return
                    return;
                },
                productSources: function () {

                    // Return empty array of objects
                    return [];
                },
                implantOptions: function() {

                    // Product sources can not be associated with
                    // the hospital until after the hospital has
                    // been created - return empty array here
                    return [];
                },
                ancillaryProductOptions: function() {

                    // Product sources can not be associated with
                    // the hospital until after the hospital has
                    // been created - return empty array here
                    return [];
                },
                monitoringProductOptions: function() {

                    // Product sources can not be associated with
                    // the hospital until after the hospital has
                    // been created - return empty array here
                    return [];
                },
                boneGraftProductOptions: function() {

                    // Product sources can not be associated with
                    // the hospital until after the hospital has
                    // been created - return empty array here
                    return [];
                }
            }

        })
        .state(ROUTES.ADMIN_HOSPITAL_EDIT, {

            url:"/hospitals/:id/edit",
            title: "Edit Hospital",
            templateUrl: "/partials/admin/hospital/hospital-new",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminHospitalFormController",
            resolve: {
                data : function ($stateParams, AdminOrganizationService) {

                    return AdminOrganizationService.findOrganizationById($stateParams.id);
                },
                productSources: function ($stateParams, AdminProductSourceService) {

                   return AdminProductSourceService.findProductSourcesByHospital($stateParams.id);
                },
                implantOptions: function(AdminProductService) {

                    return AdminProductService.findActiveImplants();
                },
                ancillaryProductOptions: function(AdminProductService, data) {

                    return AdminProductService.findAvailableAncillaryProductsForHospital(data._id);
                },
                monitoringProductOptions: function(AdminProductService, data) {

                    return AdminProductService.findAvailableMonitoringProductsForHospital(data._id);
                },
                boneGraftProductOptions: function(AdminProductService, data) {

                    return AdminProductService.findAvailableBoneGraftProductsForHospital(data._id);
                }
            }

        })
        .state(ROUTES.ADMIN_PRACTICES, {

            url: "/practices",
            title: "Practices",
            templateUrl: "/partials/admin/adminbody",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminController",
            resolve: {
                metadataKey: function() {
                    return "organization";
                },
                urlKey: function() {
                    return "practices";
                },
                entityTypeDisplayName: function() {
                    return "Practice";
                },
                service:"OrganizationService",
                query: function() {
                    return "findAdminPractices";
                },
                count: function(OrganizationService) {
                    return OrganizationService.countAllPracticesOrganizations();
                },
                data: function (OrganizationService) {
                    return OrganizationService.findAdminPractices(0);
                },
                capabilities: function () {
                    return {
                        create: true,
                        edit: true
                    };
                }
            }
        })
        .state(ROUTES.ADMIN_PRACTICES_CREATE, {

            url:"/practices/new",
            title: "Create Practice",
            templateUrl: "/partials/admin/practice/practice-new",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminPracticeController",
            resolve: {
                practice : function () {

                    // We're creating a new organization - just return
                    return;
                },
                affiliatedHospitals: function() {

                    // We're create a new practice - there are
                    // no affiliated hospitals yet
                    return [];
                },
                organizationsIndex: function (ROUTES) {
                    return ROUTES.ADMIN_PRACTICES;
                },
                hospitals: function (OrganizationService) {
                    // return list of hospitals
                    return OrganizationService.findAdminHospitals(0);
                },
                users: function() {

                    // No users on create
                    return;
                }
            }

        })
        .state(ROUTES.ADMIN_PRACTICES_EDIT, {

            url:"/practices/:id/edit",
            title: "Edit Practice",
            templateUrl: "/partials/admin/practice/practice-new",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminPracticeController",
            resolve: {
                practice : function (AdminPracticeService, $stateParams) {

                    return AdminPracticeService.editPractice($stateParams.id);
                },
                affiliatedHospitals: function(AdminPracticeService, $stateParams) {

                    return AdminPracticeService.findHospitalsAffiliatedWithPractice($stateParams.id);
                },
                organizationsIndex: function (ROUTES) {

                    return ROUTES.ADMIN_PRACTICES;
                },
                hospitals: function (OrganizationService) {

                    // return list of hospitals
                    return OrganizationService.findAdminHospitals(0);
                },
                users: function(AdminPersonService, $stateParams) {

                    return AdminPersonService.findAdminSchedulersByOrganization(0, $stateParams.id);
                }
            }

        })
        .state(ROUTES.ADMIN_SCHEDULERS, {

            url: "/schedulers",
            title: "Hospital Schedulers",
            templateUrl: "/partials/admin/adminbody",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminEntitiesController",
            resolve: {
                metadataKey: function() {
                    return "person";
                },
                urlKey: function() {
                    return "schedulers";
                },
                entityTypeDisplayName: function() {
                    return "Hospital Schedulers";
                },
                service:"AdminPersonService",
                query: function() {
                    return "findSchedulers";
                },
                listModel: function (QMService, AdminPersonService) {

                    var qm = QMService.getInstance("ADMIN");
                    qm.setOffset(0);
                    return AdminPersonService.findSchedulers(qm, "HOSPITAL");
                },
                capabilities: function () {
                    return {
                        create: true,
                        edit: true
                    };
                }
            }
        })
        .state(ROUTES.ADMIN_PRACTICE_SCHEDULERS, {

            url: "/practice-schedulers",
            title: "Practice Schedulers",
            templateUrl: "/partials/admin/adminbody",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminEntitiesController",
            resolve: {
                metadataKey: function() {
                    return "person";
                },
                urlKey: function() {
                    return "practice-schedulers";
                },
                entityTypeDisplayName: function() {
                    return "Practice Schedulers";
                },
                service:"AdminPersonService",
                query: function() {
                    return "findSchedulers";
                },
                listModel: function (QMService, AdminPersonService) {

                    var qm = QMService.getInstance("ADMIN");
                    qm.setOffset(0);
                    return AdminPersonService.findSchedulers(qm, "PRACTICE");
                },
                capabilities: function () {
                    return {
                        create: true,
                        edit: true
                    };
                }
            }
        })
        .state(ROUTES.ADMIN_SCHEDULERS_CREATE, {

            url:"/schedulers/new",
            title: "Create Hospital Scheduler",
            templateUrl: "/partials/admin/person/person-new",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminPersonFormController",
            resolve: {
                data: function () {

                    // We're creating a new scheduler - just return
                    return;
                },
                surgeons: function () {

                    // User must first select the scheduler's org
                    // before we know what surgeons to list - just
                    // return empty array here
                    return [];
                },
                organizations: function (OrganizationService) {

                    return OrganizationService.findAdminHospitals(0);
                },
                role: function (USER_ROLES) {
                    return USER_ROLES.user;
                },
                organizationsRoute: function (ROUTES) {
                    return ROUTES.ADMIN_SCHEDULERS;
                },
                entityTypeDisplayInfo : function () {
                    return "Hospital Scheduler";
                }
            }

        })
        .state(ROUTES.ADMIN_SCHEDULERS_EDIT, {

            url:"/schedulers/:id/edit",
            title: "Edit Hospital Scheduler",
            templateUrl: "/partials/admin/person/person-new",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminPersonFormController",
            resolve: {
                data: function ($stateParams, AdminPersonService) {

                    return AdminPersonService.findPersonById($stateParams.id);
                },
                // @param data The person currently being edited
                surgeons: function (PersonService, data) {

                    // Find all surgeons the user currently being edited has
                    // access to (either as a practice user, hospital user or a
                    // user of a hospital in a group)
                    var surgeonOrgIds = PersonService.generateListOfSurgeonOrganizations(data);
                    return PersonService.findAllSurgeons(surgeonOrgIds);
                },
                organizations: function (OrganizationService) {

                    return OrganizationService.findAdminHospitals(0);
                },
                role: function (USER_ROLES) {
                    return USER_ROLES.user;
                },
                organizationsRoute: function (ROUTES) {
                    return ROUTES.ADMIN_SCHEDULERS;
                },
                entityTypeDisplayInfo : function () {
                    return "Hospital Scheduler";
                }
            }
        })
        .state(ROUTES.ADMIN_PRACTICE_SCHEDULERS_CREATE, {

            url:"/practice-schedulers/new",
            title: "Create Practice Scheduler",
            templateUrl: "/partials/admin/person/person-new",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminPersonFormController",
            resolve: {
                data: function () {

                    // We're creating a new scheduler - just return
                    return;
                },
                surgeons: function () {

                    // User must first select the scheduler's org
                    // before we know what surgeons to list - just
                    // return empty array here
                    return [];
                },
                organizations: function (OrganizationService) {

                    return OrganizationService.findAdminPractices(0);
                },
                role: function (USER_ROLES) {
                    return USER_ROLES.user;
                },
                organizationsRoute: function (ROUTES) {
                    return ROUTES.ADMIN_PRACTICE_SCHEDULERS;
                },
                entityTypeDisplayInfo : function () {
                    return "Practice Scheduler";
                }
            }

        })
        .state(ROUTES.ADMIN_PRACTICE_SCHEDULERS_EDIT, {

            url:"/practice-schedulers/:id/edit",
            title: "Edit Practice Scheduler",
            templateUrl: "/partials/admin/person/person-new",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminPersonFormController",
            resolve: {
                data: function ($stateParams, AdminPersonService) {

                    return AdminPersonService.findPersonById($stateParams.id);
                },
                // @param data The person currently being edited
                surgeons: function (PersonService, data) {

                    // Find all surgeons the user currently being edited has
                    // access to (either as a practice user, hospital user or a
                    // user of a hospital in a group)
                    var surgeonOrgIds = PersonService.generateListOfSurgeonOrganizations(data);
                    return PersonService.findAllSurgeons(surgeonOrgIds);
                },
                organizations: function (OrganizationService) {

                    return OrganizationService.findAdminPractices(0);
                },
                role: function (USER_ROLES) {
                    return USER_ROLES.user;
                },
                organizationsRoute: function (ROUTES) {
                    return ROUTES.ADMIN_PRACTICE_SCHEDULERS;
                },
                entityTypeDisplayInfo : function () {
                    return "Practice Scheduler";
                }
            }
        })
        .state(ROUTES.ADMIN_SURGEONS, {

            url: "/surgeons",
            title: "Surgeons",
            templateUrl: "/partials/admin/adminbody",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminController",
            resolve: {
                metadataKey: function() {
                    return "person";
                },
                urlKey: function() {
                    return "surgeons";
                },
                entityTypeDisplayName: function() {
                    return "surgeon";
                },
                service:"AdminPersonService",
                query: function() {
                    return "findAdminSurgeons";
                },
                count: function(AdminPersonService) {
                    return AdminPersonService.countAdminSurgeons();
                },
                data: function (AdminPersonService) {
                    return AdminPersonService.findAdminSurgeons(0);
                },
                capabilities: function () {
                    return {
                        create: true,
                        edit: true
                    };
                }
            }
        })
        .state(ROUTES.ADMIN_SURGEONS_CREATE, {

            url:"/surgeons/new",
            title: "Create Surgeon",
            templateUrl: "/partials/admin/person/person-new",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminPersonFormController",
            resolve: {
                data: function () {

                    // We're creating a new scheduler - just return
                    return;
                },
                surgeons: function () {

                    // User must first select the scheduler's org
                    // before we know what surgeons to list - just
                    // return empty array here
                    return [];
                },
                organizations: function (OrganizationService) {

                    return OrganizationService.findAdminOrganizationsForRole("SURGEON");
                },
                role: function (USER_ROLES) {
                    return USER_ROLES.surgeon;
                },
                organizationsRoute: function (ROUTES) {
                    return ROUTES.ADMIN_SURGEONS;
                },
                entityTypeDisplayInfo : function () {
                    return "surgeon";
                }
            }

        })
        .state(ROUTES.ADMIN_SURGEONS_EDIT, {

            url:"/surgeons/:id/edit",
            title: "Edit Surgeon",
            templateUrl: "/partials/admin/person/person-new",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminPersonFormController",
            resolve: {
                data: function ($stateParams, AdminPersonService) {

                    return AdminPersonService.findPersonById($stateParams.id);
                },
                // @param data The person currently being edited
                surgeons: function (PersonService, data) {

                    // Find all surgeons the user currently being edited has
                    // access to (either as a practice user, hospital user or a
                    // user of a hospital in a group)
                    var surgeonOrgIds = PersonService.generateListOfSurgeonOrganizations(data);
                    return PersonService.findAllSurgeons(surgeonOrgIds);
                },
                organizations: function (OrganizationService) {

                    return OrganizationService.findAdminOrganizationsForRole("SURGEON");
                },
                role: function (USER_ROLES) {
                    return USER_ROLES.surgeon;
                },
                organizationsRoute: function (ROUTES) {
                    return ROUTES.ADMIN_SURGEONS;
                },
                entityTypeDisplayInfo : function () {
                    return "surgeon";
                }
            }
        })
        .state(ROUTES.ADMIN_REPS, {

            url: "/reps",
            title: "Reps",
            templateUrl: "/partials/admin/adminbody",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminController",
            resolve: {
                metadataKey: function() {
                    return "person";
                },
                urlKey: function() {
                    return "reps";
                },
                entityTypeDisplayName: function() {
                    return "rep";
                },
                service:"AdminPersonService",
                query: function() {
                    return "findAdminReps";
                },
                count: function(AdminPersonService) {

                    return AdminPersonService.countAdminReps();
                },
                data: function (AdminPersonService) {

                    return AdminPersonService.findAdminReps(0);
                },
                capabilities: function () {
                    return {
                        create: true,
                        edit: true
                    };
                }
            }
        })
        .state(ROUTES.ADMIN_REPS_CREATE, {

            url:"/reps/new",
            title: "Create Rep",
            templateUrl: "/partials/admin/person/person-new",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminPersonFormController",
            resolve: {
                data: function () {

                    // We're creating a new scheduler - just return
                    return;
                },
                surgeons: function () {

                    // return empty for rep users
                    return [];
                },
                organizations: function (OrganizationService) {

                    return OrganizationService.findAdminOrganizationsForRole("REP");
                },
                role: function (USER_ROLES) {
                    return USER_ROLES.rep;
                },
                organizationsRoute: function (ROUTES) {
                    return ROUTES.ADMIN_REPS;
                },
                entityTypeDisplayInfo : function () {
                    return "rep";
                }
            }

        })
        .state(ROUTES.ADMIN_REPS_EDIT, {

            url:"/reps/:id/edit",
            title: "Edit Rep",
            templateUrl: "/partials/admin/person/person-new",
            data: {
                access: [USER_ROLES.admin]
            },
            controller: "AdminPersonFormController",
            resolve: {
                data: function ($stateParams, AdminPersonService) {

                    return AdminPersonService.findPersonById($stateParams.id);
                },
                // @param data The person currently being edited
                surgeons: function (/*PersonService, data*/) {
                    // return empty for rep users
                    return [];
                },
                organizations: function (OrganizationService) {

                    return OrganizationService.findAdminOrganizationsForRole("REP");
                },
                role: function (USER_ROLES) {
                    return USER_ROLES.rep;
                },
                organizationsRoute: function (ROUTES) {
                    return ROUTES.ADMIN_REPS;
                },
                entityTypeDisplayInfo : function () {
                    return "rep";
                }
            }
        });

    $urlRouterProvider.otherwise("/404");

    $locationProvider.html5Mode(true);

    //
    // Intercept and handle specific response codes (403, 500, 422 etc)
    //
    $httpProvider.interceptors.push(["$q", "$location", "$injector", "ROUTES", function($q, $location, $injector, ROUTES) {
        return {
            "responseError": function(response) {

                var stateService = $injector.get("$state");
                if ( response.status === 400 ) {
                    stateService.go(ROUTES.ERROR_400);
                    return $q.reject(response);
                }
                else if ( response.status === 401 ) {

                    // We need to ignore 401 responses from the
                    // actual login page
                    if ( !stateService.is("login") ) {

                        stateService.go(ROUTES.ERROR_401);
                    }
                    return $q.reject(response);
                }
                else if ( response.status === 403 ) {
                    stateService.go(ROUTES.ERROR_403);
                    return $q.reject(response);
                }
                else if ( response.status === 422 ) {

                    var ccMinorCode = response.data.ccMinorErrorCode;
                    if ( ccMinorCode ) {
                        stateService.go(ROUTES.ERROR_422CODE, {minorCode: ccMinorCode});
                    }
                    return $q.reject(response);
                }
                else if ( response.status === 500 ) {
                    stateService.go(ROUTES.ERROR_500);
                    return $q.reject(response);
                }
                else {

                    return $q.reject(response);
                }
            }
        };
    }]);
})
.run(function ($rootScope, $state, $stateParams, $location, $window, USER_ROLES, ROUTES, AuthService) {

    //
    // Redirect to login if route requires auth and
    // you're not logged in
    //
    $rootScope.$on("$stateChangeStart", function (event, toState, toParams) {

        // Scroll to top
        $window.scrollTo(0,0);

        // If we haven't checked whether the user is authorized or
        // authenticated, then do it!
        if ( !AuthService.isUserResolved() ) {

            event.preventDefault();

            // Check if user is authorized to view page
            var accessToken = $location.search().access_token;

            AuthService.getCurrentUser(accessToken).then(function () {

                // Handle case where user is authenticated
                if ( AuthService.isAuthenticated() ) {

                    // Handle special cases - once the user is authorized, we don't want them
                    // to go back to the login, signup or home views
                    if ( toState.name === "login" || toState.name === "signup"|| toState.name ==="home" ) {

                        if ( AuthService.isAuthorized( USER_ROLES.admin) ) {
                            $state.go(ROUTES.ADMIN_PROCEDURES);
                        }
                        else {
                            $state.go(ROUTES.CASES_ACTIVE);
                        }
                    }
                    // Handle all other (non-special) cases
                    else {

                        // Authenticated and authorized
                        if ( AuthService.isAuthorized(toState.data.access) ) {

                            $state.go(toState, toParams);

                        }
                        // Authenticated but not authorized
                        else {

                            $state.go(ROUTES.ERROR_403);
                        }

                    }
                }
                // Handle case where use is not authenticated
                else {

                    // Unauthenticated and authorized
                    if ( AuthService.isAuthorized(toState.data.access) ) {

                        $state.go(toState, toParams);
                    }
                    // Unauthenticated but not authorized
                    else {

                        $state.go(ROUTES.LOGIN);
                    }
                }
            });
        }
    });

    //
    // Handle state change success
    //
    $rootScope.$on("$stateChangeSuccess", function (event, toState) {

        $rootScope.title = toState.title;
    });

    //
    // Handle state change errors
    //
    $rootScope.$on("$stateChangeError",
        function(event, toState, toParams, fromState, fromParams, error) {

            console.error(error);

            if ( error.status === 400 ) {
                $state.go(ROUTES.ERROR_400);
            }
            else if ( error.status === 401 ) {
                $state.go(ROUTES.ERROR_401);
            }
            else if ( error.status === 403 ) {
                $state.go(ROUTES.ERROR_403);
            }
            else if ( error.status === 404 ) {
                $state.go(ROUTES.ERROR_404);
            }
            else if ( error.status === 422 ) {
                $state.go(ROUTES.ERROR_422);
            }
            else {
                $state.go(ROUTES.ERROR_500);
            }
    });
});

//
// Main application header
//

"use strict";

angular.module("mtApp").controller("NavbarController", function ($scope, $state, UserSession, PersonDAO, AuthService, ROUTES, USER_ROLES) {

    // invoke the init function
    init();

    //
    // Return current user's full name (and salutation)
    //
    $scope.getCurrentUserDisplayText = function() {

        if ( !AuthService.isAuthenticated() ) {
            return "";
        }

        var user = UserSession.user;

        var displayText = [];
        displayText.push(user.firstName);
        displayText.push(user.lastName);
        displayText = displayText.join(" ");

        if ( AuthService.isAuthorized("SURGEON") ) {
            displayText += ", MD";
        }

        return displayText;
    };

    //
    // Return current user's role
    //
    $scope.getCurrentUserRoleDisplayText = function() {

        if ( !AuthService.isAuthenticated() ) {
            return "";
        }

        // Note: must check surgeon before user as a surgeon is categorized
        // as a user for authorization
        if ( AuthService.isAuthorized(USER_ROLES.surgeon) ) {
            return "Surgeon";
        }

        if ( AuthService.isAuthorized(USER_ROLES.user) ) {
            return "Scheduler";
        }

        if ( AuthService.isAuthorized(USER_ROLES.rep) ) {
            return "Rep";
        }

        if ( AuthService.isAuthorized(USER_ROLES.admin) ) {
            return "Admin";
        }
    };

    //
    //
    //
    $scope.logout = function() {

        $state.go(ROUTES.LOGOUT);
    };

    //
    // Show create case page
    //
    $scope.showCreateCase = function() {

        $state.go(ROUTES.CASE_NEW);
    };


    //
    // Show dashboard
    //
    $scope.showDashboard = function() {

        $state.go(ROUTES.CASES_ACTIVE);
    };

    //
    // PRIVATES
    //

    //
    // init function
    // handles all the initialization variable
    //
    function init() {

        // variable holder for menu
        $scope.menu = [];

        // Assign a correct path for specific user
        // admin, route is admin/procedure
        // user, routes is cases/active
        $scope.homeLink = (AuthService.isAuthorized(USER_ROLES.admin)) ? "/admin/procedures" :   $scope.homeLink = "/cases/active";
    }
});

//
// TODO(skin) remove this
//

"use strict";

angular.module("mtApp").controller("SecondaryNavController", function ($scope, $location, USER_ROLES) {

    $scope.menu = [
        {
            "title": "Dashboard",
            "link": "/cases/active",
            "role": [USER_ROLES.user, USER_ROLES.surgeon, USER_ROLES.rep],
            "activeKey": "case"
        },
        {
            "title": "Profile",
            "link": "/profile/info",
            "role": [USER_ROLES.user, USER_ROLES.surgeon, USER_ROLES.rep],
            "activeKey": "profile"
        },
        {
            "title": "Administration",
            "link": "/admin/procedures",
            "role": USER_ROLES.admin,
            "activeKey": "admin"
        }
    ];

    //
    // Returns true if route matches the current path
    //
    $scope.isActive = function(activeKey) {

        return $location.path().indexOf(activeKey) >= 0;
    };
});

//
// Footer Controller
//

'use strict';

angular.module('mtApp').controller('FooterController', function ($scope, AuthService, ngDialog, USER_ROLES) {

    // Assign a correct path for specific user
    // admin, route is admin/procedure
    // user, routes is cases/active
    $scope.homeLink = (AuthService.isAuthorized(USER_ROLES.admin)) ? "/admin/procedures" :   $scope.homeLink = "/cases/active";

    //
    // Show disclaimer
    //
    $scope.showDisclaimer = function() {

        ngDialog.open({
            closeByDocument: false,
            closeByEscape: false,
            template: "/partials/site/disclaimer",
            className: "ngdialog-default mt-dialog emr-notes wide",
            showClose: true
        });
    }

});

'use strict';

angular.module('mtApp').controller('HomeController', function ($scope) {

});

"use strict";


angular.module("mtApp").controller("MainController", function ($rootScope, $scope, USER_ROLES, AuthService, UserSession) {

    // Make user session details available to all
    $scope.currentUser = UserSession.user;
    $scope.userRoles = USER_ROLES;
    $scope.isAuthenticated = AuthService.isAuthenticated;

    // Listen for changes in layout - print view hides all navigation
    $scope.$on("cc-layout:print-view", function () {

        $scope.ccLayout = "print-view";
    });

    // True if a child controller is executing a blocking task (eg showing
    // modal)
    $scope.MODAL_OPEN = false;

    // Set "blocked" to true if there is a open dialog
    $rootScope.$on("ngDialog.opened", function () {

        $scope.MODAL_OPEN = true;
    });

    // Set "blocked" to true if there is a open dialog
    $rootScope.$on("ngDialog.closed", function () {

        $scope.MODAL_OPEN = false;
    });

    //
    // Returns true if the user is currently logged in
    //
    $scope.isHasCurrentUser = function() {

        return !angular.equals({}, UserSession.user);
    };


    //
    // Returns true if the current user has the ADMIN role. Will return
    // false if current user is a user. Used to toggle visibility of
    // confirm case button, tertiary navigation on profile
    // pages
    //
    // TODO(mim) revisit this - polluting global space?
    //
    $scope.isRep = function() {

        return AuthService.isAuthorized(USER_ROLES.rep);
    };

    //
    // Returns true if the current user has the USER role. Will return
    // false if current user is a rep. Used to toggle visibility of
    // create/amend/cancel etc buttons, tertiary navigation on profile
    // pages
    //
    // TODO(mim) revisit this - polluting global space?
    //
    $scope.isUser = function() {

        return AuthService.isAuthorized(USER_ROLES.user) || AuthService.isAuthorized(USER_ROLES.surgeon);
    };

    //
    // Returns true if the current user has the REP role. Will return
    // false if current user is a user. Used to toggle visibility of
    // confirm case button, tertiary navigation on profile
    // pages
    //
    // TODO(mim) revisit this - polluting global space?
    //
    $scope.isRep = function() {

        return AuthService.isAuthorized(USER_ROLES.rep);
    };
});

//
// Login controller
//

"use strict";

angular.module("mtApp").controller("LoginController", function ($scope, $rootScope, $state, AUTH_EVENTS, AuthService, $stateParams, $location, USER_ROLES, UserService, ROUTES) {

    $scope.user = {};
    $scope.errors = {};

    //
    // Login
    //
    $scope.login = function(form) {

        $scope.submitted = true;

        if ( form.$valid ) {

            var email = $scope.user.email.toLowerCase();
            if ( email.trim ) {
                email = email.trim();
            }
            else {
                email = email.replace(/^\s+|\s+$/gm,"");
            }

            AuthService.login({
                email: email,
                password: $scope.user.password
            })
            // Login was successful - redirect to cases page
            .then(function() {

                if( AuthService.isAuthorized(USER_ROLES.admin) ){
                    $state.go(ROUTES.ADMIN_PROCEDURES);
                }
                else{
                    $state.go(ROUTES.CASES_ACTIVE);
                }

                // Broadcast login success
                $rootScope.$broadcast(AUTH_EVENTS.loginSuccess);
            })
            // Login failed - display errors
            ["catch"]( function(err) {

                // Broadcast login failed
                $rootScope.$broadcast(AUTH_EVENTS.loginFailed);

                err = err.data;
                $scope.errors.other = err.message;
            });
        }
    };

    //
    // Request password reset
    //
    $scope.requestResetPassword = function(form) {

        $scope.resetRequestSubmitted = true;

        if ( form.$valid ) {

            UserService.requestResetPassword($scope.user.email.toLowerCase()).then(function () {

                // Email has been sent - notify user
                $scope.emailSent = true;

            })["catch"]( function(err) {

                err = err.data;
                $scope.errors = {};

                // Update validity of form fields that match the mongoose errors
                angular.forEach(err.errors, function(error, field) {
                    form[field].$setValidity("mongoose", false);
                    $scope.errors[field] = error.message;
                });
            });
        }

    };

    //
    // Reset password
    //
    $scope.resetPassword = function(form) {

        $scope.resetSubmitted = true;

        if ( form.$valid ) {

            UserService.resetPassword($stateParams.forgotKey, $scope.user.password, form.passwordConfirm.$viewValue).then(function() {

                // Password updated - redirect user to login
                $state.go(ROUTES.LOGIN_RESET);

            })["catch"]( function(err) {

                err = err.data;
                $scope.errors = {};

                // Update validity of form fields that match the mongoose errors
                angular.forEach(err.errors, function(error, field) {
                    form[field].$setValidity("mongoose", false);
                    $scope.errors[field] = error.message;
                });

            });
        }

    };

    //
    // Returns true if the login form is being
    // displayed after the user has activated
    // their account
    //
    $scope.isActivatedRedirect = function() {
        return !!$state.current.data.activate;
    };

    //
    // Returns true if the login form is being displayed
    // after the user has reset their password
    //
    $scope.isResetPasswordRedirect = function() {

        return !!$state.current.data.reset;
    };

    //
    // Returns true if there are errors with the login form
    //
    $scope.isHasErrors = function() {

        for ( var key in $scope.errors ) {
            return true;
        }

        return false;
    };
});

//
// Controller for handling errors
// - Adds minor code to scope
//

'use strict';

angular.module('mtApp').controller('ErrorController', function ($scope, $stateParams) {

    init();

    //
    // PRIVATES
    //

    //
    // Initialize scope
    //
    function init() {

        $scope.minorCode = $stateParams.minorCode;
    }
});

//
// Assertion service
//

"use strict";

angular.module("mtApp").factory("AssertionService", function AssertionService(AssertionDAO) {

    return {


        //
        // Calculate the implant quality (high, medium, standard)
        //
        calculateImplantQuality: function (bmiAgeRatio, area, next) {

            next = next || angular.noop;

            return AssertionDAO.calculateImplantQuality({
                bmiAgeRatio: bmiAgeRatio,
                  area: area
            }, next).$promise;
        },

        //
        // Find available areas by CPT code
        //
        findAreaUriByCpt: function(cptCode, callback) {

            callback = callback || angular.noop;

            return AssertionDAO.findAreaUriByCpt({
                cptCode: cptCode
            }, callback).$promise;
        }
    };
});

//
// Assertion DAO
//

"use strict";

angular.module("mtApp").factory("AssertionDAO", function ($resource) {

    return $resource("/api/areas/:id", {
    }, {
        calculateImplantQuality: {
            method: "GET",
            url: "/api/assertions/implant-quality"
        },
        findAreaUriByCpt: {
        method: "GET",
        url: "/api/assertions/cpt-area"
        }
    });
});

//
// Abstract cases controller
// - Responsible for case-related list functionality
//

'use strict';

angular.module('mtApp').controller('AbstractCasesController', function ($scope) {

    // Initialize controller
    init();

    //
    // Privates
    //

    //
    // Initialize controller
    //
    function init() {

    }
});

//
// Active cases controller
// - Responsible for case-related list functionality when displaying active cases
//

"use strict";

angular.module("mtApp").controller("ActiveCasesController", function ($interval, $rootScope, $scope, $state, $stateParams,
                                                                      ROUTES, PAGINATION, QMService, CaseService,
                                                                      favoritesEnabled, cases, totalCaseCount, unconfirmedCaseCount) {

    // Filter display text keyed by filter type
    var FILTER_DISPLAY_TEXT_BY_TYPE = {
        confirmedGeneral: "Unconfirmed by Rep",
        confirmedSterilizationDate: "Unconfirmed by Sterilization Date",
        confirmedTrayDetails: "Unconfirmed by Tray Delivery",
        confirmedImplantDelivery: "Unconfirmed by Implant Delivery"
    };

    // Initialize controller
    init();

    //
    // Clear the Medtel ID filter and show all active cases
    //
    $scope.clearFilterByMedtelId = function() {

        $scope.filters.medtelId = "";
        $rootScope.$broadcast("cc-pagination:refresh");
    };

    //
    // Returns true if current user has confirmed the
    // implants they are responsible for
    //
    $scope.isHasRepConfirmedAllCases = function() {

        return $scope.unconfirmedCaseCount.count === 0;
    };

    ////
    //// Filter cases by confirmation status. If no filter is selected,
    //// navigate to all active cases.
    ////
    //$scope.filterCasesByConfirmationStatus = function() {
    //
    //    if ( $scope.filters.filterByConfirmation ) {
    //
    //        $state.go(ROUTES.CASES_FILTER, {
    //            filterType: $scope.filters.filterByConfirmation
    //        });
    //    }
    //    else {
    //
    //        $state.go(ROUTES.CASES_ACTIVE);
    //    }
    //};

    //
    // Show only the case with the specified Medtel ID
    //
    $scope.findCaseByMedtelId = function(medtelId) {

        $scope.filters.medtelId = medtelId;
        $rootScope.$broadcast("cc-pagination:refresh");
    };

    //
    // Access to finding cases for pagination functionality (next/previous) or
    // for auto refresh of list
    //
    $scope.findAllCases = function(pagination, callback) {

        callback = callback || angular.noop;

        var qm = QMService.getInstance("ACTIVE_CASE");
        qm.setOffset(pagination.offset);
        qm.setLimit(pagination.limit);
        qm.addQueryParam("wasNotMe", $scope.wasNotMe);

        if ( $scope.filters.medtelId ) {

            CaseService.findCaseByMedtelId(qm, $scope.filters.medtelId, favoritesEnabled.enabled, $scope.currentUser, function(cases) {

                $scope.cases = cases;
                callback(cases, 1);
            });
        }
        else if ( $scope.filters.filterByConfirmation ) {

            CaseService.findAndCountActiveCasesWithUnconfirmedImplants(qm, $stateParams.filterType, favoritesEnabled.enabled, $scope.currentUser, function(result) {

                $scope.cases = result.items;
                callback(result.items, result.count);
            });
        }
        else {

            // Find and count the active cases for the current user
            CaseService.findAndCountActiveCases(qm, favoritesEnabled.enabled, $scope.currentUser, function(result) {

                $scope.cases = result.items;
                callback(result.items, result.count);
            });

            // If the current user is a rep, also update the
            // count of unconfirmed cases
            if ( $scope.isRep() ) {

                CaseService.countRepUnconfirmedCases($scope.currentUser._id, function(unconfirmedCaseCount) {

                    $scope.unconfirmedCaseCount = unconfirmedCaseCount;
                });
            }
        }
    };

    //
    // Privates
    //

    //
    // Initialize controller
    //
    function init() {

        // Set up cases/count for current page of cases
        $scope.cases = cases;
        $scope.casesCount = totalCaseCount.count;

        // Set up the unconfirmed case count for reps. It's possible
        // there is no count here if the current user is a scheduler.
        // Also, need to keep this as an object as the count needs to be
        // updatable in a child (case list item) scope (ie when a
        // case is confirmed)
        $scope.unconfirmedCaseCount = unconfirmedCaseCount || {
            count: 0
        };

        // Set default filter
        var filterType = $stateParams.filterType || "";
        $scope.filters = {
            filterByConfirmation: filterType,
            medtelId: ""
        };

        // Setup filter name
        if ( filterType ) {
            $scope.filterName = FILTER_DISPLAY_TEXT_BY_TYPE[filterType];
        }
        else {
            $scope.filterName = "Active Cases";
        }

        // Setup auto refresh
        var refreshPromise = $interval(autoRefresh, 30000);
        $scope.$on("$destroy", function () {
            $interval.cancel(refreshPromise);
        });
    }

    //
    // Auto refresh case list
    //
    function autoRefresh() {

        if ( !$scope.MODAL_OPEN ) {
            $scope.wasNotMe = true;
            $rootScope.$broadcast("cc-pagination:refresh");
        }

    }
});

//
// Archived cases controller
// - Responsible for case-related list functionality when displaying closed
// and canceled cases
//

"use strict";

angular.module("mtApp").controller("ArchivedCasesController", function ($scope, CaseService, QMService, favoritesEnabled, cases, totalCaseCount) {

    // Initialize controller
    init();

    //
    // Access to finding cases for pagination functionality (next/previous)
    //
    $scope.findAllCases = function(pagination, callback) {

        var qm = QMService.getInstance("INACTIVE_CASE");
        qm.setOffset(pagination.offset);
        qm.setLimit(pagination.limit);

        CaseService.findAndCountClosedAndCanceledCases(qm, favoritesEnabled.enabled, $scope.currentUser, function(result) {

            $scope.cases = result.items;
            callback(result.items, result.count);
        });
    };

    //
    // Privates
    //

    //
    // Initialize controller
    //
    function init() {

        $scope.cases = cases;
        $scope.casesCount = totalCaseCount.count;

        // Indicate we are looking at closed/canceled cases
        $scope.archived = true;

        $scope.filterName = "Closed and Canceled Cases";
    }
});

//
// Comment controller
//

"use strict";

angular.module("mtApp").controller("CommentController", ["$scope", "ngDialog", "CommentService", function ($scope) {


}]);

"use strict";

angular.module("mtApp").controller("CommentFormController", ["$scope", "ngDialog", "CommentService", function ($scope, ngDialog, CommentService) {

    init();
    // Adding an empty array for comments.comments object

    //
	// Adding a comments
    //
	$scope.createComment = function () {

        // Close dialog
        ngDialog.closeAll();

		// Push the comments to the comments array - we want
        // the comment to show up immediately
		$scope.comments.push({
            message: $scope.comment.message,
            author: {
                _id: $scope.currentUser,
                firstName: $scope.currentUser.firstName,
                lastName: $scope.currentUser.lastName,
                role: $scope.currentUser.role
            }
        });

        // Increment the comment count on the case on the UI
        $scope["case"].commentsCount++;

        // Build up post data of the case
        var data = {
            medtelId : $scope["case"].medtelId,
            author: $scope.currentUser._id,
            comments: $scope.comment.message,
            entityType: "Case"
        };

        // Reset the message box
		$scope.comment.message = "";

		// Sends a post request to the server
        CommentService.createComment($scope["case"]._id, data, function (saved) {

            // Handle error case
			if ( !saved ) {

                // Decrement the comment count on the case on the UI
                $scope["case"].commentsCount--;

                // Remove latest comment from UI
				$scope.comments.pop();
			}
		});
	};

    //
    // PRIVATES
    //

    //
    // Set up controller
    //
    function init() {

        // Fetch the comments
        CommentService.getCommentCaseById($scope["case"]._id, function (comments) {
            $scope.comments =  comments;
        });

        // Set up dummy comment for form
        $scope.comment = {
            message: ""
        };
    }
}]);

//
// Case confirmation controller
//

'use strict';

angular.module('mtApp').controller('CaseConfirmationController', function ($scope, CaseService, surgeon, kase) {

    // Initialize controller
    init();


    //
    // Initialize state of list item
    //
    function init() {

        $scope["case"] = kase;
        $scope.surgeon = surgeon;

        // Update case as confirmed if it hasn't already been confirmed...
        if ( !CaseService.isConfirmed($scope.currentUser, $scope["case"]) ) {
            CaseService.confirmCaseGeneral($scope["case"]._id);
        }
    }

});

//
// Case activity controller
//

"use strict";

angular.module("mtApp").controller("CaseActivityController", function ($scope, comments) {

    // Setup the controller
    init();

    //
    // Return the full name of the user who executed the activity
    //
    $scope.getActorFullName = function(actor) {

        var initials = [];
        initials.push(actor.firstName);
        initials.push(actor.lastName);
        return initials.join(" ");
    };

    //
    // Return the initials of the user who executed the activity
    //
    $scope.getActorInitials = function(actor) {

        var initials = [];
        initials.push(actor.firstName.substring(0, 1));
        initials.push(actor.lastName.substring(0, 1));
        return initials.join(" ");
    };

    //
    // PRIVATES
    //

    //
    // Initialize the scope
    //
    function init() {

        // Reverse the order of the comments as we
        // want the newest on top
        $scope.comments = comments.reverse();
    }
});

//
//
//

"use strict";

angular.module("mtApp").controller("CaseController", function ($scope, $state, ROUTES, CaseService, kase) {

    // Initialize controller
    init();

    //
    // Toggle visibility of activity feed
    //
    $scope.toggleActivity = function() {

        if ( $scope.showActivity ) {
            $state.go(ROUTES.CASE_SHOW);
            $scope.showActivity = false;
        }
        else {
            $state.go(ROUTES.CASE_ACTIVITY);
            $scope.showActivity = true;
        }
    };

    //
    // PRIVATES
    //

    //
    // Initialize state of list item
    //
    function init() {

        // Check if we're display the activity feed straight
        // off the bat
        $scope.showActivity = ($state.current.url.indexOf("activity") >= 0);

        $scope["case"] = kase;

        // Format amendments
        initAmendments();

    }

    //
    // Format amendments into view friendly format...
    //
    function initAmendments() {

        $scope.amendments = [];

        // Grab the amendment objects (changes and change meta)
        // from the case
        var amendmentObjs = $scope["case"].amendments;
        _.each(amendmentObjs, function(amendmentObj) {

            var changedBy = amendmentObj.changedBy;
            var amendedDate = amendmentObj.amendedDate;

            // Iterate over the keys in the amendment checking
            // for attributes that are in fact amendments (and not
            // meta such as _id, changedBy, change date etc)
            for ( var key in amendmentObj ) {

                var attr = amendmentObj[key];
                if ( !attr.to && !attr.from ) {
                    continue;
                }

                $scope.amendments.push({
                    changedBy: changedBy,
                    amendedDate: amendedDate,
                    fieldName: key,
                    from: attr.from,
                    to: attr.to
                });
            }
        });
    }
});

"use strict";

angular.module("mtApp").controller("CaseListItemController", function ($rootScope, $state, $location, $scope, OrganizationService, CaseService, CaseDAO, ngDialog, ROUTES) {

    // Initialize controller
    init();

    //
    // Cancel case
    //
    $scope.cancelCase = function() {

        ngDialog.closeAll();

        var caseId = $scope["case"]._id;
        CaseDAO.cancel({
            id:caseId
        }, function() {

            // Case successfully canceled - find index of case
            // in list and remove from scope
            for ( var i =  0 ; i < $scope.cases.length ; i++ ) {

                var kase = $scope.cases[i];
                if ( kase._id === $scope["case"]._id ) {
                    break;
                }
            }
            $scope.cases.splice(i, 1);
            $rootScope.$broadcast("update:remove");
        });
    };

    //
    // Cancel case
    //
    $scope.closeCase = function() {

        ngDialog.closeAll();

        var caseId = $scope["case"]._id;
        CaseDAO.close({
            id:caseId
        }, function() {

            // Case successfully canceled - find index of case
            // in list and remove from scope
            for ( var i =  0 ; i < $scope.cases.length ; i++ ) {

                var kase = $scope.cases[i];
                if ( kase._id === $scope["case"]._id ) {
                    break;
                }
            }
            $scope.cases.splice(i, 1);
            $rootScope.$broadcast("update:remove");
        });
    };

    //
    // Edit case
    //
    $scope.editCase = function() {

        $state.go(ROUTES.CASE_EDIT, {
            id: $scope["case"]._id
        });
    };

    //
    // Return the value for the specified field name, otherwise
    // return "N/A"
    //
    $scope.getDisplayText = function(fieldName) {

        var value = $scope["case"][fieldName];
        if ( value ) {
            return value;
        }

        return "N/A";
    };

    //
    // Return the gender specified on this case, or N/A if
    // not specified
    //
    $scope.getGenderDisplayText = function() {

        var gender = generateDisplayText($scope["case"].gender);
        if ( gender ) {
            gender = gender.toUpperCase();
        }
        return gender;
    };

    //
    // Return display text for height
    //
    $scope.getHeightDisplayText = function() {

        var height = $scope["case"].height;
        if ( height && height.value ) {

            var feet = Math.floor(height.value / 12);
            var inches = height.value % 12;

            return feet + "' " + inches + "\"";
        }

        return "N/A";
    };

    //
    // Return the name of the hospital if user's organization
    // is a practice OR user's organization is a hospital and
    // the hospital is in a group.
    //
    $scope.getHospitalDisplayText = function() {

        return $scope["case"].surgeryLocation.name;
    };

    //
    // Returns implany category if CPT category is SPINE,
    // otherwise empty string
    //
    $scope.getImplantCategoryDisplayText = function(implant) {

        if ( !$scope.isSpine() ) {
            return "";
        }
        var category = implant.product.category;
        if ( category === "FIXATION" ) {
            return "Fixation: ";
        }

        return "Interbody: ";
    };

    //
    // Return status of case - closed, canceled, confirmed etc
    //
    $scope.getCaseStatusDisplayText = function() {

        // We're looking at archived cases - only possible statuses are
        // closed or canceled
        if ( $scope.archived ) {

            if ( $scope.isCanceled() ) {
                return "CANCELED";
            }
            else {
                return "CLOSED";
            }
        }

        // Otherwise we're looking at active cases - return confirmation status
        if ( $scope.isUnconfirmed() ) {

            return "Unconfirmed";
        }
        else if ( $scope.isPartiallyConfirmed() ) {

            return "Partially Confirmed";
        }

        return "Confirmed";
    };

    //
    // Return the title of the case:
    //
    // #Medtel ID / Surgeon / Area / Surgery Location
    //
    $scope.getCaseTitle = function() {

        var caseTitle = [];
        caseTitle.push("#" + $scope["case"].medtelId);
        caseTitle.push($scope.getSurgeonFullName());

        if ( $scope["case"].area ) {
            caseTitle.push($scope.getDisplayText("area"));
        }
        caseTitle.push($scope["case"].surgeryLocation.name);

        return caseTitle.join(" / ");
    };

    //
    // {{getImplantCategoryDisplayText(implant)}}{{implant.manufacturer.name}}&nbsp;{{implant.product.name}}
    //
    $scope.getImplantDisplayText = function(implant) {

        var implantText = [];

        var implantCategory = $scope.getImplantCategoryDisplayText(implant);
        if ( implantCategory ) {
            implantText.push(implantCategory);
        }

        implantText.push(implant.product.name);
        implantText.push("/");
        implantText.push(implant.rep.firstName);
        implantText.push(implant.rep.lastName + ",");
        implantText.push(implant.manufacturer.name);

        return implantText.join(" ");
    };

    //
    // Return schedulers's full name in the format:
    //
    // First Name Last Name
    //
    $scope.getScheduledByFullName = function() {

        var schedulerDisplayText = [];
        schedulerDisplayText.push($scope["case"].scheduledBy.firstName);
        schedulerDisplayText.push($scope["case"].scheduledBy.lastName);

        return schedulerDisplayText.join(" ");
    };

    //
    // Return surgeon's full name in the format:
    //
    // Last Name, First Name here mim
    //
    $scope.getSurgeonFullName = function() {

        var surgeonDisplayText = [];
        surgeonDisplayText.push($scope["case"].surgeon.lastName);
        surgeonDisplayText.push($scope["case"].surgeon.firstName);

        return surgeonDisplayText.join(", ");
    };

    // Returns the full surgeons name in the format:
    //
    // Last Name First Name, MD
    //
    $scope.getSurgeonDisplayText = function() {

        var surgeon = $scope["case"].surgeon;
        return surgeon.lastName + " " + surgeon.firstName + ", MD";
    };

    //
    // Return display text for weight
    //
    $scope.getWeightDisplayText = function() {

        var weight = $scope["case"].weight;
        if ( weight && weight.value ) {

            return weight.value;
        }

        return "N/A";
    };

    //
    // Returns true if specified field has been amended
    //
    $scope.isAmended = function(fieldName) {

        return ($scope.amendments.indexOf(fieldName) > -1);
    };

    //
    // Returns true if case has been canceled
    //
    $scope.isCanceled = function() {

        return $scope["case"].status === "CANCELED";
    };

    //
    // Returns true if case has been canceled
    //
    $scope.isClosed = function() {

        return $scope["case"].status === "CLOSED";
    };

    //
    // Returns true if user is rep, case is not archived and case
    // has not yet been confirmed by this rep.
    //
    $scope.isCanConfirmCase = function() {

        // Only reps can confirm case
        if ( !$scope.isRep() ) {
            return false;
        }

        // Rep can only confirm case if it hasn't already
        // been confirmed
        if ( CaseService.isConfirmed($scope.currentUser, $scope["case"]) ) {
            return false;
        }

        // Case can not be confirmed if it has been archived
        if ( $scope.archived ) {
            return false;
        }

        // If the case is partially confirmed, check if current
        // user has confirmed their implants
        if ( CaseService.isPartiallyConfirmed($scope.currentUser, $scope["case"]) &&
            $scope.isHasRepConfirmedAllImplants() ) {
            return false;
        }

        return true;
    };

    //
    // Returns true if no implants for case have been confirmed
    //
    $scope.isUnconfirmed = function() {

        return CaseService.isUnconfirmed($scope.currentUser, $scope["case"]);
    };

    //
    // Returns true if no implants for case have been confirmed
    //
    $scope.isPartiallyConfirmed = function() {

        return CaseService.isPartiallyConfirmed($scope.currentUser, $scope["case"]);
    };

    //
    // Returns true if all implants for case have been confirmed
    //
    $scope.isConfirmed = function() {

        return CaseService.isConfirmed($scope.currentUser, $scope["case"]);
    };

    //
    //  Returns true if current user has confirmed the
    // implants they are responsible for
    //
    $scope.isHasRepConfirmedAllImplants = function() {

        return CaseService.isHasRepConfirmedAllImplants($scope.currentUser, $scope["case"]);
    };

    //
    // Returns true if case has any fixation meta data specified (eg
    // levels, location, area)
    //
    $scope.isHasFixationMeta = function() {

        return !!($scope["case"].locationFixation || $scope.isHasFixationLevels());
    };

    //
    // Returns true if case has any fixation levels
    //
    $scope.isHasFixationLevels = function() {

        return !!($scope["case"].fixationFrom || $scope["case"].fixationTo);
    };

    // Returns true if case has any interbody meta data specified (eg
    // levels, procedure)
    //
    $scope.isHasInterbodyMeta = function() {

        return !!($scope["case"].locationInterbody || $scope["case"].interbodyProcedure || $scope.isHasInterbodyLevels());
    };

    //
    // Returns true if case has any interbody levels
    //
    $scope.isHasInterbodyLevels = function() {

        return !!($scope["case"].interbodyFrom || $scope["case"].interbodyTo);
    };

    //
    // Returns true if the category of the primary procedure
    // is spine
    //
    $scope.isSpine = function() {

        return $scope["case"].procedures[0].category === "SPINE";
    };

    //
    // Display popup with EMR notes
    //
    $scope.showEMRNotes = function() {

        $state.go(ROUTES.CASES_ACTIVE_SHOW, {id: $scope["case"]._id});
    };

    //
    // Show confirm cancel dialog
    //
    $scope.showConfirmCancelCase = function() {

        ngDialog.open({
            template:"/partials/cases/confirm-cancel.html",
            className: "ngdialog-default",
            scope: $scope
        });
    };

    //
    // Show confirm close dialog
    //
    $scope.showConfirmCloseCase = function() {

        ngDialog.open({
            template:"/partials/cases/confirm-close.html",
            className: "ngdialog-default",
            scope: $scope
        });
    };

    //
    // Confirm case
    //
    $scope.confirmCaseGeneral = function() {

        var caseId = $scope["case"]._id;
        CaseService.confirmCaseGeneral(caseId, function(kase) {

            $scope["case"].confirmationStatus = kase.confirmationStatus;
            $scope["case"].implants = kase.implants;

            // Decrement count of unconfirmed cases - don't worry about
            // hitting up the server for an exact count here as this will
            // be done by the auto refresh
            $scope.unconfirmedCaseCount.count--;

        });
    };

    //
    // Show comments popup for case
    //
    $scope.showComments = function () {

        ngDialog.open({
            template:"/partials/cases/comments.html",
            className: "ngdialog-default mt-dialog case-comments wide",
            controller: "CommentFormController",
            scope: $scope
        });
    };

    //
    // Toggle show/hide of case detail
    //
    $scope.toggleDetail = function() {

        $scope.showDetail = !$scope.showDetail;
    };


    //
    // PRIVATES
    //

    //
    // Return the text if specified, otherwise return "N/A"
    //
    function generateDisplayText(value) {

        if ( value ) {
            return value;
        }

        return "N/A";
    }

    //
    // Initialize state of list item
    //
    function init() {

        $scope.showDetail = !$scope.archived;

        // Setup array of names of fields that have been updated - used for
        // easy checking/highlighting
        var amendments = [];
        _.each($scope["case"].amendments, function(amendment) {

            for ( var key in amendment ) {

                var value = amendment[key];

                // Must check if we are dealing with array values and check if there
                // elements in each array (as arrays are created as
                // default in Mongo so we can't use existence of the field to
                // determine if changes have been made
                if ( _.isArray(value.to) && _.isArray(value.from) ) {

                    if ( value.to.length || value.from.length ) {

                        amendments.push(key);
                    }
                }
                // All non-array values can be added as is
                else {

                    amendments.push(key);
                }
            }
        });

        $scope.amendments = _.unique(amendments);
    }
});

//
// Case form controller
//

"use strict";

angular.module("mtApp").controller("CaseFormController", function ($scope, $location, $state,
                                                                   CPT_CATEGORIES, ROUTES, CaseService,
                                                                   OrganizationService, ProcedureService, PersonService, ProductSourceService,
                                                                   favoritesEnabled, hospitals, procedures, kase) {

    //
    // Calculate BMI if height and weight is specified/valid
    // Calculate BMI/Age ratio if age is also specified
    //

    $scope.calculateBmiMetrics = function(form) {

        // Check we have the necessary data
        if ( !($scope["case"].weight && $scope["case"].weight.value) || !$scope["case"].heightFeet ) {

            $scope.bmi = "";
            $scope.bmiAgeRatio = "";

            return;
        }

        // Check the values are valid (only required if form param
        // is specified. That is, only validate values if trigger
        // is coming from form)
        if ( form && !(form.weight.$valid  && form.heightInches.$valid  && form.heightFeet.$valid) ) {
            $scope.bmi = "";
            $scope.bmiAgeRatio = "";
            return;
        }

        // OK, we're good to go...
        CaseService.calculateBmiMetrics($scope["case"], function(response) {

            $scope.bmi = response.data.bmi;

            if( form && !form.age.$valid ) {
                $scope.bmiAgeRatio = "";
                return;
            }
            $scope.bmiAgeRatio = response.data.bmiAgeRatio;
        });
    };

    //
    // Clear out selected implants - called on edit case when surgery
    // location is changed
    //
    $scope.clearSelectedImplants = function() {

        if ( $scope.isSpine() ) {

            $scope["case"].fixations = [];
            $scope["case"].interbodies = [];
            $scope["case"].monitoringProducts = [];
            $scope["case"].boneGraftProducts = [];
        }
        else {

            $scope["case"].implants = [];
        }

        $scope["case"].ancillaryProducts = [];
    };

    //
    // Create case
    //
    $scope.createCase = function(form) {

        $scope.submitted = true;

        if ( $scope.isSpine() ) {
            validateSpineImplants(form);
        }

        if ( form.$valid && !$scope.selectOneSpineImplant ) {

            // Debounce submit button
            $scope.debounce = true;

            // Create case
            CaseService.createCase($scope["case"], function(kase) {

                // Return to case list
                $state.go(ROUTES.CASES_ACTIVE_SHOW, {id: kase._id});
            });
        }
    };

    //
    // Update case
    //
    $scope.updateCase = function(form) {

        $scope.submitted = true;

        if ( $scope.isSpine() ) {
            validateSpineImplants(form);
        }

        if ( form.$valid ) {

            // Debounce submit button
            $scope.debounce = true;

            // Create case
            CaseService.updateCase($scope["case"], function() {

                // Return to case list
                $state.go(ROUTES.CASES_ACTIVE);
            });
        }
    };

    //
    // Generate display text for specified product/implant - required
    // for typeahead menu.
    //
    // If product type is IMPLANT, append rep name. Otherwise just
    // display product name and manufacturer name.
    //
    $scope.getProductDisplayText = ProductSourceService.getProductSourceDisplayText;

    //
    // Generate display text for specified procedure - required for
    // typeahead menu
    //
    $scope.getProcedureDisplayText = ProcedureService.getProcedureDisplayText;

    //
    // Generate display text for selected specified procedure - required
    // for typeahead menu
    //
    $scope.getProcedureSelectedText = ProcedureService.getProcedureSelectedText;

    //
    // Return display text for surgeon select box in format:
    // firstName lastName
    //
    $scope.getSurgeonDisplayText = PersonService.getSurgeonDisplayText;

    //
    // Procedure has been selected in typeahead - check if
    // this is the first procedure selected and if so,
    // update procedure details
    //
    $scope.handleProcedureSelected = function(procedure) {

        // Update procedure details
        if ( $scope["case"].procedures.length === 1 ) {
            $scope["case"].procedureDetails = procedure.description;
        }
    };

    //
    // Procedure has been removed from typeahead - check if
    // this is the first procedure and if so, update procedure details
    //
    $scope.handleProcedureRemoved = function(procedure, index) {

        // If we removed the first (primary) procedure, update
        // procedure details box
        if ( index === 0 ) {

            // If there are no procedures specified, clear the procedure
            // notes
            if ( $scope["case"].procedures.length === 0 ) {
                $scope["case"].procedureDetails = "";
            }
            // Otherwise grab the description of the first procedure in the list
            // of selected procedures
            else {

                var newPrimaryProcedure = $scope["case"].procedures[0];
                $scope["case"].procedureDetails = newPrimaryProcedure.description;

                // If we have changed the CPT category of the primary procedure,
                // clear out any selected implants
                if ( newPrimaryProcedure.category !== procedure.category ) {
                    $scope.clearSelectedImplants();
                }
            }

            // Let listeners know primary procedure has been changed
            $scope.$broadcast("case.procedure.removed");
        }
    };

    //
    // Returns true if user has selected both hospital and procedure
    // and the second half of the case initiation form (eg implants,
    // area, location etc) can therefore be displayed.
    //
    $scope.isShowCPTSpecificForm = function() {

        return $scope["case"].surgeryLocation && $scope["case"].procedures.length > 0;
    };

    //
    // Returns true if the category of the primary procedure
    // is sports medicine
    //
    $scope.isSportsMedicine = function() {

        return CaseService.isSportsMedicine($scope["case"]);
    };

    //
    // Returns true if the category of the primary procedure
    // is neurosurgery
    //
    $scope.isNeurosurgery = function() {

        return CaseService.isNeurosurgery($scope["case"]);
    };

    //
    // Returns true if category of primary procedure is orthopedics
    //
    $scope.isOrthopedic = function() {

        return CaseService.isOrthopedic($scope["case"]);
    };

    //
    // Returns true if the category of the primary procedure
    // is spine
    //
    $scope.isSpine = function() {

        return CaseService.isSpine($scope["case"]);
    };

    //
    // Update name of write in from specified write in text - callback
    // from typeahead
    //
    $scope.updateWriteInProductName = function(writeInProduct, text) {

        writeInProduct.product.nameBackup = writeInProduct.product.name;
        writeInProduct.product.name = text;
    };

    //
    // Revert name of write in product (write has been completed but subsequently
    // removed - revert name back to original text)
    //
    $scope.revertWriteInProductName = function(writeInProduct) {

        var originalDisplayText = writeInProduct.product.nameBackup;

        // If there isn't any a backup name for this product, force it
        // to be "Write in for" text. This will be true in the case
        // of editing a case where a write in has been saved as an implant,
        // but is being removed on edit.
        if ( !originalDisplayText ) {
            originalDisplayText = "* Write in for";
        }

        writeInProduct.product.name = originalDisplayText;
        delete writeInProduct.product.nameBackup;
    };

    //
    // Returns true if there is more than one affiliated organization (ie an
    // organization other than the user's home organization) to select from
    //
    $scope.isHasAffiliatedOrganizations = function() {

        return !!OrganizationService.findAffiliatedHospitals($scope.currentUser).length;
    };

    // Initialize controller
    init();

    //
    // Privates
    //

    //
    // Setup controller
    //
    function init() {

        // Set up scope...
        $scope.userOrganization = $scope.currentUser.organizations.home;
        $scope.hospitals = hospitals;
        $scope.procedures = procedures;
        $scope.favoritesEnabled = favoritesEnabled.enabled;

        // Set up dummy case
        initCase();

        // Init watch on change of surgey location - we need to update
        // surgeons...
        initSurgeryLocationWatch($scope);

        // Set up default values on form
        selectFirstIfOnlyOne($scope.hospitals, "surgeryLocation");

        // Setup watch on BMI age ratio
        initBMIAgeRatioWatch();
    }

    //
    // Set up case
    //
    function initCase() {

        $scope["case"] = kase;

        initCaseDefaults();

        // Set up the location for the surgery. If user is a hospital user and the
        // user's hospital is not in a group, default the surgery location to the
        // user's home organization. Otherwise the user must select the surgery location
        // from a list of locations
        if ( !OrganizationService.isPractice($scope.currentUser) && !OrganizationService.isHospitalInGroup($scope.currentUser) ) {

            $scope["case"].surgeryLocation = $scope.currentUser.organizations.home._id;
        }
    }

    //
    // Set default fields on case if they are not already set. For example,
    // we must have the implants array already instantiated on the case for
    // the typeahead to add/remove from
    //
    function initCaseDefaults() {

        $scope["case"].procedures = $scope["case"].procedures || [];

        // Setup values if this is an edit
        if ( $scope["case"]._id ) {

            // Update date to use dateFormatted value
            $scope["case"].date = $scope["case"].dateFormatted;

            // Split height into feet and inches
            var height = $scope["case"].height;
            if ( height && height.value ) {

                $scope["case"].heightFeet = Math.floor(height.value / 12);
                $scope["case"].heightInches = height.value % 12;
            }
        }

        $scope.calculateBmiMetrics();
    }

    //
    // Initialize watch on surgery location - must update list of surgeons
    // to match selected surgery location
    //
    function initSurgeryLocationWatch($scope) {

        // Add watch on location - we need to update surgeons on change
        // of location
        $scope.$watch("case.surgeryLocation", function(newValue) {

            if ( newValue ) {

                $scope.$broadcast("case.surgeryLocation.updated");

                if ( newValue._id ) {
                    newValue = newValue._id;
                }

                PersonService.findUserSurgeons($scope.currentUser, newValue, $scope.favoritesEnabled, function(surgeons) {
                    $scope.surgeons = surgeons;
                    selectFirstIfOnlyOne($scope.surgeons, "surgeon");
                });
            }
            else {

                $scope.surgeons = [];

            }

        });
    }

    //
    // Select first and only option in array if there is only one
    // option - used for setting up select boxes
    // TODO(mim) move to directive
    //
    function selectFirstIfOnlyOne(options, fieldName) {

        if ( options.length === 1 ) {
            $scope["case"][fieldName] = options[0]._id;
        }
    }

    //
    // Validate at least one fixation or one interbody implant
    // has been selected
    //
    function validateSpineImplants() {

        var error = (!$scope["case"].fixations.length && !$scope["case"].interbodies.length);
        $scope.selectOneSpineImplant = error;
    }

    //
    // Broadcast notification that BMI/age ratio has changed
    //
    function initBMIAgeRatioWatch() {

        // Add watch on location - we need to update surgeons on change
        // of location
        $scope.$watch("bmiAgeRatio", function() {

            // Let others know the BMI age ratio has changed (eg to re-calculate
            // implant demand)
            $scope.$broadcast("case.bmiAgeRatio.updated");
        });
    }
});

//
// Case implant
//

"use strict";

angular.module("mtApp").controller("CaseImplantListItemController", function ($location, $scope, CaseService, TrayService, ngDialog) {

    //
    // Confirm implant delivery - save updates and update display
    //
    $scope.confirmImplantDelivery = function() {

        $scope.debounce = true;

        // Close dialog
        ngDialog.closeAll();

        var caseId = $scope["case"]._id;
        var implantId = $scope.implant._id;

        CaseService.confirmImplantDelivery(caseId, implantId, function(kase) {

            $scope["case"].implants = kase.implants;
        });
    };

    //
    // Confirm sterilization - save updates and update display
    //
    $scope.confirmSterilizationDate = function() {

        $scope.debounce = true;

        // Close dialog
        ngDialog.closeAll();

        var caseId = $scope["case"]._id;
        var implantId = $scope.implant._id;

        CaseService.confirmSterilizationDate(caseId, implantId, function(kase) {
            $scope["case"].implants = kase.implants;
        });
    };

    //
    // Confirm tray details - save updates and update display
    //
    $scope.confirmTrayDetails = function() {

        $scope.debounce = true;

        // Close dialog
        ngDialog.closeAll();

        var caseId = $scope["case"]._id;
        var implantId = $scope.implant._id;
        var trays = [];

        for ( var i = 0 ; i < $scope.trays.length ; i++ ) {

            var tray = $scope.trays[i];
            if ( tray.included ) {

                var trayToSave = {};

                // Setup tray according to whether
                // it's a write in
                if ( tray.writeIn ) {
                    trayToSave.name = tray.name;
                    trayToSave.writeIn = true;
                }
                else {
                    trayToSave.name = tray.name;
                    trayToSave._id = tray._id;
                }

                trayToSave.source = tray.source;
                trays.push(trayToSave);
            }
        }

        CaseService.confirmTrayDetails(caseId, implantId, trays, function(kase) {
            $scope["case"].implants = kase.implants;
        });
    };

    //
    // Show confirm implant delivery dialog
    //
    $scope.showConfirmImplantDelivery = function() {

        ngDialog.open({
            template:"/partials/cases/confirm-implant-delivery.html",
            className: "ngdialog-default mt-dialog",
            scope: $scope
        });
    };

    //
    // Show confirm sterilization date dialog
    //
    $scope.showConfirmSterilizationDate = function() {

        ngDialog.open({
            template:"/partials/cases/confirm-sterilization.html",
            className: "ngdialog-default mt-dialog",
            scope: $scope
        });
    };


    //
    // Show confirm tray details dialog - query for the full list of
    // trays applicable to the implant and match with any previously
    // selected tray confirmation values
    //
    $scope.showConfirmTrayDetails = function() {

        TrayService.findTraysByProductId($scope.implant.product._id, function(trays) {

            $scope.trays = trays;

            TrayService.updateTrayConfirmationDetailsFromImplant($scope.implant, $scope.trays);

            // Open dialog...
            ngDialog.open({
                template:"/partials/cases/confirm-tray-details.html",
                className: "ngdialog-default mt-dialog confirm-tray-details wide",
                closeByEscape: false,
                closeByDocument: false,
                scope: $scope
            });

        });
    };

    //
    // Select all trays, update source to "on shelf" if
    // tray was previously unselected
    //
    $scope.selectAllTrays = function() {

        for ( var i = 0 ; i < $scope.trays.length ; i++ ) {

            var tray = $scope.trays[i];
            if ( !tray.included ) {
                tray.included = true;
                tray.source = "0";
            }
        }
    };

    //
    // Handle toggle of "include" option for the specified tray
    //
    $scope.toggleIncludeTray = function(tray) {

        // Clear source value if tray is no longer selected
        if ( !tray.selected ) {
            tray.source = "";
        }
    };

    //
    // Add write in for new tray
    //
    $scope.addTrayWriteIn = function() {

        $scope.trays.unshift({
            name: "",
            writeIn: true
        });
    };

    //
    // Write in has been confirmed - automatically check the
    // "select for this case" checkbox
    //
    $scope.confirmTrayWriteIn = function() {

        $scope.trays[0].included = true;
    };

    //
    // Remove write in of tray
    //
    $scope.removeTrayWriteIn = function() {

        $scope.trays.shift();
    };

});

//
// Case neurosurgery form controller - "sub" controller to
// case controller, responsible for neurosurgery subform of
// case initiation screen
//

angular.module('mtApp').controller('CaseNeurosurgeryFormController', function ($scope, AreaService, LocationService, ProductSourceService) {

    init();

    //
    // PRIVATES
    //

    //
    // Initialize neurosurgery form - load related entities to
    // populate drop downs
    //
    function init() {

        // Setup default values if not already set (required for populating
        // typeaheads)
        initCaseDefaults();

        // Load up implants and ancillary products
        loadProducts();

        // Load up related locations
        LocationService.findLocationsByCPTCategory("LOCATIONS_NEUROSURGERY", setLocations);

        // Load related areas
        AreaService.findAreasByName("AREA_NEUROSURGERY", setAreas);

        // Clear out values on destroy
        $scope.$on("$destroy", function() {

            $scope["case"].implants = [];
            $scope["case"].location = "";
            $scope["case"].area = "";

            $scope["case"].ancillaryProducts = [];
            $scope["case"].notes = "";
        });

        // Handle change of surgery location - clear any location-specific
        // implants and load up set of possible values for new location
        $scope.$on("case.surgeryLocation.updated", function() {

            // Clear any selected implants...
            $scope.clearSelectedImplants();

            // Load up implants for the new surgery location
            loadProducts();
        });
    }

    //
    // Set default fields on case if they are not already set. For example,
    // we must have the implants array already instantiated on the case for
    // the typeahead to add/remove from
    //
    function initCaseDefaults() {

        $scope["case"].implants = $scope["case"].implants || [];
        $scope["case"].ancillaryProducts = $scope["case"].ancillaryProducts || [];
    }

    //
    // Find products for the selected hospital - called on initialization of
    // case form OR if selected hospital is changed
    //
    function loadProducts() {

        var surgeryLocation = $scope["case"].surgeryLocation;
        var cptCategory = $scope["case"].procedures[0].category;

        // Load up implants and ancillary products
        ProductSourceService.findUserImplants(surgeryLocation, cptCategory, $scope.favoritesEnabled, setImplants);

        // Load up ancillary products
        ProductSourceService.findUserAncillaryProducts(surgeryLocation, cptCategory, $scope.favoritesEnabled, setAncillaryProducts);
    }

    //
    // Callback from querying areas
    //
    function setAreas(areas) {

        $scope.areas = areas;
    }

    //
    // Callback from querying ancillary products
    //
    function setAncillaryProducts(products) {

        $scope.ancillaryProducts = products;
    }

    //
    // Callback from querying implants
    //
    function setImplants(implants) {

        // Sort implants...
        ProductSourceService.sortProductsForSelection(implants);

        $scope.implants = implants;
    }

    //
    // Callback from querying locations
    //
    function setLocations(locations) {

        $scope.locations = locations;
    }

});

//
// Case orthopedic form controller - "sub" controller to
// case controller, responsible for orthopedic subform of
// case initiation screen
//

"use strict";

angular.module("mtApp").controller("CaseOrthopedicFormController", function ($scope, AreaService, AssertionService, LocationService, ProductSourceService) {

    init();

    //
    // Calculate the implant demand (high, medium, standard) if BMI/age ratio
    // has been calculated and area has been selected
    //
    $scope.calculateImplantQuality = function () {

        // Clear the implant quality if no area is specified
        if (!$scope["case"].area || !$scope.bmiAgeRatio) {
            $scope.implantQuality = "";
        }

        // We have an age, check if we have a BMI ratio and if so, calculate
        // the implant quality
        if ($scope.bmiAgeRatio) {

            AssertionService.calculateImplantQuality($scope.bmiAgeRatio, $scope["case"].area, function (result) {

                $scope.implantQuality = result.demand;
            });
        }
    };

    //
    // Return text for displaying implant quality
    //
    $scope.getImplantQualityText = function () {

        if (!$scope.implantQuality ) {
            return "";
        }

        return "* Demand Category: " + $scope.implantQuality;
    };

    //
    // PRIVATES
    //

    //
    // Initialize orthopedic form - load related entities to
    // populate drop downs
    //
    function init() {

        // Setup default values if not already set (required for populating
        // typeaheads)
        initCaseDefaults();

        // Load up implants and ancillary products
        loadProducts();

        // Load up related locations
        LocationService.findLocationsByCPTCategory("LOCATIONS_ORTHOPEDIC", setLocations);

        // Load related areas
        loadAreas();

        // Clear out values on destroy
        $scope.$on("$destroy", function() {

            $scope["case"].implants = [];
            $scope["case"].location = "";
            $scope["case"].area = "";

            $scope["case"].ancillaryProducts = [];
            $scope["case"].notes = "";
        });

        // Handle change of procedure - reload areas according to newly
        // selected CPT
        $scope.$on("case.procedure.removed", function() {

            // If there is still a procedure specified, load corresponding
            // areas. If no CPT is specified, we don't need to do anything
            // as clean up of area is handled in $destroy
            reloadAreas();
        });

        // Handle change of surgery location - clear any location-specific
        // implants and load up set of possible values for new location
        $scope.$on("case.surgeryLocation.updated", function() {

            // Clear any selected implants...
            $scope.clearSelectedImplants();

            // Load up implants for the new surgery location
            loadProducts();
        });

        // Handle change of BMI ration - re-calculate implant quality
        // category if necessary
        $scope.$on("case.bmiAgeRatio.updated", function() {

            $scope.calculateImplantQuality();
        });
    }

    //
    // Set default fields on case if they are not already set. For example,
    // we must have the implants array already instantiated on the case for
    // the typeahead to add/remove from
    //
    function initCaseDefaults() {

        $scope["case"].implants = $scope["case"].implants || [];
        $scope["case"].ancillaryProducts = $scope["case"].ancillaryProducts || [];
    }

    //
    // Find products for the selected hospital - called on initialization of
    // case form OR if selected hospital is changed
    //
    function loadProducts() {

        var surgeryLocation = $scope["case"].surgeryLocation;
        var cptCategory = $scope["case"].procedures[0].category;

        // Load up implants and ancillary products
        ProductSourceService.findUserImplants(surgeryLocation, cptCategory, $scope.favoritesEnabled, setImplants);

        // Load up ancillary products
        ProductSourceService.findUserAncillaryProducts(surgeryLocation, cptCategory, $scope.favoritesEnabled, setAncillaryProducts);
    }

    //
    // Load areas - areas may be restricted by CPT code
    //
    function loadAreas() {

        var cptCode = $scope["case"].procedures[0].code;
        AssertionService.findAreaUriByCpt(cptCode, function(res) {

            if (res.uri) {
                AreaService.findAreaByUri("AREA_ORTHOPEDIC", res.uri, setAreas);
            } else {
                AreaService.findAreasByName("AREA_ORTHOPEDIC", setAreas);
            }
        });
    }

    //
    // Reload areas - clear selected area and load areas
    // according to selected CPT code
    //
    function reloadAreas() {

        // If there is still a procedure specified, load corresponding
        // areas. If no CPT is specified, we don't need to do anything
        // as clean up of area is handled in $destroy
        if ( !!$scope["case"].procedures.length ) {
            $scope["case"].area = "";
            loadAreas();
        }
    }

    //
    // Callback from querying areas
    //
    function setAreas(areas) {

        $scope.areas = areas;

        // Force select of first area if there is only one. Also
        // check if need to update the implanty quality (note: this
        // is usually triggered by the change event on the area drop down)
        if ( areas.length === 1 ) {
            $scope["case"].area = areas[0].description;
            $scope.calculateImplantQuality();
        }
    }

    //
    // Callback from querying ancillary products
    //
    function setAncillaryProducts(products) {

        $scope.ancillaryProducts = products;
    }

    //
    // Callback from querying implants
    //
    function setImplants(implants) {

        // Sort implants...
        ProductSourceService.sortProductsForSelection(implants);

        $scope.implants = implants;
    }

    //
    // Callback from querying locations
    //
    function setLocations(locations) {

        $scope.locations = locations;
    }

});

//
// Case spine form controller - "sub" controller to
// case controller, responsible for spine subform of
// case initiation screen
//

"use strict";

angular.module("mtApp").controller("CaseSpineFormController", function ($scope, LocationService, OrganizationService, ProductSourceService) {

    init();

    //
    // PRIVATES
    //

    //
    // Initialize spine form - load related entities to
    // populate drop downs
    //
    function init() {

        // Setup default values if not already set (required for populating
        // typeaheads)
        initCaseDefaults();

        // Init for edit
        if ( $scope["case"]._id ) {
            initEditForm();
        }

        // Load up implants and ancillary products
        loadProducts();

        // Load up related location for fixation
        LocationService.findLocationsByCPTCategory("LOCATIONS_SPINE_FIXATION", setLocationsFixation);

        // Load up related location for interbody
        LocationService.findLocationsByCPTCategory("LOCATIONS_SPINE_INTERBODY", setLocationsInterbody);

        // Clear out values on destroy
        $scope.$on("$destroy", function() {

            $scope["case"].fixations = [];
            $scope["case"].locationFixation = "";
            $scope["case"].fixationFrom = "";
            $scope["case"].fixationTo = "";
            $scope["case"].interbodies = [];
            $scope["case"].interbodyProcedure = "";
            $scope["case"].locationInterbody = "";
            $scope["case"].interbodyFrom = "";
            $scope["case"].interbodyTo = "";
            $scope["case"].monitoringProducts = [];
            $scope["case"].boneGraftProducts = [];

            $scope["case"].ancillaryProducts = [];
            $scope["case"].notes = "";
        });

        // Handle change of surgery location - clear any location-specific
        // implants and load up set of possible values for new location
        $scope.$on("case.surgeryLocation.updated", function() {

            // Clear any selected implants...
            $scope.clearSelectedImplants();

            // Load up implants for the new surgery location
            loadProducts();
        });
    }

    //
    // Set default fields on case if they are not already set. For example,
    // we must have the implants array already instantiated on the case for
    // the typeahead to add/remove from
    //
    function initCaseDefaults() {

        $scope["case"].implants = $scope["case"].implants || [];
        $scope["case"].fixations = $scope["case"].fixations || [];
        $scope["case"].interbodies = $scope["case"].interbodies || [];
        $scope["case"].monitoringProducts = $scope["case"].monitoringProducts || [];
        $scope["case"].boneGraftProducts = $scope["case"].boneGraftProducts || [];
        $scope["case"].ancillaryProducts = $scope["case"].ancillaryProducts || [];
    }

    //
    // Set up form for edit - split out implants into fixation and interbody
    //
    function initEditForm() {

        _.each($scope["case"].implants, function(implant) {

            if ( implant.product.category === "FIXATION" ) {
                $scope["case"].fixations.push(implant);
            }
            else {
                $scope["case"].interbodies.push(implant);
            }
        });
    }

    //
    // Find products for the selected hospital - called on initialization of
    // case form OR if selected hospital is changed
    //
    function loadProducts() {

        var surgeryLocation = $scope["case"].surgeryLocation;
        var cptCategory = $scope["case"].procedures[0].category;

        // Load up implants
        ProductSourceService.findUserImplants(surgeryLocation, cptCategory, $scope.favoritesEnabled, setImplants);

        // Load allograft/autograft products
        ProductSourceService.findUserBoneGraftProducts(surgeryLocation, cptCategory, $scope.favoritesEnabled, setBoneGraftProducts);

        // Load monitoring products
        ProductSourceService.findUserMonitoringProducts(surgeryLocation, cptCategory, $scope.favoritesEnabled, setMonitoringProducts);

        // Load up ancillary products
        ProductSourceService.findUserAncillaryProducts(surgeryLocation, cptCategory, $scope.favoritesEnabled, setAncillaryProducts);
    }

    //
    // Callback from querying ancillary products
    //
    function setAncillaryProducts(products) {

        $scope.ancillaryProducts = products;
    }

    //
    // Callback from querying monitoring products
    //
    function setBoneGraftProducts(products) {

        $scope.boneGraftProducts = products;
    }

    //
    // Callback from querying implants - split list of implants in to fixation
    // and interbody and set on scope
    //
    function setImplants(implants) {

        // Sort implants...
        ProductSourceService.sortProductsForSelection(implants);

        $scope.fixations = [];
        $scope.interbodies = [];
        for ( var i = 0 ; i < implants.length ; i++ ) {

            var implant = implants[i];
            var category = implant.product.category;
            if ( category === "FIXATION" ) {
                $scope.fixations.push(implant);
            }
            else if ( category === "INTERBODY" ) {
                $scope.interbodies.push(implant);
            }
            else {
                console.error("Unrecognized product category " + category + " for implant " + implant._id);
            }
        }
    }

    //
    // Callback from querying locations for fixation
    //
    function setLocationsFixation(locations) {

        $scope.locationsFixation = locations;
    }

    //
    // Callback from querying locations for interbody
    //
    function setLocationsInterbody(locations) {

        $scope.locationsInterbody = locations;
    }

    //
    // Callback from querying monitoring products
    //
    function setMonitoringProducts(products) {

        $scope.monitoringProducts = products;
    }

});

//
// Case EMR summary controller - used to display case conformation
// details after create case
//

"use strict";

angular.module("mtApp").controller("CaseEMRSummaryController", function($state, $rootScope, $scope, ngDialog) {

    init();

    //
    // Copy text to buffer and close dialog - called as callback
    // after copy buffer has been populated by ccClip directive
    //
    $scope.closeDialog = function() {

        ngDialog.closeAll();
    };

    //
    // Return CPT code of primary procedure
    //
    $scope.getCPTCode = function() {

        var primaryProcedure = $scope["case"].procedures[0];
        return primaryProcedure.code;
    };

    //
    // Return the levels and location for fixation implant
    //
    $scope.getFixationMetaData = function() {

        var meta = [];
        meta.push($scope["case"].locationFixation);
        meta.push($scope["case"].fixationFrom);
        if ( $scope["case"].fixationFrom && $scope["case"].fixationTo ) {
            meta.push(" - ");
        }
        meta.push($scope["case"].fixationTo);

        _.compact(meta);
        return meta.join(" ").trim();
    };

    //
    // Return the levels and location for interbody implant
    //
    $scope.getInterbodyMetaData = function() {

        var meta = [];
        meta.push($scope["case"].interbodyProcedure);
        meta.push($scope["case"].interbodyFrom);
        if ( $scope["case"].interbodyFrom && $scope["case"].interbodyTo ) {
            meta.push(" - ");
        }
        meta.push($scope["case"].interbodyTo);
        meta.push($scope["case"].locationInterbody);

        _.compact(meta);
        return meta.join(" ").trim();
    };

    //
    // Returns true if notes are to be shown
    //
    $scope.isShowNotes = function() {

        return !!$scope["case"].notes;
    };

    //
    // Return the names of the manufacter of each implant
    //
    $scope.listManufacturerNames = function() {

        var manufacturerNames = [];
        _.each($scope["case"].implants, function(implant) {

            var manufacturer = implant.manufacturer;
            if ( manufacturer ) {

                manufacturerNames.push(manufacturer.name);
            }
        });

        return _.uniq(manufacturerNames).join(", ");
    };

    //
    // Return the full names of the rep for each implant
    //
    $scope.listRepNames = function() {

        var repNames = [];
        _.each($scope["case"].implants, function(implant) {

            var rep = implant.rep;
            if ( rep ) {

                repNames.push(rep.firstName + " " + rep.lastName);
            }
        });

        return _.uniq(repNames).join(", ");
    };

    //
    // Returns true if CPT category of primary procedure is SPINE
    //
    $scope.isSpine = function() {

        return $scope["case"].procedures[0].category === "SPINE";
    };

    //
    // List names of implants with the specified product category (eg FIXATION
    // or INTERBODY)
    //
    $scope.listImplantNamesInCategory = function(productCategory) {

        return $scope.listProductNames(filterImplantsByProductCategory(productCategory));
    };

    //
    // Build up pipe-delimited name of products
    //
    $scope.listProductNames = function(products) {

        var names = [];
        angular.forEach(products, function(productSource) {
            names.push(productSource.product.name);
        });

        if ( !names.length ) {
            return "";
        }

        return names.join(", ");
    };

    //
    // Generate content for copying to EMR
    //
    $scope.populateClipboard = function() {

        if ( $scope.isSpine() ) {
            return populateClipboardForSpine();
        }
        else {
            return populateClipboardForNonSpine();
        }
    };

    //
    // Listen for dialog closed events - transition state to
    // list cases
    //
    $rootScope.$on("ngDialog.closed", function () {
        return $state.transitionTo("cases.active");
    });

    //
    // PRIVATES
    //

    //
    // Find the list of implants with the specified product
    // category
    //
    function filterImplantsByProductCategory(productCategory) {

        var filtered = [];
        angular.forEach($scope["case"].implants, function(implant) {

            if ( implant.product.category === productCategory ) {
                filtered.push(implant);
            }
        });

        return filtered;
    }

    //
    // PRIVATES
    //

    //
    // Set up controller
    //
    function init() {

        // Listen for change in ngDialogData - this is set on
        // scope after controller is initialized
        $scope.$watch("ngDialogData", function(newValue) {

            if ( newValue) {
                $scope["case"] = newValue;
            }
        });
    }

    //
    // Populate clipboard for spine case
    //
    function populateClipboardForSpine() {

        var kase = $scope["case"];

        var content = [];

        // Medtel ID
        content.push("Medtel ID " + kase.medtelId);

        // Build up fixation text
        var fixationImplantsDisplayText = $scope.listImplantNamesInCategory("FIXATION");
        var levelsFixation = $scope.getFixationMetaData();
        if ( fixationImplantsDisplayText || levelsFixation ) {

            var fixationText = [];
            fixationText.push("Fixation");

            if ( fixationImplantsDisplayText ) {
                fixationText.push(fixationImplantsDisplayText);
            }

            if ( levelsFixation ) {
                fixationText.push(levelsFixation);
            }

            content.push(fixationText.join(" "));
        }

        // Build up interbody text
        var interbodyImplantsDisplayText = $scope.listImplantNamesInCategory("INTERBODY");
        var levelsInterbody = $scope.getInterbodyMetaData();
        if ( interbodyImplantsDisplayText || levelsInterbody ) {

            var interbodyText = [];
            interbodyText.push("Interbody");

            if ( interbodyImplantsDisplayText ) {
                interbodyText.push(interbodyImplantsDisplayText);
            }

            if ( levelsInterbody ) {
                interbodyText.push(levelsInterbody);
            }

            content.push(interbodyText.join(" "));
        }

        // Companies
        content.push($scope.listManufacturerNames());

        // Bone graft
        if ( kase.boneGraftProducts && kase.boneGraftProducts.length ) {
            content.push($scope.listProductNames(kase.boneGraftProducts));
        }

        // Monitoring
        if ( kase.monitoringProducts && kase.monitoringProducts.length ) {
            content.push($scope.listProductNames(kase.monitoringProducts));
        }

        // Additional products
        if ( kase.ancillaryProducts && kase.ancillaryProducts.length ) {
            content.push($scope.listProductNames(kase.ancillaryProducts));
        }

        // Notes
        if ( kase.notes ) {
            content.push(kase.notes);
        }

        // Strip out pipes (|) and hats (^) for HL7 compatibility
        var strContent = content.join("\r\n");
        return stripIt(strContent);
    }

    //
    // Populate clipboard for non spine case
    //
    function populateClipboardForNonSpine() {

        var kase = $scope["case"];

        var content = [];

        // Medtel ID
        content.push("Medtel ID " + kase.medtelId);

        // Notes
        if ( kase.notes ) {
            content.push(kase.notes);
        }

        // Implant
        content.push($scope.listProductNames(kase.implants));

        // Companies
        content.push($scope.listManufacturerNames());

        // Additional products
        if ( kase.ancillaryProducts && kase.ancillaryProducts.length ) {
            content.push($scope.listProductNames(kase.ancillaryProducts));
        }

        // Strip out pipes (|) and hats (^) for HL7 compatibility
        var strContent = content.join("\r\n");
        return stripIt(strContent);
    }

    //
    // Strip out pipes (|) and hats (^) for HL7 compatibility
    //
    function stripIt(content) {

        return content.replace(/(\||\^)/g, " ");
    }
});

//
// Tray print controller
//

"use strict";

angular.module("mtApp").controller("TrayPrintController", function ($rootScope, $scope, $state, TrayService, kase, implant, trays) {

    init();

    //
    // Return the value for the specified field name, otherwise
    // return "N/A"
    //
    $scope.getDisplayText = function(fieldName) {

        var value = $scope["case"][fieldName];
        if ( value ) {
            return value;
        }

        return "N/A";
    };

    //
    // PRIVATES
    //

    //
    // Setup controller
    //
    function init() {

        // Trigger print view
        $rootScope.$broadcast("cc-layout:print-view");

        $scope["case"] = kase;
        $scope.implant = implant;
        $scope.trays = trays;

        TrayService.updateTrayConfirmationDetailsFromImplant($scope.implant, $scope.trays);
    }
});

//
// Profile controller
// - Abstract, parent controller to info and favorite controllers
//

"use strict";

angular.module("mtApp").controller("ProfileController", function ($scope, profile) {

    init();

    //
    // PRIVATES
    //

    //
    // Initialize controller
    //
    function init() {

        $scope.profile = profile;
    }
});

//
// Profile info controller
//

"use strict";

angular.module("mtApp").controller("ProfileInfoController", function ($scope, PersonService, organization) {

    init();

    //
    // PRIVATES
    //

    //
    // Initialize controller
    //
    function init() {

        $scope.organization = organization;
    }
});

//
// Profile email form controller
//

'use strict';

angular.module('mtApp').controller('ProfileEmailFormController', function ($scope, PersonService) {

    init();

    //
    // Enable/disable user email alerts preference
    //
    $scope.updateUserEmailAlertsPreference = function() {

        PersonService.updateUserEmailAlertsPreference($scope.profile.emailAlerts);
    };

    //
    // Set up controller
    //
    function init() {

    }

});

//
// Profile favorite form controller
// - "Parent" controller for individual favorite form controllers
//

'use strict';

angular.module('mtApp').controller('ProfileFavoriteFormController', function ($scope, PersonService, OrganizationService, favoriteOrganizations) {

    init();

    //
    // Returns true if there is more than one affiliated organization (ie an
    // organization other than the user's home organization) to select from
    //
    $scope.isHasAffiliatedOrganizations = function() {

        return !!OrganizationService.findAffiliatedHospitals($scope.currentUser).length;
    };

    //
    // Enable/disable user favorites
    //
    $scope.updateUserFavoritesPreference = function() {

        PersonService.updateUserFavoritesPreference($scope.profile.favorites);
    };

    //
    // Set up controller
    //
    function init() {

        // Set organizations that the current user can book at. For practice users,
        // it will hospitals that the practice is affiliated with. For hospitals users,
        // it will be the user's own hospital. If any hospital is a group, it will be
        // the group of hospitals. If the user's organization is a hospital and it is
        // not part of a group, just set the user's organization as the only option
        // to select from.
        if ( OrganizationService.isPractice($scope.currentUser)
            || OrganizationService.isHospitalInGroup($scope.currentUser) ) {

            // Remove any practices from the affiliated to array. Practice users will
            // always be able to schedule at their home organization and we want to
            // prevent hospital users (where the hospital is associated with a practice)
            // to only schedule at other affiliated hospitals (and not at affiliated
            // practices)
            $scope.affiliatedToOrganizations = OrganizationService.findAffiliatedHospitals($scope.currentUser);
        }
        else {

            $scope.affiliatedToOrganizations = [];
        }

        // Set the organizations affiliated with the current user's
        // organization, that the user has selected as favorite
        $scope.favoriteOrganizations = favoriteOrganizations;
    }

});

//
// Favorite procedure controller
//

'use strict';

angular.module('mtApp').controller('FavoriteProcedureController', function ($scope, FavoriteService, ProcedureService, procedures, favorites) {

    init();

    //
    // Generate display text for specified procedure - required for
    // typeahead menu
    //
    $scope.getProcedureDisplayText = ProcedureService.getProcedureDisplayText;

    //
    // Generate display text for selected specified procedure - required
    // for typeahead menu
    //
    $scope.getProcedureSelectedText = function(procedure) {

        return ProcedureService.getProcedureSelectedText(procedure, true);
    };

    //
    // Handle select of procedure in typeahead - save procedure as favorite
    //
    $scope.handleProcedureSelected = function(procedure) {

        FavoriteService.createFavorite(procedure._id, "PROCEDURE");
    };

    //
    // Handle removal of procedure in typeahead - remove procedure as favorite
    //
    $scope.handleProcedureRemoved = function(procedure) {

        FavoriteService.deleteFavorite(procedure._id, "PROCEDURE");
    };

    //
    // Sort procedures by CPT code - called by typeahead when
    //
    $scope.sortProceduresByCPTCode = function(procedure0, procedure1) {

        var cptCode0 = procedure0.code;
        var cptCode1 = procedure1.code;

        if ( cptCode0 === cptCode1 ) {
            return 0;
        }

        if ( cptCode0 < cptCode1 ) {
            return -1;
        }

        return 1;
    };

    //
    // PRIVATES
    //

    //
    // Setup typeaheads
    //
    function init() {

        $scope.procedures = procedures;
        $scope.favorites = favorites;

        $scope.id = "at.favorites.procedure";
    }
});

//
// Favorite hospital controller
//
// Options and favorites are set up in parent controller ProfileFavoriteFormController
//

'use strict';

angular.module('mtApp').controller('FavoriteHospitalController', function ($scope, FavoriteService) {

    init();

    //
    // Generate display text for specified hospital - required for
    // typeahead menu
    //
    $scope.getHospitalDisplayText = function(hospital) {

        return hospital.name;
    };

    //
    // Handle select of hospital in typeahead - save hospital as favorite
    //
    $scope.handleHospitalSelected = function(hospital) {

        FavoriteService.createFavorite(hospital._id, "ORGANIZATION");
    };

    //
    // Handle removal of hospital in typeahead - remove hospital as favorite.
    // Also remove corresponding favorites (surgeons, implants, products) for
    // this hospital
    //
    $scope.handleHospitalRemoved = function(hospital) {

        // Delete the specified hospital as a favorite
        FavoriteService.deleteFavorite(hospital._id, "ORGANIZATION");

        // Delete all favorites corresponding to this hospital
        FavoriteService.deleteAllForOrganization(hospital._id);
    };

    //
    // Sort hospital by CPT code - called by typeahead when
    //
    $scope.sortHospitalsByName = function(hospital0, hospital1) {

        var name0 = hospital0.name;
        var name1 = hospital1.name;

        if ( name0 === name1 ) {
            return 0;
        }

        if ( name0 < name1 ) {
            return -1;
        }

        return 1;
    };

    //
    // PRIVATES
    //

    //
    // Setup typeaheads
    //
    function init() {

            $scope.id = "at.favorites.hospital";
    }
});

//
// Favorite product controller
//

'use strict';

angular.module('mtApp').controller('FavoriteAdditionalProductController', function ($scope, FavoriteService, ProductSourceService) {

    init();

    //
    // Generate display text for specified product - required for
    // typeahead menu
    //
    $scope.getProductDisplayText = ProductSourceService.getProductSourceDisplayText;

    //
    // Handle select of product in typeahead - save product as favorite
    //
    $scope.handleProductSelected = function(product) {

        FavoriteService.createFavoriteProduct(product._id, product.product.productType, product.product.cptCategory, $scope.favoriteOrganization._id);
    };

    //
    // Handle removal of product in typeahead - remove product as favorite
    //
    $scope.handleProductRemoved = function(product) {

        FavoriteService.deleteFavoriteForOrganization(product._id, product.product.productType, $scope.favoriteOrganization._id);
    };

    //
    // Sort products by their display text
    //
    $scope.sortProducts = function(product0, product1) {

        var value0 = ProductSourceService.getProductSourceDisplayText(product0);
        var value1 = ProductSourceService.getProductSourceDisplayText(product1);

        if ( value0 === value1 ) {
            return 0;
        }

        if ( value0 < value1 ) {
            return -1;
        }

        return 1;
    };

    //
    // Returns true if product type is IMPLANT
    //
    $scope.isImplant = function() {

        return false;
    };

    //
    // PRIVATES
    //

    //
    // Setup typeahead for product type "ADDITION_PRODUCT"
    //
    function init() {

        // Set up typeahead options - find all surgeons in the current user's
        // organization
        ProductSourceService.findActiveAdditionalProductSources($scope.favoriteOrganization._id, function(additionalProducts) {
            $scope.products = additionalProducts;
        });

        // Set up surgeons previously selected as favorites - this will be
        // per organization that was selected as favorite
        ProductSourceService.findFavoriteAdditionalProducts($scope.favoriteOrganization._id, function(favorites) {
            $scope.favorites = favorites;
        });


        $scope.id = "at.favorites.ancillaryProduct" + $scope.favoriteOrganization._id;
    }

});

//
// Favorite product controller
//

"use strict";

angular.module("mtApp").controller("FavoriteImplantController", function ($scope, FavoriteService, ProductSourceService) {

    init();

    //
    // Generate display text for specified product - required for
    // typeahead menu
    //
    $scope.getProductDisplayText = ProductSourceService.getProductSourceDisplayText;

    //
    // Handle select of product in typeahead - save product as favorite
    //
    $scope.handleProductSelected = function(product) {

        FavoriteService.createFavoriteImplant(product._id, product.product.cptCategory, $scope.favoriteOrganization._id);
    };

    //
    // Handle removal of product in typeahead - remove product as favorite
    //
    $scope.handleProductRemoved = function(product) {

        FavoriteService.deleteFavoriteForOrganization(product._id, "IMPLANT", $scope.favoriteOrganization._id);
    };

    //
    // Sort products by their display text
    //
    $scope.sortProducts = function(product0, product1) {

        var value0 = ProductSourceService.getProductSourceDisplayText(product0);
        var value1 = ProductSourceService.getProductSourceDisplayText(product1);

        if ( value0 === value1 ) {
            return 0;
        }

        if ( value0 < value1 ) {
            return -1;
        }

        return 1;
    };

    //
    // Returns true if product type is IMPLANT
    //
    $scope.isImplant = function() {

        return true;
    };

    //
    // PRIVATES
    //

    //
    // Setup typeahead for product type "IMPLANT"
    //
    function init() {

        // Set up typeahead options - find all surgeons in the current user's
        // organization
        ProductSourceService.findActiveImplantProductSources($scope.favoriteOrganization._id, false, function(implants) {
            $scope.products = implants;
        });

        // Set up surgeons previously selected as favorites - this will be
        // per organization that was selected as favorite
        ProductSourceService.findFavoriteImplants($scope.favoriteOrganization._id, function(favorites) {
            $scope.favorites = favorites;
        });

        $scope.id = "at.favorites.implant" + $scope.favoriteOrganization._id;
    }

});

//
// Favorite surgeon controller
//

'use strict';

angular.module('mtApp').controller('FavoriteSurgeonController', function ($scope, FavoriteService, OrganizationService, PersonService) {

    init();

    //
    // Generate display text for specified surgeon - required for
    // typeahead menu
    //
    $scope.getSurgeonDisplayText = function(surgeon) {

        var displayText = PersonService.getSurgeonDisplayText(surgeon);
        return displayText + "  " + surgeon.organizations.home.name;
    };

    //
    // Handle select of surgeon in typeahead - save surgeon as favorite
    //
    $scope.handleSurgeonSelected = function(surgeon) {

        FavoriteService.createFavoriteForOrganization(surgeon._id, "SURGEON", $scope.favoriteOrganization._id);
    };

    //
    // Handle removal of surgeon in typeahead - remove surgeon as favorite
    //
    $scope.handleSurgeonRemoved = function(surgeon) {

        FavoriteService.deleteFavoriteForOrganization(surgeon._id, "SURGEON", $scope.favoriteOrganization._id);
    };

    //
    // Sort surgeons by their display text
    //
    $scope.sortSurgeons = function(surgeon0, surgeon1) {

        var value0 = PersonService.getSurgeonDisplayText(surgeon0);
        var value1 = PersonService.getSurgeonDisplayText(surgeon1);

        if ( value0 === value1 ) {
            return 0;
        }

        if ( value0 < value1 ) {
            return -1;
        }

        return 1;
    };

    //
    // PRIVATES
    //

    //
    // Set up controller
    //
    function init() {

        // Check all (faves, visibility, all) for case initiation form
        // Get all (all) for admin form
        // Get visibility or all for favorites

        var surgeonOrgIds = PersonService.generateListOfSurgeonOrganizations($scope.currentUser);

        // If the user has been assigned surgeons, find surgeons user has visibility rights to
        if ( $scope.currentUser.visibilityRights && $scope.currentUser.visibilityRights.length ) {

            PersonService.findVisibleSurgeons($scope.currentUser, function(surgeons) {
                $scope.surgeons = surgeons;
            });
        }
        // Otherwise user has not been assigned any surgeons, find all surgeons
        else {

            PersonService.findAllSurgeons(surgeonOrgIds, function(surgeons) {
                $scope.surgeons = surgeons;
            });
        }


        // Set up surgeons previously selected as favorites - this will be
        // per organization that was selected as favorite
        PersonService.findFavoriteSurgeons($scope.favoriteOrganization._id, function(favorites) {
            $scope.favorites = favorites;
        });

        $scope.id = "at.favorites.surgeon" + $scope.favoriteOrganization._id;
    }

});

//
// Profile nav controller
// - Used to control navigation on profile-related pages
//
// TODO(skin) remove this?
//

'use strict';

angular.module('mtApp').controller('ProfileNavController', function ($scope, $location, USER_ROLES) {

    $scope.menu = [
        {
            'title': 'My Profile',
            'link': '/profile/info',
            'role': [USER_ROLES.user, USER_ROLES.surgeon, USER_ROLES.rep]
        },
        {
            'title': 'My Custom Email Alerts',
            'link': '/profile/emails',
            'role': [USER_ROLES.user, USER_ROLES.surgeon, USER_ROLES.rep]
        },
        {
            'title': 'My Favorite Surgical Dashboard',
            'link': '/profile/favorites',
            'role': [USER_ROLES.user, USER_ROLES.surgeon]
        }
    ];

    //
    // Returns true if route matches the current path
    //
    $scope.isActive = function(route) {
        return route === $location.path();
    };
});

//
// Medtel Admin Controller
//
// @deprecated Use adminentitiescontroller.js instead (where standard CC pagination and CC list
// model objects are used)
//
// TODO Convert all admin lists to use adminentitiescontroller.js
//

"use strict";

angular.module("mtApp").controller("AdminController",
    function ($rootScope, $scope, $location, $state, PAGINATION, MetaDataService, DateTimeService,
              metadataKey, urlKey, entityTypeDisplayName, service, query, count, data, capabilities) {

    init();

    //
    // Next page button
    //
    $scope.nextPage = function () {
        $scope.last = true;
        if($scope.total !== $scope.countRow) {
            $scope.offset = $scope.offset + $scope.rows.length;
            $scope.first = false;
            service[query]($scope.offset, function(rows) {
                $scope.total = $scope.offset + rows.length;
                $scope.last = ($scope.total === $scope.countRow) ? true : false;
                $scope.rows = rows;
            });
        }
    };

    //
    // Previous page button
    //
    $scope.prevPage = function () {
        $scope.first = true;
        if($scope.offset >= PAGINATION.ADMIN.limit) {
            $scope.offset = $scope.offset - PAGINATION.ADMIN.limit;
            $scope.last = false;
            service[query]($scope.offset, function(rows) {
                $scope.total = $scope.offset + rows.length;
                $scope.rows = rows;
                $scope.first = ($scope.offset === PAGINATION.offset) ? true : false;
            });
        }

        if ( $scope.offset === PAGINATION.offset ) {
            $scope.first = true;
        }
    };

    //
    // Create new entity
    //
    $scope.createEntity = function () {

        $location.path("/admin/" + $scope.urlKey + "/new");
    };

    //
    // Edit entity - called from callback from magic table
    //
    $scope.editEntity = function(entityId) {

        $location.path("/admin/" + $scope.urlKey + "/" + entityId + "/edit");
    };

    //
    // Show entity - called from callback from magic table
    //
    $scope.showEntity = function(entityId) {

        $location.path("/admin/" + $scope.urlKey + "/" + entityId);
    };

    //
    // PRIVATES
    //
    function init() {

        // Set variable indicated we are using the deprecated
        // controller (used to determine which version of pagination
        // to use)
        $scope.deprecatedController = true;

        // Setup variables for pagination
        $scope.countRow = 0;
        $scope.rows = [];
        $scope.offset = 0;
        $scope.total = 0;
        $scope.first = true;
        $scope.last = false;
        $scope.columns = MetaDataService.getColumns(metadataKey);

        // Set up list data and count for pagination...

        if (metadataKey === "person") {
            if (data.items && data.count) {
                createPersonLastActivity(data.items);
            }
            else {
                createPersonLastActivity(data);
            }
        }


        // Check if we're dealing with a list model
        if ( data.items && data.count ) {

            $scope.countRow = data.count;
            $scope.rows = data.items;
            $scope.total = data.items.length;
            $scope.last = (data.items.length >= data.count);
        }
        // Otherwise we're dealing with straight up data and count
        // values that have been resolved separately
        // TODO remove this flow once all entity types have been
        // moved to list model
        else {

            $scope.countRow = count.count;
            $scope.rows =  data;
            $scope.total = data.length;
            $scope.last = (data.length >= count.count) ? true : false;

        }

        // Set URL key - used for building up entity-specific
        // URLs (eg /products/edit or /schedulers/new)
        $scope.urlKey = urlKey;

        // assign a boolean to create/edit button entities
        // customized the logic to handle the visibility of
        // the edit and create button
        $scope.capabilities = capabilities || {};

        // Entity type display name (eg "Product" or "Scheduler")
        $scope.entityTypeDisplayName =  entityTypeDisplayName;
    }


    function createPersonLastActivity(data) {

        for (var i = 0; i < data.length; i++) {
            var item = data[i];
            item.lastActivity = DateTimeService.formatLastSeen(item.lastSeen);
        }
    }
});

//
// Controller for displaying admin entities.
//
// This is the "2-dot-oh" version of admincontroller (re-uses standard CC pagination, uses list model
// rather than separate items and count etc)
//

"use strict";

angular.module("mtApp").controller("AdminEntitiesController",
    function ($rootScope, $scope, $location, ngDialog, MetaDataService, QMService, DateTimeService,
              metadataKey, urlKey, entityTypeDisplayName, service, query, listModel, capabilities) {

    init();

    //
    // Access to finding cases for pagination functionality (next/previous) or
    // for auto refresh of list
    //
    $scope.findEntities = function(pagination, callback) {

        callback = callback || angular.noop;

        var qm = QMService.getInstance("ADMIN");
        qm.setOffset(pagination.offset);
        qm.setLimit(pagination.limit);

        service[query](qm, function(result) {

            $scope.rows = result.items;
            callback(result.items, result.count);
        });
    };

    //
    // Create new entity
    //
    $scope.createEntity = function () {

        $location.path("/admin/" + $scope.urlKey + "/new");
    };

    //
    // Edit entity - called from callback from magic table
    //
    $scope.editEntity = function(entityId) {

        $location.path("/admin/" + $scope.urlKey + "/" + entityId + "/edit");
    };

    //
    // Show confirm prompt for retiring the current entity
    //
    $scope.showConfirmRetireEntity = function(entityId) {

        ngDialog.open({
            template:"/partials/admin/" + $scope.entityTypeDisplayName.toLowerCase() + "/confirm-retire.html",
            className: "ngdialog-default",
            scope: $scope,
            data: entityId
        });
    };

    //
    // Retire entity - called from callback from magic table
    //
    $scope.retireEntity = function(entityId) {

        ngDialog.closeAll();

        service["retire" + entityTypeDisplayName](entityId, function() {

            // Remove entity from list
            for ( var i = 0 ; i < $scope.rows.length ; i++ ) {

                var entity = $scope.rows[i];
                if ( entity._id === entityId ) {
                    $scope.rows.splice(i, 1);
                    break;
                }
            }

            // Update pagination
            $rootScope.$broadcast("update:remove");
        });
    };

    //
    // Show entity - called from callback from magic table
    //
    $scope.showEntity = function(entityId) {

        $location.path("/admin/" + $scope.urlKey + "/" + entityId);
    };

    //
    // PRIVATES
    //
    function init() {

        $scope.columns = MetaDataService.getColumns(metadataKey);

        // setup human readable "last seen"
        if ( metadataKey === "person" ) {
            createPersonLastActivity(listModel);
        }

        // Set up list data and count for pagination...
        $scope.totalItems = listModel.count;
        $scope.rows = listModel.items;
        $scope.pageSize = listModel.items.length;
        $scope.last = (listModel.items.length >= listModel.count);

        // Set URL key - used for building up entity-specific
        // URLs (eg /products/edit or /schedulers/new)
        $scope.urlKey = urlKey;

        // assign a boolean to create/edit button entities
        // customized the logic to handle the visibility of
        // the edit and create button
        $scope.capabilities = capabilities || {};

        // Entity type display name (eg "Product" or "Scheduler")
        $scope.entityTypeDisplayName =  entityTypeDisplayName;
    }

    function createPersonLastActivity(listModel) {

        for (var i = 0; i < listModel.count; i++) {
            var item = listModel.items[i];
            item.lastActivity = DateTimeService.formatLastSeen(item.lastSeen);
        }
    }
});

//
// Admin nav controller
// - Used to control navigation on admin pages
//

"use strict";

angular.module("mtApp").controller("AdminNavController", function ($scope, $location, USER_ROLES) {

    $scope.menu = [
        {
            "title": "Products",
            "link": "/admin/products",
            "role": [USER_ROLES.admin]
        },
        {
            "title": "Procedures",
            "link": "/admin/procedures",
            "role": [USER_ROLES.admin]
        },
        {
            "title": "Manufacturers",
            "link": "/admin/manufacturers",
            "role": [USER_ROLES.admin]
        },
        {
            "title": "Practices",
            "link": "/admin/practices",
            "role": [USER_ROLES.admin]
        },
        //{
        //    "title": "Hospital Groups",
        //    "link": "/admin/hospital-groups",
        //    "role": [USER_ROLES.admin]
        //},
        {
            "title": "Hospitals",
            "link": "/admin/hospitals",
            "role": [USER_ROLES.admin]
        },
        {
            "title": "Hospital Schedulers",
            "link": "/admin/schedulers",
            "role": [USER_ROLES.admin]
        },
        {
            "title": "Practice Schedulers",
            "link": "/admin/practice-schedulers",
            "role": [USER_ROLES.admin]
        },
        {
            "title": "Surgeons",
            "link": "/admin/surgeons",
            "role": [USER_ROLES.admin]
        },
        {
            "title": "Reps",
            "link": "/admin/reps",
            "role": [USER_ROLES.admin]
        },
        {
            "title": "Reports",
            "link": "/admin/reports",
            "role": [USER_ROLES.admin]
        }
    ];
});

//
// Form controller for creating/editing hospitals
//

"use strict";


var AdminHospitalFormController =
    function ($scope, $state, ROUTES, TIMEZONE, AdminOrganizationService, AdminProductSourceService,
              data, productSources, implantOptions, ancillaryProductOptions, monitoringProductOptions, boneGraftProductOptions) {

    //
    // Create organization
    //
    $scope.createOrganization = function(form) {

        $scope.submitted = true;

        if ( form.$valid ) {

            $scope.debounced = true;

            $scope.organization.type = "HOSPITAL";
            AdminOrganizationService.createOrganization($scope.organization, function(organization) {

                // if create fails display error from the server
                if (organization.result) {

                    $scope.errors = organization.result;
                    $scope.debounced = false;
                }
                else {

                    // Return to organization list
                    $state.go(ROUTES.ADMIN_HOSPITAL_INDEX);
                }
            });
        }
    };

    //
    // Update organization
    //
    $scope.updateOrganization = function(form) {

        $scope.submitted = true;

        if ( form.$valid ) {

            $scope.debounced = true;

            // Update organization
            AdminOrganizationService.updateOrganization($scope.organization._id, $scope.organization, function(organization) {

                // if update fails display error from the server
                if (organization.result) {
                    $scope.errors = organization.result;
                    $scope.debounced = false;
                } else {
                    // Return to organization list
                    $state.go(ROUTES.ADMIN_HOSPITAL_INDEX);
                }
            });
        }

    };

    // Initialize scope
    init();

    //
    // PRIVATES
    //

    //
    // Initialize scope
    //
    function init() {

        // Form title - matches page title
        $scope.title = $state.current.title || "";

        // True if we're in edit mode, false if we're creating
        $scope.edit = !!data;

        // Display the organization data when editing
        $scope.organization = data || {};

        // removing the affiliatedOrganization it is not being used
        // to update hospital and manufacturer organization
        delete $scope.organization.affiliatedOrganizations;

        // List of timezone. This is only visible for hospital
        $scope.timezones = TIMEZONE.zones;

        // Setup typeaheads for creating new implant product source
        $scope.implantOptions = implantOptions || [];

        // Setup typeaheads for creating new implant product source
        $scope.ancillaryProductOptions = ancillaryProductOptions || [];

        // Setup typeaheads for creating new implant product source
        $scope.monitoringProductOptions = monitoringProductOptions || [];

        // Setup typeaheads for creating new implant product source
        $scope.boneGraftProductOptions = boneGraftProductOptions || [];

        // Setup the lists of implants, ancillary products etc
        initProductLists();
    }

    //
    // Split the list of product sources into implants, ancillary,
    // monitoring and bone graft. Applicable to hospitals only.
    //
    function initProductLists() {

        productSources = productSources || [];
        productSources.sort(AdminProductSourceService.sortProductSources);

        // Getting the implants product on the productsource.
        $scope.implants = _.filter(productSources, function(data){
            return data.product.productType === "IMPLANT";
        });

        // Getting the ancillary product on the productsource.
        $scope.ancillaryProducts = _.filter(productSources, function(data){
            return data.product.productType === "ANCILLARY";
        });

        // Getting the monitoring product on the productsource.
        $scope.monitoringProducts = _.filter(productSources, function(data){
            return data.product.productType === "MONITORING";
        });

        // Getting the bonegrafts product on the productsource.
        $scope.boneGraftProducts = _.filter(productSources, function(data){
            return data.product.productType === "BONE_GRAFT";
        });
    }
};

angular.module("mtApp").controller("AdminHospitalFormController", AdminHospitalFormController);

//
// AdminOrganization service
// for Manufacturer, Hospital, Practice
//

"use strict";

angular.module("mtApp").factory("AdminOrganizationService", function AdminOrganizationService(OrganizationDAO) {

    return {

        //
        // Find organization with the specified ID
        //
        findOrganizationById: function(id, next) {

            next = next || angular.noop;

            return OrganizationDAO.get({
                id: id
            }, next).$promise;
        },

        //
        // Create Organization
        //
        createOrganization: function (organization, next) {

            next = next || angular.noop;

            return OrganizationDAO.save(organization, next).$promise;
        },

        //
        // Create Organization
        //
        createHospitalGroup: function (organization, next) {

            next = next || angular.noop;

            return OrganizationDAO.createHospitalGroup(organization, next).$promise;
        },

        //
        // Update organization
        //
        updateOrganization: function(id, organization, next) {

            next = next || angular.noop;

            // Create a clone to prevent Angular updating UI (ie adding validation
            // errors to case values) as we normalize manufacturer values
            var organizationClone = {};
            _.extend(organizationClone, organization);

            return OrganizationDAO.update({
                id: id
            }, organizationClone, next).$promise;
        },

        //
        // Update organization
        //
        updateHospitalGroup: function(id, organization, next) {

            next = next || angular.noop;

            // Create a clone to prevent Angular updating UI (ie adding validation
            // errors to case values) as we normalize manufacturer values
            var organizationClone = {};
            _.extend(organizationClone, organization);

            return OrganizationDAO.updateHospitalGroup({
                id: id
            }, organizationClone, next).$promise;
        },

        //
        // Find all hospitals that are not yet in group
        //
        findHospitalsNotInGroup: function (next) {

            next = next || angular.noop;
            return OrganizationDAO.findHospitalsNotInGroup(next).$promise;
        }

    };

});

//
// Generic AdminOrganization Controller
// - for manufacturers, hospitals, practices
//

"use strict";


var AdminOrganizationController =
    function ($scope, $state, AdminOrganizationService, data, organizationsRoute, organizationType, products, users) {

    //
    // Update organization
    //
    $scope.updateOrganization = function(form) {

        $scope.submitted = true;

        if ( form.$valid ) {

            $scope.debounced = true;

            // Update organization
            AdminOrganizationService.updateOrganization($scope.organization._id, $scope.organization, function(organization) {

                // if update fails display error from the server
                if (organization.result) {
                    $scope.errors = organization.result;
                    $scope.debounced = false;
                } else {
                    // Return to organization list
                    $state.go(organizationsRoute);
                }
            });
        }

    };

    //
    // Create organization
    //
    $scope.createOrganization = function(form) {

        $scope.submitted = true;

        if ( form.$valid ) {

            $scope.debounced = true;

            // Update organization
            // assign a type to organization
            $scope.organization.type = organizationType.toUpperCase();
            AdminOrganizationService.createOrganization($scope.organization, function(organization) {

                // if create fails display error from the server
                if (organization.result) {
                    $scope.errors = organization.result;
                    $scope.debounced = false;
                } else {
                    // Return to organization list
                    $state.go(organizationsRoute);
                }
            });
        }
    };

    // Initialize scope
    init();

    //
    // PRIVATES
    //

    //
    // Initialize scope
    //
    function init() {

        // Form title - matches page title
        $scope.title = $state.current.title || "";

        // True if we're in edit mode, false if we're creating
        $scope.edit = !!data;
        // Display the organization data when editing
        $scope.organization = data || {};

        // Display Organization type information
        $scope.organizationType = organizationType || "";

        // Display organization users
        $scope.users = users || [];

        // removing the affiliatedOrganization it is not being used
        // to update hospital and manufacturer organization
        delete $scope.organization.affiliatedOrganizations;

        products = products || [];
    }
};

angular.module("mtApp").controller("AdminOrganizationController", AdminOrganizationController);

// Create and Edit procedure controller

'use strict';


var AdminProcedureController = function ($scope, $location, $state, ROUTES, AdminProcedureService, data) {

	//
	// initialize
	//
	init();

	//
	// Save procedure handles the event from the view
	//
	$scope.createProcedure = function () {

        AdminProcedureService.createProcedure($scope.procedure, function (response) {
			if(angular.isArray(response.result)){
				$scope.errors = response.result;
			} else if('success' === response.result.toLowerCase()) {
				$state.go(ROUTES.ADMIN_PROCEDURES);
			}
		});
	};

	//
	//	Update a procedure handles the event from the view
	//
	$scope.updateProcedure = function () {

		ProcedureService.updateProcedure($scope.procedure._id, $scope.procedure, function (response) {
			if(angular.isArray(response.result)){
				$scope.errors = response.result;
			} else if('success' === response.result.toLowerCase()) {
				$state.go(ROUTES.ADMIN_PROCEDURES);
			}
		});
	};

    //
    // PRIVATES
    //

    //
    // Initialize scope variable here
    //
    function init () {

        // Form title - matches page title
        $scope.title = $state.current.title || '';

        // True if we're in edit mode, false if we're creating
        // a new procedure
        $scope.edit = !!data;

        // Procedure that we are editing (null, if this is a create)
        $scope.procedure = data;
    }
};

angular.module('mtApp').controller('AdminProcedureController', AdminProcedureController);

//
// Admin procedure service
//

"use strict";

angular.module("mtApp").factory("AdminProcedureService", function AdminProcedureService(QMService, PAGINATION, AdminProcedureDAO) {

    return {

        //
        // Find active procedures to be listed in admin
        //
        findActiveProcedures: function(qm, next) {

            next = next || angular.noop;

            // Build up sort order
            qm.addSort("code", true);

            // Add limit
            qm.setLimit(PAGINATION.ADMIN.limit);

            return AdminProcedureDAO.findActiveProcedures(qm.asQuery(), next).$promise;
        },

        //
        // Create procedure
        //
        createProcedure : function (data, next) {

            next = next || angular.noop;

            AdminProcedureDAO.createProcedure(data, next);
        },

        //
        // Find procedure with specified ID
        //
        findProcedureById : function (id, next) {

            next = next || angular.noop;

            return AdminProcedureDAO.get({
                id: id
            }, next).$promise;
        },

        //
        // Retire procedure
        //
        retireProcedure: function(id, next) {

            return AdminProcedureDAO.retireProduct({
                id: id
            }, next).$promise;
        },

        // Update procedure
        updateProcedure : function (id, data, next) {

            next = next || angular.noop;

            return AdminProcedureDAO.updateProcedure({
                id: id
            }, data, next);
        }

    };
});

//
// Admin procedure DAO
//

"use strict";

angular.module("mtApp").factory("AdminProcedureDAO", function ($resource) {

    return $resource("/api/admin/procedures/:id", {
        id: "@id"
    }, {
        findActiveProcedures: {
            method: "GET",
            url: "/api/admin/procedures/active",
            isArray: false
        },
        createProcedure: {
            method: "POST",
            url: "/api/admin/procedures",
            isArray: false
        },
        retireProduct: {
            method: "PUT",
            url: "/api/admin/procedures/:id/retire"
        },
        updateProcedure: {
            method: "PUT",
            url: "/api/admin/procedures/:id",
            isArray: false
        }
    });
});

//
// Admin controller for product-related create/edit functionality
//

"use strict";


var AdminProductController = function ($scope, product, manufacturer, trays) {

	//
	// Setup controller
	//
	init();

    //
    // Returns true if product is of type IMPLANT
    //
    $scope.isImplant = function () {

        return $scope.product.productType === "IMPLANT";
    };

    //
    // List CPT categories
    //
    $scope.listCPTCategories = function() {


        return product.cptCategory.join(", ");
    };

    //
    // Privates
    //

    //
    // Init function - initialize all the scope variable here
    //
    function init() {

        $scope.product = product;
        $scope.manufacturer = manufacturer;
        $scope.trays = trays;
    }
};

angular.module("mtApp").controller("AdminProductController", AdminProductController);

//
// Admin controller for product-related create/edit functionality
//

"use strict";


var AdminProductFormController = function ($scope, $location, $state, CPT_CATEGORIES_ADMIN, ROUTES, AdminProductService, data, manufacturers, trays) {

	//
	// Setup controller
	//
	init();

	//
	// Create new product
	//
	$scope.createProduct = function () {

        AdminProductService.createProduct($scope.product, function (response) {

			if ( angular.isArray(response.result) ) {
				$scope.errors = response.result;
			}
            else if ( "success" === response.result.toLowerCase() ) {
				$state.go(ROUTES.ADMIN_PRODUCT_INDEX);
			}
		});
	};

    //
    // Clear/update category of product according
    // to the selected CPT category
    //
    $scope.handleCPTCategoryChanged = function() {

        // TODO - revisit. what is meant to happen here?
        //var cptCategory = $scope.product.cptCategory;
        //console.log(cptCategory)
    };

    //
    // Clear/update category and CPT category of product according
    // to the selected product type
    //
    $scope.handleProductTypeChanged = function() {

        // Clear any previously selected CPT categories if this
        // is an implant
        if ( $scope.isImplant() ) {

            $scope.product.cptCategory = [];
        }
        // Clear category for all other types of product. Also
        // set CPT category according to product type
        else {

            $scope.product.category = "";
            if ( isSpineProductType() ) {

                $scope.product.cptCategory = ["SPINE"];
            }
            else {
                $scope.product.cptCategory = CPT_CATEGORIES_ADMIN;
            }

        }
    };

	//
	// check if the product is implant
	//
	$scope.isImplant = function () {

		return $scope.product.productType === "IMPLANT";
	};

	//
	// determine if the implant has trays content
	//
	$scope.implantHasTrays = function () {

		return $scope.trays.length > 0;
	};

    //
    // Returns true if SPINE option has been selected in the
    // CPT category multi select - required for determining
    // if category (eg INTERBODY vs FIXATION) is required
    //
    $scope.isSpine = function() {

        return $scope.product.cptCategory.indexOf("SPINE") >= 0;
    };

    //
    // Handle selection of CPT category - can be SPINE or a combination
    // of ORTHOPEDIC and/or NEUROSURGERY
    //
    $scope.toggleCPTCategory = function(cptCategory) {

        if ( cptCategory === "SPINE" ) {

            for ( var i = 0 ; i < $scope.product.cptCategory.length ; i++ ) {

                if ( $scope.product.cptCategory[i] !== "SPINE" ) {

                    $scope.product.cptCategory.splice(i, 1);
                    i--;

                    // Clear category
                    $scope.product.category = "";
                }
            }
        }
        // Clear SPINE selection if ORTHO or NEURO are selected
        else {

            var spineIndex = $scope.product.cptCategory.indexOf("SPINE");
            if ( spineIndex >= 0 ) {
                $scope.product.cptCategory.splice(spineIndex, 1);

                // Clear category
                $scope.product.category = "";
            }
        }

        // Toggle selected CPT category
        var index = $scope.product.cptCategory.indexOf(cptCategory);
        if ( index >= 0 ) {

            $scope.product.cptCategory.splice(index, 1);
        }
        else {

            $scope.product.cptCategory.push(cptCategory);
        }
    };

    //
    // Returns true if CPT category is selected
    //
    $scope.isCPTCategorySelected = function(cptCategory) {

        return $scope.product.cptCategory.indexOf(cptCategory) >= 0;
    };

    //
    // Update product details
    //
    $scope.updateProduct = function () {

        AdminProductService.updateProduct($scope.product._id, $scope.product, function (response) {

            if ( angular.isArray(response.result) ) {
                $scope.errors = response.result;
            }
            else if ( "success" === response.result.toLowerCase() ) {
                $state.go(ROUTES.ADMIN_PRODUCT_INDEX);
            }
        });
    };

    //
    // Privates
    //

    //
    // Init function - initialize all the scope variable here
    //
    function init() {

        // Form title - matches page title
        $scope.title = $state.current.title || '';

        // True if we're in edit mode, false if we're creating
        // a new procedure
        $scope.edit = !!data;

        // Product we are editing (null if this is a create)
        $scope.product = data || {} ;

        // list of manufacturers
        $scope.manufacturers = manufacturers || [];

        // list of trays
        $scope.trays = trays;
    }

    //
    // Returns true if product type can only be matched with
    // CPT category "SPINE". That is, return true if product type
    // is monitoring or bone graft.
    //
    function isSpineProductType() {

        return $scope.product.productType === "MONITORING" ||
                $scope.product.productType === "BONE_GRAFT";
    }
};

angular.module("mtApp").controller("AdminProductFormController", AdminProductFormController);

//
// Admin product service
//

"use strict";

angular.module("mtApp").factory("AdminProductService", function AdminProductService($q, PAGINATION, QMService, AdminProductDAO) {

    return {

        //
        // Create Product
        //
        createProduct : function (data, next) {

            next = next || angular.noop;

            AdminProductDAO.createProduct(data, next);
        },

        //
        // Find active products
        //
        findActiveProducts: function(qm, next) {

            next = next || angular.noop;

            // Build up query model
            qm.addSort("name", true);
            qm.setLimit(PAGINATION.ADMIN.limit);

            return AdminProductDAO.findActiveProducts(qm.asQuery(), next).$promise;
        },

        //
        // Find all products to be listed in admin
        // @deprecated Use findActiveProducts for listing products
        // in admin
        //
        findAdminAll: function(offset, next) {

            next = next || angular.noop;

            // Build up sort order
            var qm = QMService.getInstance("Product");
            qm.addSort("name", true);
            qm.setOffset(offset);
            qm.setLimit(PAGINATION.ADMIN.limit);

            return AdminProductDAO.findAllProducts(qm.asQuery(), next).$promise;
        },

        //
        // Find available bone graft products for the specified hospital. That is, only list
        // bone graft products that have not yet been associated with the hospital. Used
        // when listing products when creating product sources on the edit hospital page.
        //
        findAvailableBoneGraftProductsForHospital: function(hospitalId, next) {

            next = next || angular.noop;

            return AdminProductDAO.findAvailableProducts({
                hospitalId: hospitalId,
                productType: "BONE_GRAFT"
            }, next).$promise;
        },

        //
        // Find available ancillary products for the specified hospital. That is, only list
        // ancillary products that have not yet been associated with the hospital. Used
        // when listing products when creating product sources on the edit hospital page.
        //
        findAvailableAncillaryProductsForHospital: function(hospitalId, next) {

            next = next || angular.noop;

            return AdminProductDAO.findAvailableProducts({
                hospitalId: hospitalId,
                productType: "ANCILLARY"
            }, next).$promise;
        },

        //
        // Find active implants - for listing products when creating product sources
        // on the edit hospital page
        //
        findActiveImplants: function(next) {

            next = next || angular.noop;

            var implantDeferred = $q.defer();

            var qm = QMService.getInstance();
            qm.setPaginated(false);
            qm.addEqualsQueryFilter("productType", "IMPLANT");
            qm.addSort("manufacturer.name", true);
            qm.addSort("product.name", true);
            AdminProductDAO.findActiveProducts(qm.asQuery(), function(listModel) {

                next();
                implantDeferred.resolve(listModel.items);
            });

            return implantDeferred.promise;
        },

        //
        // Find available monitoring products for the specified hospital. That is, only list
        // monitoring products that have not yet been associated with the hospital. Used
        // when listing products when creating product sources on the edit hospital page.
        //
        findAvailableMonitoringProductsForHospital: function(hospitalId, next) {

            next = next || angular.noop;

            return AdminProductDAO.findAvailableProducts({
                hospitalId: hospitalId,
                productType: "MONITORING"
            }, next).$promise;
        },

        //
        // Find product by ID
        //
        findProductById : function (id, next) {
            return AdminProductDAO.findProductById({id: id}, next).$promise;
        },

        //
        // Retire product
        //
        retireProduct: function(id, next) {

            return AdminProductDAO.retireProduct({
                id: id
            }, next).$promise;
        },

        //
        // Updates the product details by ID
        //
        updateProduct : function (id, data, next) {
            return AdminProductDAO.updateProduct({id: id}, data, next);
        }
    };
});

//
// Product source DAO
//

"use strict";

angular.module("mtApp").factory("AdminProductDAO", function ($resource) {

    return $resource("/api/admin/products/:id", {
        id: "@id"
    }, {
        createProduct: {
            method: "POST",
            url: "/api/admin/products",
            isArray: false
        },
        findActiveProducts: {
            method: "GET",
            url: "/api/admin/products/active",
            isArray: false // Returns list model
        },
        findAllProducts: { // @deprecated (use findActiveProducts instead)
            method: "GET",
            url: "/api/admin/products",
            isArray: true
        },
        findAvailableProducts: {
            method: "GET",
            url: "/api/admin/products/available-products",
            isArray: true
        },
        updateProduct: {
            method: "PUT",
            url: "/api/admin/products/:id",
            isArray: false
        },
        findProductById: {
            method: "GET",
            url: "/api/admin/products/:id",
            isArray: false
        },
        retireProduct: {
            method: "PUT",
            url: "/api/admin/products/:id/retire"
        }
    });
});

//
// List item controller for listing product sources
//

"use strict";


var AdminProductSourceListItemController =  function ($scope, ngDialog, AdminProductSourceService, AdminPersonService, PersonService) {

    // Set up controller scope
    init();

    //
    // Cancel edit of product source
    //
    $scope.cancelEdit = function() {

        $scope.edit = false;
        $scope.repOptions = [];
        $scope.selectedReps = [];
    };

    //
    // Generate display text for specified rep - required
    // for typeahead menu.
    //
    $scope.getRepDisplayText = PersonService.getRepDisplayText;

    //
    // Edit product source - list the possible reps for the
    // selected product of this product source
    //
    $scope.editProductSource = function() {

        var productId = $scope.productSource.product._id;
        AdminPersonService.findAvailableReps($scope.organization._id, productId, function(reps) {

            $scope.repOptions = reps;
            $scope.selectedReps = [];

            $scope.edit = true;
        });
    };

    //
    // Retire product source
    //
    $scope.retireProductSource = function() {

        ngDialog.closeAll();

        AdminProductSourceService.retireProductSource($scope.productSource._id, function() {

            // Remove product source from list
            for ( var i = 0 ; i < $scope.products.length ; i++ ) {

                var productSource = $scope.products[i];
                if ( productSource._id === $scope.productSource._id ) {
                    $scope.products.splice(i, 1);
                    break;
                }
            }
        });
    };

    //
    // Show confirm prompt for retiring the current product source
    //
    $scope.showConfirmRetireProductSource = function() {

        ngDialog.open({
            template:"/partials/admin/productsource/confirm-retire.html",
            className: "ngdialog-default",
            scope: $scope
        });
    };

    //
    // Update rep on product source
    //
    $scope.updateProductSource = function(selectedRep) {

        // Clear out typeaheads etc
        $scope.cancelEdit();

        // Replace rep name locally (for display only)
        $scope.productSource.rep = {
            _id: selectedRep._id,
            firstName: selectedRep.firstName,
            lastName: selectedRep.lastName,
            email: selectedRep.email
        };

        // Save change in rep
        var productId = $scope.productSource._id;
        var repId = selectedRep._id;
        AdminProductSourceService.updateProductSource(productId, repId, function(newProductSource) {

            // A new product source is created when the rep is switched out - update ID of
            // product source to match newly created product source
            $scope.productSource._id = newProductSource._id;
        });
    };

    //
    // PRIVATES
    //

    //
    // Setup controller
    //
    function init() {

        $scope.edit = false;
    }
};

angular.module("mtApp").controller("AdminProductSourceListItemController", AdminProductSourceListItemController);

//
// Form controller for creating product sources
//

"use strict";


var AdminProductSourceFormController =  function ($scope, AdminPersonService, AdminProductSourceService, ProductSourceService, PersonService) {

    // Set up controller scope
    init();

    //
    // Create product source
    //
    // @param associatedImplants The array of implants that the new implant will
    // be added to after create. The associated implants share the same product type
    // (eg IMPLANT, ANCILLARY, MONITORING etc)
    //
    //
    // @param implantForm Product source form being submitted
    // @param associatedImplants Array of implants already associated with the selected hospital
    // @param implantOptions Array of possible implants that can be associated with the selected hospital
    //
    $scope.createProductSource = function(implantForm, associatedImplants, implantOptions) {

        $scope.submitted = true;

        if ( implantForm.$valid ) {

            $scope.debounced = true;

            //productSource = {
            //    manufacturer: "..",
            //    product: "..",
            //    hospital: "..",
            //    rep: ".."
            //}

            var hospitalId = $scope.organization._id;
            var product = $scope.selectedImplants[0];
            var productType = product.productType;
            var manufacturerId = product.manufacturer._id;

            var repId;
            if ( $scope.selectedReps && $scope.selectedReps.length ) {
                repId = $scope.selectedReps[0]._id;
            }

            AdminProductSourceService.createProductSource(hospitalId, manufacturerId, product._id, repId, function(productSource) {

                // If we're dealing with ancillary, monitoring or bone graft
                // products, remove the option from the list of possible options
                if ( productType !== "IMPLANT" ) {

                    removeProductOption(implantOptions, product);
                }

                // Reset form
                resetProductSourceForm();

                // Add product source to array of product sources for this hospital, then sort
                associatedImplants.push(productSource);
                associatedImplants.sort(AdminProductSourceService.sortProductSources);

            });
        }
    };

    //
    // Generate display text for specified product/implant - required
    // for typeahead menu.
    //
    // If product type is IMPLANT, append rep name. Otherwise just
    // display product name and manufacturer name.
    //
    $scope.getProductDisplayText = ProductSourceService.getProductDisplayText;

    //
    // Generate display text for specified rep - required
    // for typeahead menu.
    //
    // If product type is IMPLANT, append rep name. Otherwise just
    // display product name and manufacturer name.
    //
    $scope.getRepDisplayText = PersonService.getRepDisplayText;

    //
    // Implant has been selected - list the reps in the
    // corresponding manufacturer. Called for products of
    // type IMPLANT only.
    //
    $scope.handleImplantSelected = function(item) {

        if ( item.manufacturer ) {
            loadManufacturerReps(item.manufacturer._id);
        }
    };

    //
    // Implant has been removed - clear reps. Called for products of
    // type IMPLANT only.
    //
    $scope.handleImplantRemoved = function(item) {

        clearRepOptions();
    };

    //
    // PRIVATES
    //

    //
    // Setup controller
    //
    function init() {

        // Setup typeaheads for creating new implant product source
        $scope.selectedImplants = [];
        $scope.selectedReps = [];

        $scope.repOptions = [];
        $scope.selectedReps = [];
    }

    //
    // Reset rep options and selected reps - called when selected product
    // is cleared/changed
    //
    function clearRepOptions() {

        $scope.repOptions = [];
        $scope.selectedReps = [];
    }

    //
    // Load reps for the specified manufacturer
    //
    function loadManufacturerReps() {

        AdminPersonService.findAvailableReps($scope.organization._id, $scope.selectedImplants[0]._id, function(reps) {

            $scope.repOptions = reps;
        });
    }

    //
    // Reset product source form - called after successful form post
    //
    function resetProductSourceForm() {

        $scope.debounced = false;
        $scope.submitted = false;

        // Clear selected implants and rep options
        $scope.selectedImplants = [];
        clearRepOptions();
    }

    //
    // Remove the specified product from the possible set of products.
    // This is required for additional products (ancillary, monitoring, bone graft)
    // as a selected product must be removed from the list of possible options
    // once it has been selected.
    //
    function removeProductOption(implantOptions, product) {

        for ( var i = 0 ; i < implantOptions.length ; i++ ) {

            var implantOption = implantOptions[i];
            if ( implantOption._id === product._id ) {

                implantOptions.splice(i, 1);
                break;
            }
        }
    }
};

angular.module("mtApp").controller("AdminProductSourceFormController", AdminProductSourceFormController);

//
// AdminProductSource service
//

"use strict";

angular.module("mtApp").factory("AdminProductSourceService", function AdminProductSourceService(QMService, AdminProductSourceDAO) {

    return {

        //
        // Create product source
        //
        createProductSource: function(hospitalId, manufacturerId, productId, repId, next) {

            next = next || angular.noop;

            var params = {
                hospital: hospitalId,
                manufacturer: manufacturerId,
                product: productId
            };

            if ( repId ) {
                params.rep = repId;
            }

            return AdminProductSourceDAO.save(params, next).$promise;
        },

        //
        // Find all product sources for the specified hospital
        //
        findProductSourcesByHospital: function (hospitalId, next) {

            next = next || angular.noop;

            // Build up query for search for producsource
            var qm = QMService.getInstance();
            qm.addEqualsQueryFilter("hospital", hospitalId);
            qm.addNotQueryFilter("writeIn", true);
            qm.addSort("manufacturer.name", true);
            qm.addSort("product.name", true);

            // Only display product sources that have not yet been retired
            qm.addGreaterThanQueryFilter("endDate", new Date());

            qm.setPaginated(false);
            return AdminProductSourceDAO.query(qm.asQuery(), next).$promise;
        },

        //
        // Retire the specified product source
        //
        retireProductSource: function(productSourceId, next) {

            next = next || angular.noop;

            return AdminProductSourceDAO.retireProductSource({
                id: productSourceId
            }, next).$promise;
        },

        //
        // Sort product sources by:
        // Manufacturer, product, rep first name, rep last name
        //
        sortProductSources: function(productSource0, productSource1) {

            var compareValue0 = buildProductSourceCompareValue(productSource0);
            var compareValue1 = buildProductSourceCompareValue(productSource1);

            if ( compareValue0 === compareValue1 ) {

                return 0;
            }

            if ( compareValue0 < compareValue1 ) {
                return -1;
            }

            return 1;
        },

        //
        // Update rep on product source
        //
        updateProductSource: function(productSourceId, repId, next) {

            next = next || angular.noop;

            return AdminProductSourceDAO.updateProductSource({
                id: productSourceId
            }, {
                repId: repId
            }, next).$promise;
        }
    };

    //
    // Build up single string value to compare two product sources
    // against each other during sorting of array
    //
    function buildProductSourceCompareValue(productSource) {

        var value = [];
        value.push(productSource.manufacturer.name);
        value.push(productSource.product.name);

        var rep = productSource.rep;
        if ( rep ) {
            value.push(rep.firstName);
            value.push(rep.lastName);
        }

        return value.join();
    }

});

//
// Product source DAO
//

"use strict";

angular.module("mtApp").factory("AdminProductSourceDAO", function ($resource) {

    return $resource("/api/admin/productsources/:id", {
        id: "@id"
    }, {
        findActiveProductSources: {
            method: "GET",
            url: "/api/admin/productsources/active",
            isArray: true
        },
        retireProductSource: {
            method: "PUT",
            url: "/api/admin/productsources/:id/retire"
        },
        updateProductSource: {
            method: "PUT",
            url: "/api/admin/productsources/:id",
            isArray: false
        }
    });
});

//
// Person-related (scheduler, surgeon etc)-related admin functionality
//

"use strict";


var AdminPersonFormController = function ($scope, $location, $state, ROUTES, USER_ROLES, AdminPersonService, PersonService,
                                      data, surgeons, organizations, role, organizationsRoute, entityTypeDisplayInfo) {

	// Initialize scope
	init();

    //
    // Return display text for surgeon select box in format:
    // firstName lastName for hospital users only
    //
    $scope.getSurgeonDisplayText = PersonService.getSurgeonDisplayText;

    //
    // Returns true if person being created/edited is a rep
    //
    $scope.isRep = function() {

        return $scope.person.role === USER_ROLES.rep;
    };

    //
    // Returns true if person being created/edited is a scheduler
    //
    $scope.isUser = function() {

        return $scope.person.role === USER_ROLES.user;
    };

    //
    // Update person
    //
    $scope.updatePerson = function(form) {

        $scope.submitted = true;

        if ( form.$valid ) {

            $scope.debounced = true;

            // call service to update person
            AdminPersonService.updatePerson($scope.person, function(response) {
                $scope.debounced = false;
                if(angular.isArray(response.result)){
                    $scope.errors = response.result;
                } else {
                    $state.go(organizationsRoute);
                }
            });
        }

    };

    //
    // update person password
    //
    $scope.updatePersonPassword = function (form) {

        $scope.successMessage = "";
        $scope.passwordSubmitted = true;

        if ( form.$valid ) {

            $scope.passwordDebounced = true;

            // call service to update person
            $scope.personPassword._id = $scope.person._id;
            AdminPersonService.updatePersonPassword($scope.personPassword, function() {

                // Show the success message and reset flags
                $scope.passwordDebounced = false;
                $scope.passwordSubmitted = false;
                $scope.personPassword = {};
                $scope.successMessage = "Password updated";
            });
        }

    };


    //
    // Create Person
    //
    $scope.createPerson = function (form) {

        $scope.submitted = true;

        if ( form.$valid ) {

            $scope.debounced = true;

            // invoke on updating the organization name
            // updateOrganizationName();

            // call service to create person
            AdminPersonService.createPerson($scope.person, function(response) {
                $scope.debounced = false;
                if(angular.isArray(response.result)){
                    $scope.errors = response.result;
                } else {
                    $state.go(organizationsRoute);
                }
            });
        }
    };

    //
    // PRIVATES
    //

    //
    // Initialize scope
    //
    function init() {

        // Form title - matches page title
        $scope.title = $state.current.title || "";


        $scope.entityTypeDisplayInfo = entityTypeDisplayInfo|| "";

        // flag to show the message
        $scope.showMessage = false;

        // True if we're in edit mode, false if we're creating
        // a new person
        $scope.edit = !!data;

        // Person who we are editing.
        $scope.person = data || {};

        // Set role on person
        $scope.person.role = role;

        // instatiate an array of organization, container for filtered
        // organization properties
        $scope.organizations = organizations;

        $scope.person.visibilityRights = $scope.person.visibilityRights || [];

        // Form data for affiliated surgeons
        $scope.surgeons = surgeons;

        // Check if the user being created/edited can have visibility rights
        // assigned to them - true for users and surgeons
        $scope.isVisible = (role === USER_ROLES.user ||
                            role === USER_ROLES.surgeon);

        if ($scope.edit === false) {

            initOrganizationWatcher($scope);
        }
    }

    //
    // Watch for change in organization dropdown
    //
    function initOrganizationWatcher($scope) {

        $scope.$watch("person.organizations.home._id", function(newValue) {

            $scope.person.visibilityRights = [];

            if ( newValue ) {

                updateSurgeonListForOrganization(newValue);
            }
            else {

                $scope.surgeons = [];
            }
        });
    }


    function updateSurgeonListForOrganization(orgId) {

        $scope.$broadcast("person.organizations.home._id.updated");

        var orgType;

        for (var i = 0; i < $scope.organizations.length; i++) {
            var org = $scope.organizations[i];
            if (org._id === orgId) {
                orgType = org.type;
                break;
            }
        }

        AdminPersonService.findAdminAffiliatedSurgeonsByOrganization(orgId, orgType, function(surgeons) {

            $scope.surgeons = surgeons;
        });
    }
};

angular.module("mtApp").controller("AdminPersonFormController", AdminPersonFormController);

//
// Surgeon service
//

"use strict";

angular.module("mtApp").factory("AdminPersonService",
    function PersonService(PAGINATION, QMService, AdminPersonDAO, OrganizationService, FavoriteDAO, PersonDAO) {

    return {

        //
        // Add rep as backup to specified primary rep
        //
        addBackupRep: function(primaryRepId, backupRepId, next) {

            next = next || angular.noop;

            return AdminPersonDAO.addBackupRep({
                id: primaryRepId
            }, {
                backupRepId: backupRepId
            }, next).$promise;
        },

        //
        // Count admin schedulers
        //
        countAdminReps: function (next) {

            next = next || angular.noop;

            return countAdminPeople("REP", next);
        },

        //
        // Count admin schedulers
        //
        countAdminSchedulers: function (next) {

            next = next || angular.noop;

            return countAdminPeople("USER", next);
        },

        //
        // Count admin schedulers
        //
        countAdminSurgeons: function (next) {

            next = next || angular.noop;

            return countAdminPeople("SURGEON", next);
        },

        //
        // Create person
        //
        createPerson : function (person, next) {

            next = next || angular.noop;

            var personClone = {};
            _.extend(personClone, person);

            // Denormalize surgeon IDs
            personClone.visibilityRights = _.pluck(personClone.visibilityRights, "_id");
            AdminPersonDAO.createPerson(personClone, next);
        },

        //
        // Find reps for displaying in the admin
        //
        findAdminReps: function(offset, next) {

            next = next || angular.noop;

            return findAdminPeople(offset, "REP", next);
        },

        //
        // Find primary rep for the specified rep group
        //
        findAdminRepPrimaryForRepGroup: function(repGroupId, next) {

            next = next || angular.noop;

            // Build up query for search for rep who is the primary
            // rep for the specified group
            var qm = QMService.getInstance();
            qm.addEqualsQueryFilter("organizations.primary._id", repGroupId);

            return AdminPersonDAO.findAdminPeople(qm.asQuery(), next).$promise;
        },

        //
        // Find all backup reps for the specified rep group
        //
        findAdminRepBackupsForRepGroup: function(repGroupId, next) {

            next = next || angular.noop;

            // Build up query for search for rep who is the primary
            // rep for the specified group
            var qm = QMService.getInstance();
            qm.addEqualsQueryFilter("organizations.backup._id", repGroupId);

            return AdminPersonDAO.findAdminPeople(qm.asQuery(), next).$promise;
        },

        //
        // Find reps who work for the specified manufacturer
        //
        findAdminRepsByManufacturer : function (manufacturerId, next) {

            next = next || angular.noop;

            return findAdminPeopleByOrganization(0, "REP", manufacturerId, next);
        },

        //
        // Find schedulers for displaying in the admin
        //
        findAdminSchedulers: function(offset, next) {

            next = next || angular.noop;

            return findAdminPeople(offset, "USER", next);
        },

        //
        // Find surgeons for displaying in the admin
        //
        findAdminSurgeons: function(offset, next) {

            next = next || angular.noop;

            return findAdminPeople(offset, "SURGEON", next);
        },

        //
        // Find surgeons by organization
        //
        findAdminSurgeonsByOrganization : function (offset, orgId, next) {

            next = next || angular.noop;

            return findAdminPeopleByOrganization(offset, "SURGEON", orgId, next);
        },

        //
        // Find surgeons by affiliated organizations
        //
        findAdminAffiliatedSurgeonsByOrganization: function(orgId, orgType, next) {

            next = next || angular.noop;

            return findAdminAffiliatedSurgeonsByOrganization(orgId, orgType, next);
        },

        //
        // Find schedulers by organization
        //
        findAdminSchedulersByOrganization: function(offset, orgId, next) {

            next = next || angular.noop;

            return findAdminPeopleByOrganization(offset, "USER", orgId, next);
        },

        //
        // Find active hospital schedulers or practice schedulers
        //
        findSchedulers: function(qm, scheduler, next) {

            next = next || angular.noop;

            // Add filter to only return schedulers
            qm.addEqualsQueryFilter("role", "USER");

            // Add filter to only return schedulers who work at a hospital or practice
            qm.addEqualsQueryFilter("organizations.home.type", scheduler);

            // Build up sort order
            qm.addSort("lastName", true);
            qm.addSort("firstName", true);

            // Add limit
            qm.setLimit(PAGINATION.ADMIN.limit);

            // Add parameter to indicate we are expecting a list model (and
            // not an array of people)
            qm.addQueryParam("listModel", true);

            // TODO revisit - remove flag once all routes are updated to use list model

            return AdminPersonDAO.findSchedulers(qm.asQuery(), next).$promise;
        },

        //
        // Find person with the specified ID - populate the surgeons selected
        // in the visibility rights list
        //
        findPersonById: function(id, next) {
            next = next || angular.noop;

            // Build up param for specifying fields to populate
            var populates = [];
            populates.push(buildQueryPopulates("visibilityRights"));

            return PersonDAO.get({
                id: id,
                populates: populates
            }, next).$promise;
        },

        //
        // Find reps available to be selected as the rep for the specified
        // hospital/product combination. Called when creating product sources
        // on edit hospital.
        //
        findAvailableReps: function(hospitalId, productId, next) {

            next = next || angular.noop;

            return AdminPersonDAO.findAvailableReps({
                hospitalId: hospitalId,
                productId: productId
            }, next).$promise;
        },

        //
        // Remove rep as backup to specified primary rep
        //
        removeBackupRep: function(primaryRepId, backupRepId, next) {

            next = next || angular.noop;

            return AdminPersonDAO.removeBackupRep({
                id: primaryRepId,
                backupRepId: backupRepId
            }, next).$promise;
        },

        //
        // Update person
        //
        updatePerson: function(person, next) {

            next = next || angular.noop;

            // Create a clone to prevent Angular updating UI (ie adding validation
            // errors to case values) as we normalize person values
            var personClone = {};
            _.extend(personClone, person);

            // Denormalize surgeon IDs
            personClone.visibilityRights = _.pluck(personClone.visibilityRights, "_id");
            AdminPersonDAO.updatePerson({
                id: personClone._id
            }, personClone, next);
        },

        updatePersonPassword: function(person, next) {

            next = next || angular.noop;

            AdminPersonDAO.updatePersonPassword({
                id: person._id
            }, person, next);
        }
    };

    //
    // PRIVATES
    //

    //
    // Build query filter query param
    // TODO(dave) repeated in other services
    //
    function buildQueryFilter(filterType, fieldName, value) {

        return {
            filterType: filterType,
            fieldName: fieldName,
            value: value
        };
    }

    //
    // Build sort order query param
    // TODO(dave) repeated in other services
    //
    function buildQuerySort(fieldName, asc) {

        return {
            fieldName: fieldName,
            asc: asc
        };
    }

    //
    // Build populate query param
    //
    function buildQueryPopulates(fieldName, childrenFieldNames) {

        return {
            fieldName: fieldName,
            childrenFieldNames: childrenFieldNames
        };
    }

    //
    // Find all people who have the specified role, for listing
    // poeple in admin
    //
    function findAdminPeople(offset, role, next) {

        next = next || angular.noop;

        // Build up filter
        var filters = [];
        filters.push(buildQueryFilter("EQUALS", "role", role));

        // Build up sort order
        var sorts = [];
        sorts.push(buildQuerySort("lastName", true));
        sorts.push(buildQuerySort("firstName", true));

        // Build up param for specifying fields to populate
        var populates = [];
        populates.push(buildQueryPopulates("organization", ["name"]));

        return AdminPersonDAO.findAdminPeople({
            filters:filters,
            populates: populates,
            sorts: sorts,
            offset: offset,
            limit: PAGINATION.ADMIN.limit
        }, next).$promise;
    }

    //
    // Find all surgeons based on organization
    //
    function findAdminPeopleByOrganization(offset, role, orgId, next) {

        next = next || angular.noop;

        // Build up filter
        var filters = [];
        filters.push(buildQueryFilter("EQUALS", "role", role));
        filters.push(buildQueryFilter("IN", "organizations.home._id", [orgId]));
        // Build up sort order
        var sorts = [];
        sorts.push(buildQuerySort("lastName", true));
        sorts.push(buildQuerySort("firstName", true));

        // Build up param for specifying fields to populate
        var populates = [];
        populates.push(buildQueryPopulates("organization", ["name"]));

        return AdminPersonDAO.findAdminPeople({
            filters:filters,
            populates: populates,
            sorts: sorts,
            offset: offset
        }, next).$promise;
    }

    function countAdminPeople(role, next) {

        next = next || angular.noop;

        // Build up filter
        var filters = [];
        filters.push(buildQueryFilter("EQUALS", "role", role));

        // Build up sort order
        var sorts = [];
        sorts.push(buildQuerySort("lastName", true));
        sorts.push(buildQuerySort("firstName", true));

        // Build up param for specifying fields to populate
        var populates = [];
        populates.push(buildQueryPopulates("organization", ["name"]));

        return AdminPersonDAO.countAdminPeople({
            filters:filters,
            populates: populates
        }, next).$promise;
    }

    function findAdminAffiliatedSurgeonsByOrganization(orgId, orgType, next) {

        var qm = QMService.getInstance();

        qm.addSort("lastName", true);
        qm.addSort("firstName", true);

        qm.setPaginated(false);

        if (orgType === "HOSPITAL") {

            qm.addOrQueryFilter([
                qm.buildEqualsQueryFilter("organizations.home._id", orgId),
                qm.buildEqualsQueryFilter("organizations.affiliatedTo._id", orgId)
            ]);
        }
        else if (orgType === "PRACTICE") {

            qm.addEqualsQueryFilter("organizations.home._id", orgId);
        }

        // Only return surgeons
        qm.addEqualsQueryFilter("role", "SURGEON");

        return AdminPersonDAO.findAdminPeople(qm.asQuery(), next).$promise;
    }
});

//
// User Service
// - Service
//

"use strict";

angular.module("mtApp").factory("AdminPersonDAO", function ($resource) {
    return $resource("/api/admin/people/:id", {
        id: "@id"
    }, {
        addBackupRep: {
            method: "POST",
            url: "/api/admin/reps/:id/backups"
        },
        countAdminPeople: {
            method: "GET",
            url: "/api/admin/count/people",
            isArray: false
        },
        deactivate: {
            method: "POST",
            url: "/api/people/:id/deactivate"
        },
        findAdminPeople: {
            method: "GET",
            url: "/api/admin/people",
            isArray: true
        },
        findAvailableReps: {
            method: "GET",
            url: "/api/admin/people/available-reps",
            isArray: true
        },
        findSchedulers: {
            method: "GET",
            url: "/api/admin/people",
            isArray: false
        },
        createPerson : {
            method: "POST",
            url: "/api/admin/people"
        },
        reactivate: {
            method: "POST",
            url: "/api/people/:id/reactivate"
        },
        removeBackupRep: {
            method: "DELETE",
            url: "/api/admin/reps/:id/backups/:backupRepId"
        },
        updatePerson: {
            method: "PUT",
            url: "/api/admin/people/:id"
        },
        updatePersonPassword: {
            method: "PUT",
            url: "/api/admin/people/:id/password"
        }
    });
});

//
// Rep-related admin functionality. Used only for managing (adding/removing) backup reps
// on edit rep form. See AdminPersonFormController for full create/edit functionality.
//

"use strict";


var AdminRepController = function ($scope, AdminPersonService) {

	// Initialize scope
	init();

    //
    // Add selected rep as a backup to the current rep
    //
    $scope.addBackupRep = function(backupRep) {

        var primaryRepId = $scope.person._id;
        var backupRepId = backupRep._id;
        AdminPersonService.addBackupRep(primaryRepId, backupRepId);
    };

    //
    // Return display text for surgeon select box in format:
    // firstName lastName for hospital users only
    //
    $scope.getRepDisplayText = function(rep) {

        return rep.firstName + " " + rep.lastName;
    };

    //
    // Remove selected rep as a backup to the current rep
    //
    $scope.removeBackupRep = function(backupRep) {

        var primaryRepId = $scope.person._id;
        var backupRepId = backupRep._id;
        AdminPersonService.removeBackupRep(primaryRepId, backupRepId);
    };


    //
    // PRIVATES
    //

    //
    // Initialize scope
    //
    function init() {

        // Find all backup reps for the current rep
        AdminPersonService.findAdminRepBackupsForRepGroup($scope.person.organizations.primary._id, function(backupReps) {

            $scope.backupReps = backupReps;
        });

        // Find all reps in the current user's home organization
        AdminPersonService.findAdminRepsByManufacturer($scope.person.organizations.home._id, function(repsInManufacturer) {

            $scope.reps = [];
            for ( var i = 0 ; i < repsInManufacturer.length ; i++ ) {

                if ( repsInManufacturer[i]._id !== $scope.person._id ) {
                    $scope.reps.push(repsInManufacturer[i]);
                }
            }
        });
    }
};

angular.module("mtApp").controller("AdminRepController", AdminRepController);

//
// Rep group controller
//

'use strict';

angular.module('mtApp').controller('AdminRepGroupController', function ($scope, repGroup, primaryRep, backupReps) {

	//
	// Setup controller
	// 
	init();

    //
    // Privates
    //

    //
    // Setup controller
    //
    function init() {

        $scope.repGroup = repGroup;
        $scope.primaryRep = primaryRep;
        $scope.backupReps = backupReps;
    }
});

//
//  AdminOrganization Controller
//

'use strict';


var AdminHospitalGroupController = function ($scope, $state, $stateParams, ROUTES, AdminOrganizationService, hospitalGroup, organizationIndexRoute, organizationType, entityTypeDisplayName, hospitalsNotInGroup) {

    // Initialize scope
    init();

    $scope.getHospitalDisplayText = function (item) {
        return item.name;
    };

    //
    // Update organization
    //
    $scope.updateOrganization = function(form) {

        $scope.submitted = true;

        if ( form.$valid ) {

            $scope.debounced = true;

            // Update organization
            $scope.organization['affiliatedOrganizations'] = _.pluck($scope.organization['affiliatedOrganizations'], '_id');
            AdminOrganizationService.updateHospitalGroup($stateParams.id, $scope.organization, function(organization) {

                // Return to organization list
                $state.go(organizationIndexRoute);
            });
        }

    };

    //
    // Create organization
    //
    $scope.createOrganization = function(form) {

        $scope.submitted = true;

        if ( form.$valid ) {

            $scope.debounced = true;

            // Update organization
            // assign a type to organization
            $scope.organization['type'] = organizationType;

            // get only the ids of the selected organizations
            $scope.organization['affiliatedOrganizations'] = _.pluck($scope.organization['affiliatedOrganizations'], '_id');
            AdminOrganizationService.createHospitalGroup($scope.organization, function(organization) {

                // Return to organization list
                $state.go(organizationIndexRoute);
            });
        }

    };

    //
    // PRIVATES
    //

    //
    // Initialize scope
    //
    function init() {

        // Form title - matches page title
        $scope.title = $state.current.title || '';

        // True if we're in edit mode, false if we're creating
        $scope.edit = !!hospitalGroup;

        // Display the organization hospitalGroup when editing
        $scope.organization = hospitalGroup || {};

        // Display Organization type information
        $scope.entityTypeDisplayName = entityTypeDisplayName || '';

        //
        $scope.organization.affiliatedOrganizations = $scope.organization.affiliatedOrganizations || [];
        
        // All hospitals that are not yet in group
        $scope.hospitals = _.union(hospitalsNotInGroup, $scope.organization.affiliatedOrganizations);
    }

};

angular.module('mtApp').controller("AdminHospitalGroupController", AdminHospitalGroupController);

//
// AdminPracticeController Controller
//

'use strict';


var AdminPracticeController = function ($scope, $state, $stateParams, ROUTES, AdminPracticeService, practice, affiliatedHospitals, organizationsIndex, hospitals, users) {

	// Initialize scope
	init();

    //
    // Return the name of the hospital for display purposes
    //
    $scope.getHospitalDisplayText = function (item, text) {

        return item.name;
    };

    //
    // Sort hospital by CPT code - called by typeahead when
    //
    $scope.sortHospitalsByName = function(hospital0, hospital1) {

        var name0 = hospital0.name;
        var name1 = hospital1.name;

        if ( name0 === name1 ) {
            return 0;
        }

        if ( name0 < name1 ) {
            return -1;
        }

        return 1;
    };

    //
    // Update practice
    //
    $scope.updatePractice = function(form) {

        $scope.submitted = true;

        if ( form.$valid ) {

            $scope.debounced = true;

            // Clone practice and normalize hospital IDs. We need to clone the practice
            // here to avoid Angular from displaying error messages while we normalize
            // the hospital IDs
            var practiceToUpdate = _.clone($scope.practice);
            practiceToUpdate.hospitalIds = _.pluck(practiceToUpdate.hospitalIds, "_id");

            // Update practice
            AdminPracticeService.updatePractice(practiceToUpdate, function() {

                // Return to practice list
                $state.go(organizationsIndex);
            });
        }

    };

    //
    // Create practice
    //
    $scope.createPractice = function(form) {

        $scope.submitted = true;

        if ( form.$valid ) {

            $scope.debounced = true;

            // Clone practice and normalize hospital IDs. We need to clone the practice
            // here to avoid Angular from displaying error messages while we normalize
            // the hospital IDs
            var practiceToCreate = _.clone($scope.practice);
            practiceToCreate["type"] = "PRACTICE";
            practiceToCreate.hospitalIds = _.pluck(practiceToCreate.hospitalIds, "_id");

            // Assign a type to practice
            AdminPracticeService.createPractice(practiceToCreate, function() {

                $state.go(organizationsIndex);
            });
        }

    };

    //
    // PRIVATES
    //

    //
    // Initialize scope
    //
    function init() {

        // Form title - matches page title
        $scope.title = $state.current.title || "";

        // True if we're in edit mode, false if we're creating
        $scope.edit = !!practice;

        // Display the practice data when editing
        $scope.practice = practice || {};

        // Display the practice detail
        $scope.hospitals = hospitals || [];

        // Display schedulers for a practice when editing
        $scope.users = users || [];

        // Tag each affiliated hospital as non-removable (for typeahead).
        // Admins can only add new hospitals, not remove previously
        // affiliated hospitals
        _.each(affiliatedHospitals, function(affiliatedHospital) {
            affiliatedHospital.disableRemove = true;
        });
        $scope.practice.hospitalIds = affiliatedHospitals || [];

    }

};

angular.module("mtApp").controller("AdminPracticeController", AdminPracticeController);

//
// AdminPracticeService service
//

'use strict';

angular.module('mtApp').factory('AdminPracticeService', function AdminPracticeService(OrganizationDAO, QMService) {

    return {

        //
        // Find hospitals affiliated with the specified practice
        //
        findHospitalsAffiliatedWithPractice: function(practiceId, next) {

            next = next || angular.noop;

            return OrganizationDAO.findOrganizationsAffiliatedTo({
                id: practiceId
            }, next).$promise;
        },

        //
        // Create Practice
        //
        createPractice: function (practice, next) {

            next = next || angular.noop;

            return OrganizationDAO.createPractice(practice, next).$promise;
        },

        //
        // Find practice
        //
        editPractice: function (id, next) {

            next = next || angular.noop;

            return OrganizationDAO.editPractice({ id : id }, next).$promise
        },

        //
        // Update practice
        //
        updatePractice: function(practice, next) {

            next = next || angular.noop;

            OrganizationDAO.updatePractice({
                id: practice._id
            }, practice, next);
        }

    };

});

//
// Product source DAO
//

"use strict";

angular.module("mtApp").factory("AdminTrayDAO", function ($resource) {

    return $resource("/api/admin/trays/:id", {
        id: "@id"
    }, {
        findActiveTrays: {
            method: "GET",
            url: "/api/admin/trays/active",
            isArray:true
        },
        retireTray: {
            method: "PUT",
            url: "/api/admin/trays/:id/retire"
        },
        updateTray: {
            method: "PUT",
            url: "/api/admin/trays/:id",
            isArray: false
        }
    });
});

//
// Form controller for creating trays
//

"use strict";


var AdminTrayFormController =  function ($scope, AdminTrayService) {

    // Set up controller scope
    init();

    //
    // Create product source
    //
    $scope.createTray = function(trayForm) {

        $scope.traySubmitted = true;

        if ( trayForm.$valid ) {

            $scope.trayDebounced = true;

            var productId = $scope.product._id;
            AdminTrayService.createTray(productId, $scope.tray.name, function(savedTray) {

                $scope.trays.push(savedTray);
                $scope.trays.sort(AdminTrayService.sortTrays);

                $scope.traySubmitted = false;
                $scope.trayDebounced = false;

                $scope.tray.name = "";
            });
        }
    };

    //
    // PRIVATES
    //

    //
    // Setup controller
    //
    function init() {

        $scope.tray = {
            name: ""
        };
    }
};

angular.module("mtApp").controller("AdminTrayFormController", AdminTrayFormController);

//
// List item controller for listing trays (in admin)
//

"use strict";


var AdminTrayListItemController =  function ($scope, ngDialog, AdminTrayService) {

    // Set up controller scope
    init();

    //
    // Cancel edit of tray
    //
    $scope.cancelEdit = function() {

        $scope.edit = false;
        $scope.tray.name = $scope.nameBackup;
    };

    //
    // Edit tray (name only)
    //
    $scope.editTray = function() {

        $scope.edit = true;

        // Take a backup of the tray's name in case
        // the user cancels out of the edit
        $scope.nameBackup = $scope.tray.name;
    };

    //
    // Retire tray
    //
    $scope.retireTray = function() {

        ngDialog.closeAll();

        var trayId = $scope.tray._id;
        AdminTrayService.retireTray($scope.tray._id, function() {

            // Remove tray from list
            for ( var i = 0 ; i < $scope.trays.length ; i++ ) {

                var tray = $scope.trays[i];
                if ( tray._id === trayId ) {
                    $scope.trays.splice(i, 1);
                    break;
                }
            }
        });
    };

    //
    // Show confirm prompt for retiring the current product source
    //
    $scope.showConfirmRetireTray = function() {

        ngDialog.open({
            template:"/partials/admin/tray/confirm-retire.html",
            className: "ngdialog-default",
            scope: $scope
        });
    };

    //
    // Update tray (name only)
    //
    $scope.updateTray = function() {

        // Close out of edit mode
        $scope.edit = false;

        // Save change in rep
        AdminTrayService.updateTray($scope.tray._id, $scope.tray.name);
    };

    //
    // PRIVATES
    //

    //
    // Setup controller
    //
    function init() {

        $scope.edit = false;
    }
};

angular.module("mtApp").controller("AdminTrayListItemController", AdminTrayListItemController);

//
// Admin tray service
//

"use strict";

angular.module("mtApp").factory("AdminTrayService", function AdminTrayService(QMService, AdminTrayDAO) {

    return {

        //
        // Create tray
        //
        createTray: function(productId, trayName, next) {

            next = next || angular.noop;

            var params = {
                product: productId,
                name: trayName
            };

            return AdminTrayDAO.save(params, next).$promise;
        },

        //
        // Find all active trays
        //
        findActiveTraysByProductId: function(productId, next) {

            next = next || angular.noop;

            // Build up filter for querying trays
            // Build up query for search for producsource
            var qm = QMService.getInstance();
            qm.addEqualsQueryFilter("product", productId);

            // Build up sort order
            qm.addSort("name", true);

            // Disable pagination - we want to list all trays
            qm.setPaginated(false);

            return AdminTrayDAO.findActiveTrays(qm.asQuery(), next).$promise;
        },

        //
        // Retire the specified tray
        //
        retireTray: function(trayId, next) {

            next = next || angular.noop;

            return AdminTrayDAO.retireTray({
                id: trayId
            }, next).$promise;
        },


        //
        // Sort trays by name
        //
        sortTrays: function(tray0, tray1) {

            var compareValue0 = tray0.name.toLowerCase();
            var compareValue1 = tray1.name.toLowerCase();

            if ( compareValue0 === compareValue1 ) {

                return 0;
            }

            if ( compareValue0 < compareValue1 ) {
                return -1;
            }

            return 1;
        },

        //
        // Update tray
        //
        updateTray: function(trayId, name, next) {

            next = next || angular.noop;

            return AdminTrayDAO.updateTray({
                id: trayId
            }, {
                name: name
            }, next).$promise;
        }
    };

});

//
// Reports controller - lists all available reports and handles corresponding GETs to server
//
//

"use strict";

angular.module("mtApp").controller("AdminReportsController", function ($scope) {

});

//
// Zaps controller - lists all available zaps and handles corresponding POSTs to server
//
//

"use strict";

angular.module("mtApp").controller("AdminZapsController", function ($scope, AdminZapDAO) {

    //
    // Delete and recreate all rep groups in the local workspace data files
    //
    $scope.convertRepGroups = function() {

        AdminZapDAO.convertRepGroups(function() {

            $scope.repGroupsZapped = true;
        });
    };

    //
    // Convert weight from encrypted string to encrypted value
    // and units
    //
    $scope.convertWeightToValueAndUnits = function() {

        AdminZapDAO.convertWeightToValueAndUnits(function() {

            $scope.weightZapped = true;
        });
    };

    //
    // Set tray end dates
    //
    $scope.setTrayEndDate = function() {

        AdminZapDAO.setTrayEndDate(function() {

            $scope.trayEndDateZapped = true;
        });
    };

    //
    // Set product end dates
    //
    $scope.setProductEndDate = function() {

        AdminZapDAO.setProductEndDate(function() {

            $scope.productEndDateZapped = true;
        });
    };


    //
    // Set procedure end dates
    //
    $scope.setProcedureEndDate = function() {

        AdminZapDAO.setProcedureEndDate(function() {

            $scope.procedureEndDateZapped = true;
        });
    };

    //
    // Set area URI
    //
    $scope.setAreaUri = function() {

        AdminZapDAO.setAreaUri(function() {

            $scope.setAreaUri = true;
        });
    };

    //
    // Set max end date
    //
    $scope.setMaxEndDate = function() {

        AdminZapDAO.setMaxEndDate(function() {

            $scope.setMaxEndDate = true;
        });
    };

    //
    // Capitalize Products
    //
    $scope.capitalizeProducts = function() {

        AdminZapDAO.capitalizeProducts(function() {

            $scope.capitalizeProducts = true;
        });
    };

    //
    // Add "Anterior and Posterior"
    //
    $scope.addAntAndPostFixationLocation = function() {

        AdminZapDAO.addAntAndPostFixationLocation(function () {

            $scope.addAntAndPostFixationLocation = true;
        });
    };
});

//
// Admin zap DAO
//

"use strict";

angular.module("mtApp").factory("AdminZapDAO", function ($resource) {

    return $resource("/api/admin/zaps", {
    }, {
        convertRepGroups: {
            method: "POST",
            url: "/api/admin/zaps/convert-rep-groups",
            isArray: false
        },
        convertWeightToValueAndUnits: {
            method: "POST",
            url: "/api/admin/zaps/convert-weight-to-value-and-units",
            isArray: false
        },
        setTrayEndDate: {
            method: "POST",
            url: "/api/admin/zaps/set-tray-end-date",
            isArray: false
        },
        setProductEndDate: {
            method: "POST",
            url: "/api/admin/zaps/set-product-end-date",
            isArray: false
        },
        setProcedureEndDate: {
            method: "POST",
            url: "/api/admin/zaps/set-procedure-end-date",
            isArray: false
        },
        setAreaUri: {
            method: "POST",
            url: "/api/admin/zaps/set-area-uri",
            isArray: false
        },
        setMaxEndDate: {
            method: "POST",
            url: "/api/admin/zaps/set-max-end-date",
            isArray: false
        },
        capitalizeProducts: {
            method: "POST",
            url: "/api/admin/zaps/capitalize-products",
            isArray: false
        },
        addAntAndPostFixationLocation: {
            method: "POST",
            url: "/api/admin/zaps/add-ant-and-post",
            isArray: false
        }
    });
});

//
// Area service
//

"use strict";

angular.module("mtApp").factory("AreaService", function AreaService(QMService, AreaDAO) {

    return {

        //
        // Find areas with the specified area name
        //
        findAreasByName: function(areaName, callback) {

            callback = callback || angular.noop;

            var qm = QMService.getInstance();
            qm.addEqualsQueryFilter("name", areaName);

            return AreaDAO.findAreaValuesByName(qm.asQuery(), callback).$promise;
        },

        //
        // Find Area by uri
        //
        findAreaByUri: function(areaName, uri, callback) {

            callback = callback || angular.noop;

            return AreaDAO.findAreaByUri({
                name: areaName,
                uri: uri
            }, callback).$promise;
        }
    };
});

//
// Authentication Service
//

"use strict";

angular.module("mtApp").factory("AuthService", function AuthService($q, UserSession, SessionDAO, PersonDAO, USER_ROLES) {

    var init = false;

    return {

        //
        // Returns true if we have attempted to get the current user
        //
        isUserResolved: function() {
            return init;
        },

        //
        // Authenticate user
        //
        // @param  {Object}   user     - login info
        // @param  {Function} callback - optional
        // @return {Promise}
        //
        login: function(user, callback) {

            var cb = callback || angular.noop;

            var that = this;
            return SessionDAO.save({
                email: user.email,
                password: user.password
            }, function(user) {

                // Create a user session
                UserSession.create(user);

                return cb();

            }, function(err) {

                return cb(err);

            }).$promise;
        },

        //
        // Unauthenticate user
        //
        // @param  {Function} callback - optional
        // @return {Promise}
        //
        logout: function(callback) {

            var cb = callback || angular.noop;

            return SessionDAO["delete"](function () {

                // Destroy the current user session
                UserSession.destroy();

                return cb();
            },
            function(err) {

                return cb(err);

            }).$promise;
        },

        //
        // Gets all available info on authenticated user. Queries server once for user
        // details otherwise returns cached user (which can be null if user has not
        // yet logged in).
        //
        // @return {Promise}
        //
        getCurrentUser: function(accessToken) {

            var userDeferred = $q.defer();
            if ( init ) {
                userDeferred.resolve(UserSession.user);
            }
            else {
                PersonDAO.get({
                    access_token: accessToken
                }, function (user) {

                    // If no user was found, set user to be null - $resource
                    // returns an object populated with data from server, must
                    // explicitly check if returned data has ID
                    if (!user._id) {

                        // Destroy any current user session
                        UserSession.destroy();
                    }
                    else {

                        // Create user session
                        UserSession.create(user);
                    }

                    init = true;
                    userDeferred.resolve(UserSession.user);

                });
            }

            return userDeferred.promise;
        },

        //
        // Returns true if user is authenticated
        //
        isAuthenticated: function() {

            return !!UserSession.user._id;
        },

        //
        // Returns true if current user is in the specified role.
        //
        isAuthorized: function (role) {


            return isAuthorized(role, UserSession.user);
        },

        //
        // Returns true if specified user is in the specified role.
        //
        isUserAuthorized: function (role, user) {

            return isAuthorized(role, user);
        },

        //
        // Kill the local session - called when session has timed out
        // (or session has somehow been cleared on the server side) and we
        // have received a 401 response. We must sync up the client side
        // by kill the local session (which should force the login page)
        //
        killLocalSession: function() {

            // Destroy the current user session
            UserSession.destroy();
        }
    };

    //
    // Privates
    //

    //
    // Returns true if user has specified role(s)
    //
    function isAuthorized(role, user) {

        // Convert the role into an array if it's not so we
        // can loop over it
        var roleArray = [].concat(role);
        for ( var i = 0 ; i < roleArray.length ; i++ ) {

            var roleToCheck = roleArray[i];

            // Handle the case where user is authenticated
            if ( user._id ) {

                var userRole = user.role;

                // Ignore links for visitors...
                if ( roleToCheck === USER_ROLES.visitor ) {
                    continue;
                }

                if ( userRole === roleToCheck ) {
                    return true;
                }

                // SPECIAL CASE ***
                // Allow surgeons to have the same auth as users
                if ( userRole === USER_ROLES.surgeon && roleToCheck === USER_ROLES.user ) {
                    return true;
                }
            }
            // Otherwise there is no user - check if role is "visitor"
            else {

                if ( roleToCheck === USER_ROLES.visitor ) {
                    return true;
                }
            }
        }

        return false;
    }
});

//
// Case service
//

"use strict";

angular.module("mtApp").factory("CaseService", function CaseService($q, CPT_CATEGORIES, PAGINATION, USER_ROLES,
                                                                    AuthService, OrganizationService, PersonService,
                                                                    QMService, CaseDAO) {

    return {

        //
        // Calculate BMI Metrics on case - called "dynamically" as case details
        // are completed by scheduler
        //
        calculateBmiMetrics: function(kase, next) {

            next = next || angular.noop;

            // Create a clone to prevent Angular updating UI (ie adding validation
            // errors to case values) as we normalize case values
            var kaseClone = {};
            _.extend(kaseClone, kase);

            // Combine feet and inches into a single height value
            prepareHeightForSave(kaseClone);

            // Specify units for weight
            prepareWeightForSave(kaseClone);

            return CaseDAO.calculateBmiMetrics({
                height: kaseClone.height.value,
                heightUnit: kaseClone.height.unit,
                weight: kaseClone.weight.value,
                weightUnit: kaseClone.weight.unit,
                age: kaseClone.age
            }, next).$promise;
        },

        //
        // Create case
        //
        createCase: function(kase, callback) {

            callback = callback || angular.noop;

            // Create a clone to prevent Angular updating UI (ie adding validation
            // errors to case values) as we normalize case values
            var kaseClone = {};
            _.extend(kaseClone, kase);

            // Determine the primary CPT category
            var cptCategory = kaseClone.procedures[0].category;

            // Add procedure IDs
            var procedureIds = kaseClone.procedures.map(function(procedure) {
                return procedure._id;
            });
            kaseClone.procedures = procedureIds;

            // Combine feet and inches into a single height value
            prepareHeightForSave(kaseClone);

            // Specify units for weight
            prepareWeightForSave(kaseClone);

            // Setup additional case information according to CPT category
            if ( cptCategory === CPT_CATEGORIES.spine ) {
                prepareAdditionalSpineInformation(kaseClone);
            }
            else {
                prepareAdditionalNonSpineInformation(kaseClone);
            }

            // Remove calculated fields
            removeCalculatedFields(kaseClone);

            CaseDAO.save(kaseClone, callback);
        },

        //
        // Update case
        //
        updateCase: function(kase, callback) {

            callback = callback || angular.noop;

            // Create a clone to prevent Angular updating UI (ie adding validation
            // errors to case values) as we normalize case values
            var kaseClone = {};
            _.extend(kaseClone, kase);

            // Determine the primary CPT category
            var cptCategory = kaseClone.procedures[0].category;

            // Add procedure IDs
            var procedureIds = kaseClone.procedures.map(function(procedure) {
                return procedure._id;
            });
            kaseClone.procedures = procedureIds;

            // Combine feet and inches into a single height value
            prepareHeightForSave(kaseClone);

            // Specify units for weight
            prepareWeightForSave(kaseClone);

            // Setup additional case information according to CPT category
            if ( cptCategory === CPT_CATEGORIES.spine ) {
                prepareAdditionalSpineInformation(kaseClone);
            }
            else {
                prepareAdditionalNonSpineInformation(kaseClone);
            }

            // Remove calculated fields
            removeCalculatedFields(kaseClone);

            CaseDAO.updateCase({
                id: kaseClone._id
            }, kaseClone, callback);
        },

        //
        // Confirm case (general confirmation)
        //
        confirmCaseGeneral: function(caseId, next) {

            CaseDAO.confirmCaseGeneral({
                id: caseId
            }, next);
        },

        //
        // Update implant delivery confirmation
        //
        confirmImplantDelivery: function(caseId, implantId, next) {

            CaseDAO.confirmImplantDelivery({
                id: caseId,
                implantId: implantId
            }, next);
        },

        //
        // Update implant delivery confirmation
        //
        confirmSterilizationDate: function(caseId, implantId, next) {

            CaseDAO.confirmSterilizationDate({
                id: caseId,
                implantId: implantId
            }, next);
        },

        //
        // Update tray details confirmation
        //
        confirmTrayDetails: function(caseId, implantId, trays, next) {

            CaseDAO.confirmTrayDetails({
                id: caseId,
                implantId: implantId,
                trays: trays
            }, next);
        },

        //
        // Find active cases
        //
        countActiveCases: function(qm, favoritesEnabled, user, next) {

            next = next || angular.noop;

            // Handle dashboard for reps
            if ( AuthService.isAuthorized(USER_ROLES.rep) ) {

                qm.addInQueryFilter("status", ["ACTIVE"]);
                return countCasesForRep(qm, user, next);
            }

            qm.addQueryParam("status", ["ACTIVE"]);

            if ( favoritesEnabled ) {

                // Find cases for surgeons that the current user has marked as favorite
                return countCasesByFavoriteSurgeons(qm, next);
            }

            // Otherwise find cases for all surgeons at the current user's organization
            return countCasesByUserOrganizationSurgeons(qm, user, next);
        },

        //
        //
        //
        countActiveCasesWithUnconfirmedImplants: function(qm, implantConfirmationType, favoritesEnabled, user, next) {

            // Build up field name of confirmation type that we are filtering on
            buildCasesFilteredByConfirmationStatusQM(qm, implantConfirmationType, favoritesEnabled);

            return this.countActiveCases(qm, favoritesEnabled, user, next);
        },

        //
        // Get normalized version of case for populating case form
        //
        editCase: function(caseId, next) {

            next = next || angular.noop;

            return CaseDAO.editCase({
                id: caseId
            }, next).$promise;
        },

        //
        // Find case with the specified ID
        //
        findCaseById: function(caseId, next) {

            next = next || angular.noop;

            return CaseDAO.get({
                id: caseId
            }, next).$promise;
        },

        //
        // Find case for details page with populated amendments
        //
        showCase: function(caseId, next) {

            next = next || angular.noop;

            return CaseDAO.showCase({
                id: caseId
            }, next).$promise;
        },

        //
        // Return active cases for the current page and also the total count
        // of cases. This is called for the auto refresh of the dashboard.
        // TODO refactor: make find and count methods a single server call then merge corresponding find and count methods below
        //
        findAndCountActiveCases: function(qm, favoritesEnabled, user, next) {

            next = next || angular.noop;

            var deferred = $q.defer();
            var that = this;
            this.findActiveCases(qm, favoritesEnabled, user).then(function(cases) {

                // Clear out any sorts for the count query TODO - revisit this (refactor to use list model)
                qm.setSortable(false);

                that.countActiveCases(qm, favoritesEnabled, user, function(count) {

                    var casesAndCount = {
                        items: cases,
                        count: count.count
                    };

                    deferred.resolve(casesAndCount);
                    next(casesAndCount);
                });
            });

            return deferred.promise;
        },

        //
        // Return active cases with unconfirmed implants for the current page and also the total count
        // of cases. This is called for the auto refresh of the dashboard.
        // TODO refactor: make find and count methods a single server call then merge corresponding find and count methods below
        //
        findAndCountActiveCasesWithUnconfirmedImplants: function(qm, implantConfirmationType, favoritesEnabled, user, next) {

            next = next || angular.noop;

            var deferred = $q.defer();
            var that = this;

            // Build up field name of confirmation type that we are filtering on
            buildCasesFilteredByConfirmationStatusQM(qm, implantConfirmationType, favoritesEnabled);
            this.findActiveCases(qm, favoritesEnabled, user).then(function(cases) {

                that.countActiveCasesWithUnconfirmedImplants(qm, implantConfirmationType, favoritesEnabled, user, function(count) {

                    var casesAndCount = {
                        items: cases,
                        count: count.count
                    };

                    deferred.resolve(casesAndCount);
                    next(casesAndCount);
                });
            });

            return deferred.promise;
        },

        //
        // Find and count closed and canceled cases
        // TODO refactor: make find and count methods a single server call then merge corresponding find and count methods below
        //
        findAndCountClosedAndCanceledCases: function(qm, favoritesEnabled, user, next) {

            next = next || angular.noop;

            var deferred = $q.defer();
            var that = this;

            this.findClosedAndCanceledCases(qm, favoritesEnabled, user).then(function(cases) {

                that.countClosedAndCanceledCases(qm, favoritesEnabled, user, function(count) {

                    var casesAndCount = {
                        items: cases,
                        count: count.count
                    };

                    deferred.resolve(casesAndCount);
                    next(casesAndCount);
                });
            });

            return deferred.promise;
        },

        //
        // Find active cases
        //
        findActiveCases: function(qm, favoritesEnabled, user, next) {

            next = next || angular.noop;

            // Handle dashboard for reps
            if ( AuthService.isAuthorized(USER_ROLES.rep) ) {

                qm.addInQueryFilter("status", ["ACTIVE"]);
                return findCasesForRep(qm, user, next);
            }

            // Cases by org and cases by fave surgeon are a two-prong
            // query on the server-side. Must add status as query param
            // rather than filter as adding it as a filter will affect
            // the first query (which we don't want) rather than the second
            // query that we do want)
            // TODO refactor: two-prong
            qm.addQueryParam("status", ["ACTIVE"]);

            // Otherwise show cases for schedulers...
            if ( favoritesEnabled ) {

                // Find cases for surgeons that the current user has marked as favorite
                return findCasesByFavoriteSurgeons(qm, next);
            }

            // Otherwise find cases for all surgeons at the current user's organization
            return findCasesByUserOrganizationSurgeons(qm, user, next);
        },

        //
        // Find active cases with the specified
        //
        findActiveCasesWithUnconfirmedImplants: function(qm, implantConfirmationType, favoritesEnabled, user, next) {

            // Build up field name of confirmation type that we are filtering on
            buildCasesFilteredByConfirmationStatusQM(qm, implantConfirmationType, favoritesEnabled);

            return this.findActiveCases(qm, favoritesEnabled, user, next);
        },

        //
        // Find case by Medtel ID
        //
        findCaseByMedtelId: function (qm, medtelId, favoritesEnabled, user, next) {

            next = next || angular.noop;

            // Filter cases by the specifeid Medtel ID
            // TODO fix this - same as for filter by confirmation status (favorites is a two-prong query so can not add filter here)
            if ( favoritesEnabled ) {
                qm.addQueryParam("medtelId", medtelId);
            }
            else {
                qm.addEqualsQueryFilter("medtelId", medtelId);
            }

            return this.findActiveCases(qm, favoritesEnabled, user, next);
        },

        //
        // Find closed and canceled cases
        //
        findClosedAndCanceledCases: function(qm, favoritesEnabled, user, next) {

            next = next || angular.noop;

            // Handle inactive cases dashboard for reps
            if ( AuthService.isAuthorized(USER_ROLES.rep) ) {

                qm.addInQueryFilter("status", ["CLOSED", "CANCELED"]);
                return findCasesForRep(qm, user, next);
            }

            qm.addQueryParam("status", ["CLOSED", "CANCELED"]);

            if ( favoritesEnabled ) {

                // Find cases for surgeons that the current user has marked as favorite
                return findCasesByFavoriteSurgeons(qm, next);
            }

            // Otherwise find cases for all surgeons at the current user's organization
            return findCasesByUserOrganizationSurgeons(qm, user, next);
        },

        //
        // Count all closed and canceled cases
        //
        countClosedAndCanceledCases: function(qm, favoritesEnabled, user, next) {

            next = next || angular.noop;

            // Handle closed and canceled cases dashboard for reps
            if ( AuthService.isAuthorized(USER_ROLES.rep) ) {

                qm.addInQueryFilter("status", ["CLOSED", "CANCELED"]);
                return countCasesForRep(qm, user, next);
            }

            qm.addQueryParam("status", ["CLOSED", "CANCELED"]);

            if ( favoritesEnabled ) {

                // Count cases for surgeons that the current user has marked as favorite
                return countCasesByFavoriteSurgeons(qm, next);
            }

            // Otherwise find cases for all surgeons at the current user's organization
            return countCasesByUserOrganizationSurgeons(qm, user, next);
        },

        //
        //  Returns true if current user has confirmed the
        // implants they are responsible for
        //
        countRepUnconfirmedCases: function(repId, next) {

            return CaseDAO.countRepUnconfirmedCases({
                repId: repId
            }, next).$promise;
        },

        //
        // Returns true if no implants for case have been confirmed
        //
        isUnconfirmed: function(user, kase) {

            // If the user is a scheduler, just use the overall confirmation
            // status on the case
            if ( AuthService.isAuthorized(USER_ROLES.user) ) {
                return kase.confirmationStatus === 0;
            }

            // Otherwise, the user is a rep - we must check each
            // implant individually to see if the implants for this
            // particular rep have been confirmed
            return countConfirmedImplants(kase.implants) === 0;
        },

        //
        // Returns true if no implants for case have been confirmed
        //
        isPartiallyConfirmed: function(user, kase) {

            // If the user is a scheduler, just use the overall confirmation
            // status on the case
            if ( AuthService.isAuthorized(USER_ROLES.user) ) {
                return kase.confirmationStatus === 1;
            }

            // Otherwise, the user is a rep - we must check each
            // implant individually to see if the implants for this
            // particular rep have been confirmed
            var confirmedCount = countConfirmedImplants(kase.implants);
            return (confirmedCount > 0) && (confirmedCount < kase.implants.length);
        },

        //
        // Returns true if:
        // 1. For schedulers, all implants for case have been confirmed
        // 2. For reps, all implants for the current rep have been confirmed
        isConfirmed: function(user, kase) {

            // If the user is a scheduler, just use the overall confirmation
            // status on the case
            if ( AuthService.isAuthorized(USER_ROLES.user) ) {
                return kase.confirmationStatus === 2;
            }

            // Otherwise, the user is a rep - we must check each
            // implant individually to see if the implants for this
            // particular rep have been confirmed
            return (countConfirmedImplants(kase.implants) === kase.implants.length);
        },

        //
        // Returns true if the category of the primary procedure
        // is sports medicine
        //
        isSportsMedicine: function (kase) {

            return isProcedureInCategory(kase, CPT_CATEGORIES.sportsMedicine);

        },

        //
        // Returns true if the category of the primary procedure
        // is neurosurgery
        //
        isNeurosurgery: function (kase) {

            return isProcedureInCategory(kase, CPT_CATEGORIES.neurosurgery);
        },

        //
        // Returns true if category of primary procedure is orthopedics
        //
        isOrthopedic: function (kase) {

            return isProcedureInCategory(kase, CPT_CATEGORIES.orthopedic);
        },

        //
        // Returns true if the category of the primary procedure
        // is spine
        //
        isSpine: function (kase) {

            return isProcedureInCategory(kase, CPT_CATEGORIES.spine);
        }
    };

    //
    // Privates
    //

    //
    // Count cases for the specified rep
    //
    function countCasesForRep(qm, rep, next) {

        next = next || angular.noop;

        buildCasesForRepQM(qm, rep);
        qm.setPaginated(false);

        return CaseDAO.countCases(qm.asQuery(), next).$promise;
    }

    //
    // Find cases for surgeons according to rules around the user's
    // organization surgeon visilibity rights
    //
    function findCasesByUserOrganizationSurgeons(qm, user, next) {

        next = next || angular.noop;

        // Find the organization IDs that are applicable to the current
        // practice/hospital/hospital group user
        var surgeonOrgIds = PersonService.generateListOfSurgeonOrganizations(user);
        qm.addQueryParam("organizationIds", surgeonOrgIds);

        // Build up filters for querying for surgeons
        buildCasesByUserOrganizationSurgeons(qm, user);

        // Build up sort order
        qm.addSort("date", true);
        qm.addSort("medtelId", true);

        // If the user has visibility rights assigned to them, only return
        // cases for surgeons that are applicable
        if ( user.visibilityRights.length ) {

            qm.addInQueryFilter("surgeon._id", user.visibilityRights);
        }

        // Find cases...
        return CaseDAO.findCasesByUserOrganizationSurgeons(qm.asQuery(), next).$promise;
    }

    //
    // Count cases for surgeons according to rules around the user's
    // organization surgeon visilibity rights
    //
    function countCasesByUserOrganizationSurgeons(qm, user, next) {

        next = next || angular.noop;

        // Find the organization IDs that are applicable to the current
        // practice/hospital/hospital group user
        var surgeonOrgIds = PersonService.generateListOfSurgeonOrganizations(user);
        qm.addQueryParam("organizationIds", surgeonOrgIds);

        // Build up filters for querying for surgeons
        buildCasesByUserOrganizationSurgeons(qm, user);

        return CaseDAO.countCasesByUserOrganizationSurgeons(qm.asQuery(), next).$promise;
    }

    //
    // Find cases for the specified rep - must search for rep's own cases
    // and also cases where they are a backup
    //
    function findCasesForRep(qm, rep, next) {

        next = next || angular.noop;

        buildCasesForRepQM(qm, rep);

        // Build up sort order
        qm.addSort("date", true);
        qm.addSort("medtelId", true);

        return CaseDAO.query(qm.asQuery(), next).$promise;
    }

    //
    // Find cases for surgeons selected as favorites by the current user
    //
    function findCasesByFavoriteSurgeons(qm, next) {

        next = next || angular.noop;

        // Build up filter for querying favorites
        buildCasesByFavoriteSurgeonsQM(qm);

        // Build up sort order
        qm.addSort("date", true);
        qm.addSort("medtelId", true);

        return CaseDAO.findCasesByFavoriteSurgeons(qm.asQuery(), next).$promise;
    }


    //
    // Count cases for surgeons selected as favorites by the current user
    //
    function countCasesByFavoriteSurgeons(qm, next) {

        next = next || angular.noop;

        // Build up filter for querying favorites
        buildCasesByFavoriteSurgeonsQM(qm);

        return CaseDAO.countCasesByFavoriteSurgeons(qm.asQuery(), next).$promise;
    }

    //
    // Convert feet and inches value into a single height value. If no
    // height specified, default height to:
    //
    // {
    //   value: "",
    //   units: ""
    // }
    //
    function prepareHeightForSave(kase) {

        var feet = kase.heightFeet;
        var inches = kase.heightInches;

        delete kase.heightFeet;
        delete kase.heightInches;

        if ( !feet && !inches ) {
            kase.height = {
                value: "",
                unit: ""
            };
            return;
        }

        if ( !inches ) {
            inches = 0;
        }

        kase.height = {
            value: (feet * 12) + inches,
            unit: "inches"
        };
    }

    //
    // Add weight unit. If no weight specified, default weight to:
    //
    // {
    //   value: "",
    //   units: ""
    // }
    //
    function prepareWeightForSave(kase) {

        if ( !kase.weight || !kase.weight.value ) {
            kase.weight = {
                value: "",
                unit: ""
            };
            return;
        }

        var weight = kase.weight.value;
        if ( weight ) {
            kase.weight.unit = "pounds";
        }
    }

    //
    // Prepare non-spine (eg orthopedic, sports med, neurosurgery) information
    // for save - convert any objects to IDs
    //
    function prepareAdditionalNonSpineInformation(kase) {

        // Add write ins to case
        kase.writeIns = identifyImplantWriteIns(kase.implants);

        // Add implant IDs
        var implantIds = kase.implants.map(function(implant) {
            return implant._id;
        });
        kase.implants = implantIds;

        // Add ancillary products
        var productIds = kase.ancillaryProducts.map(function(product) {
            return product._id;
        });
        kase.ancillaryProducts = productIds;
    }

    //
    // Prepare spine information for save - convert any objects to IDs
    //
    function prepareAdditionalSpineInformation(kase) {

        // Add write ins to case
        kase.writeIns = identifyImplantWriteIns(kase.fixations)
            .concat(identifyImplantWriteIns(kase.interbodies));

        // Grab the implant fixation IDs
        var fixationIds = kase.fixations.map(function(fixation) {
            return fixation._id;
        });

        // Grab the implant interbody IDs
        var interbodyIds = kase.interbodies.map(function(interbody) {
            return interbody._id;
        });

        // Add fixation and interbody IDs as a single array
        kase.implants = fixationIds.concat(interbodyIds);

        // Add bonegraft products
        var boneGraftProductsIds = kase.boneGraftProducts.map(function(product) {
            return product._id;
        });
        kase.boneGraftProducts = boneGraftProductsIds;

        // Add monitoring products
        var monitoringProductsIds = kase.monitoringProducts.map(function(product) {
            return product._id;
        });
        kase.monitoringProducts = monitoringProductsIds;

        // Add ancillary products
        var ancillaryProductIds = kase.ancillaryProducts.map(function(product) {
            return product._id;
        });
        kase.ancillaryProducts = ancillaryProductIds;
    }

    //
    // Identify and return write ins in the specifed array
    // of implants
    //
    function identifyImplantWriteIns(implants) {

        var writeIns = [];
        for ( var i = 0 ; i < implants.length ; i++ ) {

            var implant = implants[i];
            if ( implant.writeIn ) {
                writeIns.push(implant);
            }
        }

        return writeIns;
    }

    //
    // Returns true if the primary (first selected) procedure is
    // in the specified category
    //
    function isProcedureInCategory(kase, category) {

        if ( kase.procedures.length > 0 ) {

            var primaryProcedure = kase.procedures[0];
            return !!(primaryProcedure && primaryProcedure.category === category);
        }

        return false;
    }

    //
    // Calculate the number of confirmed implants on the case
    //
    function countConfirmedImplants(implants) {

        var confirmedCount = 0;
        for ( var i = 0 ; i < implants.length ; i++ ) {

            var implant = implants[i];
            if ( implant.confirmedGeneral && implant.confirmedGeneral.confirmed ) {
                confirmedCount++;
            }
        }

        return confirmedCount;
    }

    //
    // Build up query builder for querying for cases for
    // the specified rep. Called when list cases for rep
    // or counting cases for rep
    //
    function buildCasesForRepQM(qm, rep) {

        // Filter for cases where rep is either the primary
        // or backup rep
        var repGroupIds = rep.organizations.backup.map(function(repGroup) {
            return repGroup._id;
        });
        if ( repGroupIds.length ) {

            qm.addOrQueryFilter([
                qm.buildEqualsQueryFilter("implants.rep._id", rep._id),
                qm.buildInQueryFilter("implants.backup", repGroupIds)
            ]);
        }
        else {

            qm.addEqualsQueryFilter("implants.rep._id", rep._id);
        }
    }

    //
    // Build up query builder for querying for active cases for
    // the scheduler where they have favorites enabled. Called when list
    // active cases for scheduler or counting active cases for scheduler
    //
    function buildCasesByFavoriteSurgeonsQM(qm) {

        qm.addEqualsQueryFilter("entityType", "SURGEON");
    }

    //
    // Build up query builder for querying for active cases for
    // the scheduler (where favorites are not enabled). Called when list active
    // cases for scheduler or counting active cases for scheduler
    //
    function buildCasesByUserOrganizationSurgeons(qm, user) {

        // If the user has visibility rights assigned to them, only return
        // cases for surgeons that are applicable
        if ( user.visibilityRights.length ) {

            qm.addInQueryFilter("surgeon._id", user.visibilityRights);
        }
    }


    //
    // For favorites, add query param for filtering by specified confirmation. This needs to be
    // done separately from the "filters" as there is a two part query on the back end
    // and we don't want the confirmation to be added as a filter as it will break the
    // intiial query.
    // TODO - refactor to more specific query on back on
    //
    function buildCasesFilteredByConfirmationStatusQM(qm, implantConfirmationType, favoritesEnabled) {

        if ( favoritesEnabled ) {
            qm.addQueryParam("filterByConfirmationStatus", implantConfirmationType);
        }
        else {

            // Build up field name of confirmation type that we are filtering on
            var confirmationFieldName = ["implants."];
            confirmationFieldName.push(implantConfirmationType);
            confirmationFieldName.push(".confirmed");

            qm.addEqualsQueryFilter(confirmationFieldName.join(""), false);
        }
    }

    //
    // Remove calculated fields
    //
    function removeCalculatedFields(kaseClone) {

        delete kaseClone.bmi;
    }

});

//
// Favorite service
//

'use strict';

angular.module('mtApp').factory('FavoriteService', function FavoriteService(FavoriteDAO) {

    return {

        //
        // Create favorite - called for favorites that are not
        // per hospital (ie procedures and hospitals)
        //
        createFavorite: function(entityId, entityType, callback) {

            createFavorite(entityId, entityType, null, callback);
        },

        //
        // Create favorite  - this is called for
        // favorites that are selected on a per-hospital basis (ie implants,
        // surgeons and products)
        //
        createFavoriteForOrganization: function(entityId, entityType, organizationId, callback) {

            createFavorite(entityId, entityType, organizationId, callback);
        },

        //
        // Create favorite for implant
        //
        createFavoriteImplant: function(entityId, cptCategory, organizationId, callback) {

            callback = callback || angular.noop;

            var favorite = {
                entityId: entityId,
                entityType: "IMPLANT",
                organization: organizationId,
                cptCategory: cptCategory
            };

            FavoriteDAO.save(favorite, callback);
        },

        //
        // Create favorite for product
        //
        createFavoriteProduct: function(entityId, entityType, cptCategory, organizationId, callback) {

            callback = callback || angular.noop;

            var favorite = {
                entityId: entityId,
                entityType: entityType,
                organization: organizationId,
                cptCategory: cptCategory
            };

            FavoriteDAO.save(favorite, callback);
        },

        //
        // Delete favorite - called for favorites that are not
        // per hospital (ie procedures and hospitals)
        //
        deleteFavorite: function(entityId, entityType, callback) {

            // Build up filter for deleting surgeons and execute
            deleteFavorite(entityId, entityType, null, callback);
        },

        //
        // Delete favorite for the specified hospital - this is called for
        // favorites that are selected on a per-hospital basis (ie implants,
        // surgeons and products)
        //
        deleteFavoriteForOrganization: function(entityId, entityType, organizationId, callback) {

            // Build up filter for deleting surgeons and execute
            deleteFavorite(entityId, entityType, organizationId, callback);
        },

        //
        // Delete all favorites for the specified organization (ie implants,
        // surgeons, products)
        //
        deleteAllForOrganization: function(organizationId, callback) {

            callback = callback || angular.noop;

            var filters = [];
            filters.push(buildQueryFilter("EQUALS", "organization", organizationId));

            FavoriteDAO["delete"]({
                filters: filters
            }, callback);
        }
    };

    //
    // PRIVATES
    //

    //
    // Build query filter
    //
    function buildQueryFilter(filterType, fieldName, value) {

        return {
            filterType: filterType,
            fieldName: fieldName,
            value: value
        };
    }

    //
    // Create favorite with the specified values. Only certain favorites
    // have an organization (hospital) ID associated with them (ie implants,
    // surgeons, products). Favorite procedures and favorite hospitals are
    // not per-hospital and therefore do not have an organization ID associated
    // to them.
    //
    function createFavorite(entityId, entityType, organizationId, callback) {

        callback = callback || angular.noop;

        var favorite = {
            entityId: entityId,
            entityType: entityType
        };

        if ( organizationId ) {
            favorite.organization = organizationId;
        }

        FavoriteDAO.save(favorite, callback);
    }

    //
    // Delete favorite with the specified values. Only certain favorites
    // have an organization (hospital) ID associated with them (ie implants,
    // surgeons, products). Favorite procedures and favorite hospitals are
    // not per-hospital and therefore do not have an organization ID associated
    // to them.
    //
    function deleteFavorite(entityId, entityType, organizationId, callback) {

        callback = callback || angular.noop;

        var filters = [];
        filters.push(buildQueryFilter("EQUALS", "entityId", entityId));
        filters.push(buildQueryFilter("EQUALS", "entityType", entityType));

        if ( organizationId ) {
            filters.push(buildQueryFilter("EQUALS", "organization", organizationId));
        }

        FavoriteDAO["delete"]({
            filters: filters
        }, callback);
    }

});
//
// Location service
//

'use strict';

angular.module('mtApp').factory('LocationService', function LocationService(LocationDAO) {

    return {

        //
        // Find locations with the specified CPT category
        //
        findLocationsByCPTCategory: function(locationName, callback) {

            callback = callback || angular.noop;

            LocationDAO.query({
                name: locationName
            }, callback);
        }
    };
});
//
// Metadata service
//

"use strict";

angular.module("mtApp").factory("MetaDataService", function MetaDataService() {

    var columnsByName = {
        procedure: [
            {displayName:"Code", fieldName:"code", idKey: true},
            {displayName:"Description", fieldName:"description"},
            {displayName:"Category", fieldName:"category"}
        ],
        product: [
            {displayName:"Name", fieldName:"name"},
            {displayName:"Type", fieldName:"productType"},
            {displayName:"Category", fieldName:"category"},
            {displayName:"Manufacturer", fieldName:"manufacturer.name"}
        ],
        organization: [
            {displayName:"Name", fieldName:"name", idKey: true}
        ],
        person: [
            {displayName: "First Name", fieldName: "firstName"},
            {displayName: "Last Name", fieldName: "lastName"},
            {displayName: "Email", fieldName: "email", idKey: true},
            {displayName: "Phone", fieldName: "phone"},
            {displayName: "Role", fieldName: "role"},
            {displayName: "Organization", fieldName: "organizations.home.name"},
            {displayName: "Last Seen", fieldName: "lastActivity"}
        ]
    };

    return {

        getColumns: function(name) {
            return columnsByName[name];
        }

    };

});

//
// Organization service
//

'use strict';

angular.module('mtApp').factory('OrganizationService', function OrganizationService(PAGINATION, USER_ROLES, FavoriteDAO, OrganizationDAO) {

    return {

        //
        // Find all hospital groups to be listed in admin
        //
        findAdminHospitalGroups: function(offset, next) {

            return findAdminOrganization(offset, "HOSPITAL_GROUP", false, next);
        },

        //
        // Find all hospitals to be listed in admin
        //
        findAdminHospitals: function(offset, next) {

            return findAdminOrganization(offset, "HOSPITAL", false, next);
        },

        //
        // Find all rep groups to be listed in admin
        //
        findAdminRepGroups: function(offset, next) {

            return findAdminOrganization(offset, "REP_GROUP", false, next);
        },

        //
        // Find all organizations the specified role - use to populate
        // the organization select box when create a user with that role
        //
        findAdminOrganizationsForRole: function(role, next) {

            next = next || angular.noop;

            // Build up filter
            var filters = [];
            if ( role === USER_ROLES.user || role === USER_ROLES.surgeon ) {
                filters.push(buildQueryFilter("IN", "type", ["HOSPITAL", "PRACTICE"]));
            }
            else if ( USER_ROLES.rep ) {
                filters.push(buildQueryFilter("EQUALS", "type", "MANUFACTURER"));
            }

            // Build up sort order
            var sorts = [];
            sorts.push(buildQuerySort("name", true));

            return OrganizationDAO.findAdminOrganizations({
                filters:filters,
                sorts: sorts
            }, next).$promise;
        },

        //
        // Find all manufacturers to be listed in admin
        //
        findAdminManufacturers: function(offset, next) {

            return findAdminOrganization(offset, "MANUFACTURER", false, next);
        },

        //
        // Find all manufacturers to be displayed in product dropdown list
        //
        findAllAdminManufacturers: function(offset, next) {

            return findAdminOrganization(offset, "MANUFACTURER", true, next);
        },

        //
        // Find all practices to be listed in admin
        //
        findAdminPractices: function(offset, next) {
            return findAdminOrganization(offset, "PRACTICE", false, next);
        },

        //
        // Get information of specific organization by id
        //
        findOrganizationById: function(id, next) {

            return OrganizationDAO.findOrganizationById({
                id: id
            }, next).$promise;
        },

        //
        // Count all manufacturers
        //
        countAllManufacturerOrganizations : function (next) {

            return countOrganizations("MANUFACTURER", next);
        },

        //
        // Count all hospital groups
        //
        countAllHospitalGroupsOrganizations : function (next) {

            return countOrganizations("HOSPITAL_GROUP", next);
        },

        //
        // Count all rep groups
        //
        countAllRepGroupsOrganizations : function (next) {

            return countOrganizations("REP_GROUP", next);
        },

        //
        // Count all practices
        //
        countAllPracticesOrganizations : function (next) {

            return countOrganizations("PRACTICE", next);
        },

        //
        // Count all hospitals
        //
        countAllHospitalOrganizations : function (next) {

            return countOrganizations("HOSPITAL", next);
        },
        //
        // Find all hospitals for the current user/hospital - used for
        // populating the select box from which user can choose favorite
        // hospitals
        //
        findAllHospitals: function(affiliatedToId, next) {

            next = next || angular.noop;

            // Build up filter
            var qm = new QueryModel();
            qm.addInQueryFilter("affiliatedOrganizations", affiliatedToId);

            // Build up sort order
            qm.addSort("name", true);

            return OrganizationDAO.findAllOrganizations(qm, next).$promise;
        },

        //
        // Find the favorite hospitals for the current user. Used to list
        // the hospitals selected by the current user on the favorites form
        // (only visibile if user's organization is a practice)
        //
        findFavoriteHospitals: function(next) {

            next = next || angular.noop;

            // Build up sort order for querying implants
            var sorts = [];
            sorts.push(buildQuerySort("name", true));

            return FavoriteDAO.findFavoriteOrganizations({
                sorts: sorts
            }, next).$promise;
        },

        //
        // Find hospitals for the current user - either all hospitals
        // will be returned or if the user has activated favorites,
        // their favorite hospitals will be returned. Called from case
        // initiation screen.
        //
        findUserHospitals: function(favoritesEnabled, user, next) {

            if ( favoritesEnabled ) {
                return this.findFavoriteHospitals(next);
            }

            // If the user organization is a practice OR the user
            // organization is a hospital and the hospital is in
            // a group, return the affiliated hospitals
            if ( this.isPractice(user) || this.isHospitalInGroup(user) ) {
                return this.findAffiliatedHospitals(user);
            }

            // Otherwise the user organization is a hospital that is
            // not in a group, return just the user organization
            return [user.organizations.home];
        },

        //
        // Find all organizations to be listed in admin
        //
        findAdminAll: function(next) {

            next = next || angular.noop;

            // Build up sort order
            var sorts = [];
            sorts.push(buildQuerySort("name", true));

            return OrganizationDAO.findAdminOrganizations({
                sorts: sorts
            }, next).$promise;
        },

        //
        // Returns true if user's home organization is a hospital
        //
        isHospital: function(user) {

            return user.organizations.home.type === "HOSPITAL";
        },

        //
        // Returns true if user's home organization is a practice
        //
        isPractice: function(user) {

            return user.organizations.home.type === "PRACTICE";
        },

        //
        // Returns true if user's organization is a hospital, and the
        // hospital is member of a hospital group
        //
        isHospitalInGroup: function(user) {

            if ( !this.isHospital(user) ) {
                return false;
            }

            // If user is not affiliated with any organizations, they
            // are not in a group
            if ( !user.organizations.affiliatedTo.length ) {
                return false;
            }

            // Check list of affiliated organizations to see if there are any hospitals
            // (affiliated to array can also contain practices and we want to
            // ignore them)
            var affiliatedHospitals = this.findAffiliatedHospitals(user);
            return !!affiliatedHospitals.length;
        },

        //
        // Returns true if user's organization is a hospital, and the
        // hospital has affiliated practices
        //
        isHospitalAffiliatedWithPractices: function(user) {

            if ( !this.isHospital(user) ) {
                return false;
            }

            // Handle the case where user is not affiliated with any practices
            if ( !user.organizations.affiliatedTo.length ) {
                return false;
            }

            // Check list of affiliated organizations to see if there are any practices
            // (affiliated to array can also contain hospitals and we want to
            // ignore them)
            var affiliatedPractices = this.findAffiliatedPractices(user);
            return !!affiliatedPractices.length;
        },

        //
        // Return the list of hospitals that the current user is affiliated
        // with. This function weeds out any practices that is listed in the
        // user's affiliatedTo array
        //
        findAffiliatedHospitals: function(user) {

            return _.filter(user.organizations.affiliatedTo, function(org) {

                return org.type === "HOSPITAL";
            });
        },

        //
        // Return the list of practices that the current user is affiliated
        // with. This function weeds out any hospitals that is listed in the
        // user's affiliatedTo array
        //
        findAffiliatedPractices: function(user) {

            return _.filter(user.organizations.affiliatedTo, function(org) {

                return org.type === "PRACTICE";
            });
        }
    };

    //
    // PRIVATES
    //


    //
    // Build query filter
    //
    function buildQueryFilter(filterType, fieldName, value) {

        return {
            filterType: filterType,
            fieldName: fieldName,
            value: value
        };
    }

    //
    // Build sort order
    // TODO(mim) repeated
    //
    function buildQuerySort(fieldName, asc) {

        return {
            fieldName: fieldName,
            asc: asc
        };
    }

    //
    // Find organizations of the specified type, for listing in admin
    //
    function findAdminOrganization(offset, type, hasLimit, next) {

        next = next || angular.noop;

        // Build up filter
        var filters = [];
        if (_.isArray(type) ) {
            filters.push(buildQueryFilter("IN", "type", type));
        }
        else {
            filters.push(buildQueryFilter("EQUALS", "type", type));
        }

        // Build up sort order
        var sorts = [];
        sorts.push(buildQuerySort("name", true));

        return OrganizationDAO.findAdminOrganizations({
            filters:filters,
            sorts: sorts,
            offset: offset,
            limit: hasLimit ? '' : PAGINATION.ADMIN.limit,
        }, next).$promise;
    }

    //
    // Count the number organizations of the specified type
    //
    function countOrganizations(type, next) {

        next = next || angular.noop;

        // Build up filter
        var filters = [];
        filters.push(buildQueryFilter("EQUALS", "type", type));

        // Build up sort order
        var sorts = [];
        sorts.push(buildQuerySort("name", true));

        return OrganizationDAO.countAllOrganizations({
            filters:filters,
            sorts: sorts
        }, next).$promise;
    }
});

//
// Surgeon service
//

'use strict';

angular.module('mtApp').factory('PersonService', function PersonService(FavoriteDAO, OrganizationService, PersonDAO) {

    return {

        //
        // Find all surgeons for specified user/hospitals - used for
        // populating the select box from which user can choose favorite
        // surgeons OR from selecting a surgeon on the case initiation
        // screen when favorites are disabled
        //
        findAllSurgeons: function(organizationIds, next) {

            next = next || angular.noop;

            // Build up filter for querying surgeons
            var filters = [];
            filters.push(buildQueryFilter("EQUALS", "role", "SURGEON"));
            filters.push(buildQueryFilter("IN", "organizations.home._id", organizationIds));

            // Build up sort order
            var sorts = [];
            sorts.push(buildQuerySort("lastName", true));
            sorts.push(buildQuerySort("firstName", true));

            return PersonDAO.findAllPeople({
                filters: filters,
                sorts: sorts
            }, next).$promise;

        },

        //
        // Find the favorite surgeons for the current user. Used to list
        // the surgeons selected by the current user on the favorites form.
        //
        findFavoriteSurgeons: function(organizationId, next) {

            next = next || angular.noop;

            // Build up filter for querying people
            var filters = [];
            filters.push(buildQueryFilter("EQUALS", "entityType", "SURGEON"));
            filters.push(buildQueryFilter("EQUALS", "organization", organizationId));

            // Build up sort order for querying people
            var sorts = [];
            sorts.push(buildQuerySort("firstName", true));
            sorts.push(buildQuerySort("lastName", true));

            return FavoriteDAO.findFavoritePeople({
                filters: filters,
                sorts: sorts
            }, next).$promise;
        },

        //
        // Find surgeons for the current user.
        // - If the user has enabled favorites, only favorite surgeons will be returned
        // - If the user only has visibility to certain surgeons, only return those surgeons
        // - Otherwise, return all surgeons according to the practice/hospital/hospital group rules
        //
        // Called from case initiation screen.
        //
        findUserSurgeons: function(user, favoriteOrganizationId, favoritesEnabled, next) {

            // If favorites are enabled, return all surgeons that have been
            // selected as a favorite
            if ( favoritesEnabled ) {
                return this.findFavoriteSurgeons(favoriteOrganizationId, next);
            }

            // If user only has a set of surgeons they are allowed to see/book
            // for, return that list
            if ( user.visibilityRights && user.visibilityRights.length ) {
                return this.findVisibleSurgeons(user, next);
            }

            // If user is a hospital user and the user's hospital is in a group, query for
            // surgeons across all hospitals in group
            var hospitalIds = this.generateListOfSurgeonOrganizations(user);

            return this.findAllSurgeons(hospitalIds, next);
        },

        //
        // Return the person with the specified ID
        //
        findPersonById: function(personId, next) {

            next = next || angular.noop;

            return PersonDAO.get({
                id: personId
            }, next).$promise;
        },

        //
        // Return the profile for the current user
        //
        findPersonProfile: function(userId, next) {

            next = next || angular.noop;

            return PersonDAO.findPersonProfile({
                id: userId
            }, next).$promise;
        },

        //
        // Find reps for the specified organization
        //
        findManufacturerReps: function(manufacturerId, next) {

            next = next || angular.noop;

            return PersonDAO.find({}, next).$promise;
        },

        //
        // Return all surgeons user has visibility rights to
        //
        findVisibleSurgeons: function(user, next) {

            // If user is a hospital user and the user's hospital is in a group, query for
            // surgeons across all hospitals in group
            var organizationIds = this.generateListOfSurgeonOrganizations(user);

            // Build up filter for querying surgeons
            var filters = [];
            filters.push(buildQueryFilter("EQUALS", "role", "SURGEON"));
            filters.push(buildQueryFilter("IN", "organizations.home._id", organizationIds));
            filters.push(buildQueryFilter("IN", "_id",user.visibilityRights, "_id"));

            // Build up sort order
            var sorts = [];
            sorts.push(buildQuerySort("firstName", true));
            sorts.push(buildQuerySort("lastName", true));

            return PersonDAO.findAllPeople({
                filters: filters,
                sorts: sorts
            }, next).$promise;
        },

        //
        // Return the list of organization IDs that user has access to
        // the surgeons at
        //
        generateListOfSurgeonOrganizations: function(user) {

            // If the user is a practice user, then they can only schedule
            // for practice surgeons
            if ( OrganizationService.isPractice(user) ) {
                return [user.organizations.home._id];
            }

            // Otherwise the user is a hospital user...

            // If the user's hospital is in a group, return
            // all affiliated organizations (the hospital user can
            // schedule surgeons from any hospital in the group or
            // any surgeons from the affiliated practices). The affiliated
            // hospitals saved on the user will include the user's home hospital
            if ( OrganizationService.isHospitalInGroup(user) ) {

                return user.organizations.affiliatedTo.map(function (hospital) {
                    return hospital._id;
                });
            }

            // If the user's hospital has affiliated practices, return
            // all affiliated organizations (the hospital user can
            // schedule surgeons from their own hospital or
            // any surgeons from the affiliated practices)
            if ( OrganizationService.isHospitalAffiliatedWithPractices(user) ) {

                // Add practice IDs
                var orgIds = user.organizations.affiliatedTo.map(function (hospital) {
                    return hospital._id;
                });

                // Add the user's home organization
                orgIds.push(user.organizations.home._id);

                return orgIds;
            }

            // Otherwise the user's hospital has no affiliated practices and is not
            // in a hospital group - the user can only schedule surgeons from their home
            // hospital
            return [user.organizations.home._id];

        },

        //
        // Return text for displaying rep. Format:
        // "firstName lastName"
        //
        getRepDisplayText: function(rep) {

            return rep.firstName + " " + rep.lastName;
        },

        //
        // Return text for displaying surgeon. Format:
        // "firstName lastName"
        //
        getSurgeonDisplayText: function(surgeon) {

            return surgeon.firstName + " " + surgeon.lastName;
        },

        //
        // Determine if user has enabled favorites
        //
        isFavoritesEnabled: function(next) {

            next = next || angular.noop;

            return PersonDAO.isFavoritesEnabled(next).$promise;
        },

        //
        // Update user email alerts preference - either enable email
        // alerts or disable email alerts
        //
        updateUserEmailAlertsPreference: function(enabled, next) {

            next = next || angular.noop;

            return PersonDAO.updateUserEmailAlertsPreference({
                emailAlerts: enabled
            }, next);
        },

        //
        // Update user favorites preference - either enable favorites
        // or disable favorites
        //
        updateUserFavoritesPreference: function(enabled, next) {

            next = next || angular.noop;

            return PersonDAO.updateUserFavoritesPreference({
                favorites: enabled
            }, next);
        }
    };

    //
    // PRIVATES
    //

    //
    // Build query filter query param
    // TODO(dave) repeated in other services
    //
    function buildQueryFilter(filterType, fieldName, value) {

        return {
            filterType: filterType,
            fieldName: fieldName,
            value: value
        };
    }

    //
    // Build sort order query param
    // TODO(dave) repeated in other services
    //
    function buildQuerySort(fieldName, asc) {

        return {
            fieldName: fieldName,
            asc: asc
        };
    }

    //
    // Build populate query param
    //
    function buildQueryPopulates(fieldName, childrenFieldNames) {

        return {
            fieldName: fieldName,
            childrenFieldNames: childrenFieldNames
        };
    }
});

//
// Procedure service
//

"use strict";

angular.module("mtApp").factory("ProcedureService", function ProcedureService($q, QMService, FavoriteDAO, ProcedureDAO) {

    return {

        //
        // Find all active procedures for the current user/hospital - used for
        // populating the select box from which user can choose favorite
        // procedures
        //
        findActiveProcedures: function(next) {

            next = next || angular.noop;

            var procedureDeferred = $q.defer();

            var qm = QMService.getInstance();

            // Build up sort order
            qm.addSort("code", true);
            qm.setPaginated(false);

            ProcedureDAO.findActiveProcedures(qm.asQuery(), function(listModel) {

                next();
                procedureDeferred.resolve(listModel.items);
            });

            return procedureDeferred.promise;
        },

        //
        // Find the favorite procedures for the current user. Used to list
        // the procedures selected by the current user on the favorites form.
        //
        findFavoriteProcedures: function(next) {

            next = next || angular.noop;

            // Build up filters for finding favorites
            var qm = QMService.getInstance();
            qm.addEqualsQueryFilter("entityType", "PROCEDURE");

            // Build up sort order for querying implants
            qm.addSort("code", true);

            qm.setPaginated(false);

            return FavoriteDAO.findFavoriteProcedures(qm.asQuery(), next).$promise;
        },

        //
        // Find procedures for the current user - either all active procedures
        // will be returned or if the user has activated favorites,
        // their favorite procedures will be returned. Called from case
        // initiation screen.
        //
        findUserProcedures: function(favoritesEnabled, next) {

            if ( favoritesEnabled ) {
                return this.findFavoriteProcedures(next);
            }

            return this.findActiveProcedures(next);
        },

        //
        // Generate display text for specified procedure - required for
        // typeahead menu
        //
        getProcedureDisplayText: function(procedure) {

            if ( !procedure ) {
                return "";
            }

            return procedure.code + " " + procedure.description;
        },

        //
        // Generate display text for selected specified procedure - required
        // for typeahead menu
        //
        getProcedureSelectedText: function(procedure, showCPTCategory) {

            if ( !procedure ) {
                return "";
            }

            var selectedText = [];

            // Add CPT category if specified
            if ( showCPTCategory ) {
                selectedText.push(procedure.category);
            }

            // Add CPT code
            selectedText.push(procedure.code);

            return selectedText.join("  ");
        }
    };
});

//
// Product source service
//

"use strict";

angular.module("mtApp").factory("ProductSourceService", function ProductSourceService(QMService, FavoriteDAO, ProductSourceDAO) {

    // CONSTANTS
    var PRODUCT_TYPE_ADDITIONAL_PRODUCTS = ["ANCILLARY", "MONITORING", "BONE_GRAFT"];

    return {

        //
        // Find all implants for the current user/hospital - used for
        // populating the select box from which user can choose favorite
        // implants (where implants are not filtered by CPT category and
        // no write ins are required)
        //
        findActiveImplantProductSources: function(hospitalId, includeWriteIns, next) {

            return findActiveImplantProductSources(hospitalId, null, includeWriteIns, next);
        },

        //
        // Find the favorite implants for the current user. Used to list
        // the implants selected by the current user on the favorites form.
        //
        findFavoriteImplants: function(hospitalId, next) {

            return findFavoriteImplants(hospitalId, null, false, next);
        },

        //
        // Find implants for the current user - either all implants
        // will be returned or if the user has activated favorites,
        // their favorite implants will be returned. Called from case
        // initiation screen (where implants are filtered by CPT category and
        // write ins are required).
        //
        findUserImplants: function(hospitalId, cptCategory, favoritesEnabled, next) {

            if ( favoritesEnabled ) {

                return findFavoriteImplants(hospitalId, cptCategory, true, next);
            }

            return findActiveImplantProductSources(hospitalId, cptCategory, true, next);
        },

        //
        // Find active additional products (ancillary, monitoring etc) for the current
        // user/hospital - used for populating the select box from which user can choose
        // favorite products.
        //
        // Ignores product sources that have been retired.
        //
        findActiveAdditionalProductSources: function(hospitalId, next) {

            findActiveAdditionalProducts(hospitalId, null, null, next); // TODO do this one next...
        },

        //
        // Find the favorite additional products for the current user. Used to list
        // the additional products selected by the current user on the favorites form.
        //
        findFavoriteAdditionalProducts: function(hospitalId, next) {

            findFavoriteAdditionalProducts(hospitalId, null, null, next);
        },

        //
        // Find ancillary products for the current user - either all ancillary
        // products will be returned or if the user has activated favorites,
        // their favorite ancillary products will be returned. Called from case
        // initiation screen.
        //
        findUserAncillaryProducts: function(hospitalId, cptCategory, favoritesEnabled, next) {

            if ( favoritesEnabled ) {
                return findFavoriteAdditionalProducts(hospitalId, cptCategory, "ANCILLARY", next);
            }

            return findActiveAdditionalProducts(hospitalId, cptCategory, "ANCILLARY", next);
        },

        //
        // Find monitoring products for the current user - either all monitoring
        // products will be returned or if the user has activated favorites,
        // their favorite ancillary products will be returned. Called from case
        // initiation screen.
        //
        findUserMonitoringProducts: function(hospitalId, cptCategory, favoritesEnabled, next) {

            if ( favoritesEnabled ) {
                return findFavoriteAdditionalProducts(hospitalId, cptCategory, "MONITORING", next);
            }

            return findActiveAdditionalProducts(hospitalId, cptCategory, "MONITORING", next);
        },

        //
        // Find bone graft products for the current user - either all bone graft
        // products will be returned or if the user has activated favorites,
        // their favorite ancillary products will be returned. Called from case
        // initiation screen.
        //
        findUserBoneGraftProducts: function(hospitalId, cptCategory, favoritesEnabled, next) {

            if ( favoritesEnabled ) {
                return findFavoriteAdditionalProducts(hospitalId, cptCategory, "BONE_GRAFT", next);
            }

            return findActiveAdditionalProducts(hospitalId, cptCategory, "BONE_GRAFT", next);
        },

        //
        // Generate display text for specified product - required for
        // typeahead menu when selecting favorites and on case initiation screen
        //
        getProductDisplayText: function(product) {

            if ( !product ) {
                return "";
            }

            var displayChunks = [];

            if ( product.manufacturer && product.productType === "IMPLANT" ) {
                displayChunks.push(product.manufacturer.name);
            }

            displayChunks.push(product.name);
            return displayChunks.join("  ");
        },

        //
        // Generate display text for specified product source - required for
        // typeahead menu when selecting favorites and on case initiation screen
        //
        getProductSourceDisplayText: function(product) {

            if ( !product ) {
                return "";
            }

            var displayChunks = [];

            if ( product.manufacturer && product.product.productType === "IMPLANT" ) {
                displayChunks.push(product.manufacturer.name);
            }

            displayChunks.push(product.product.name);

            if ( product.product.productType === "IMPLANT" ) {

                displayChunks.push(product.rep.firstName + " " + product.rep.lastName);
            }

            return displayChunks.join("  ");
        },

        // Sort products for display in typeheads. Sort order:
        // Manufacturer/Rep First Name/Rep Last Name/Product Name.
        //
        // Write ins displayed last in array.
        //
        sortProductsForSelection: function(products) {

            products.sort(function(product0, product1) {

                var value0 = getProductSortableValue(product0);
                var value1 = getProductSortableValue(product1);

                // Both products are write ins...
                if ( product0.writeIn && product1.writeIn ) {

                    return sort(value0, value1);
                }

                // First is write in, second is not
                if ( product0.writeIn && !product1.writeIn ) {
                    return 1;
                }

                // First is not write in, second is
                if ( !product0.writeIn && product1.writeIn ) {
                    return -1;
                }

                // Otherwise neither are write ins - as you were!
                return sort(value0, value1);

            });
        }
    };

    //
    // PRIVATES
    //

    //
    // Find all implants for the current user/hospital - only show product sources
    // that are active (ie have not been retired)
    //
    function findActiveImplantProductSources(hospitalId, cptCategory, includeWriteIns, next) {

        next = next || angular.noop;

        // Build up filter for querying implants
        var qm = QMService.getInstance();
        qm.addEqualsQueryFilter("product.productType", "IMPLANT");
        qm.addEqualsQueryFilter("hospital", hospitalId);

        if ( cptCategory ) {
            qm.addEqualsQueryFilter("product.cptCategory", cptCategory);
        }

        // Exclude write ins from favorite implants if specified (for example, we do not want
        // write ins on the favorites page)
        if ( !includeWriteIns ) {
            qm.addNotQueryFilter("writeIn", true);
        }

        // Build up sort order
        buildProductSorts(qm, true);

        // We want to list all implants - set paginated to false
        qm.setPaginated(false);

        return ProductSourceDAO.findActiveProductSources(qm.asQuery(), next).$promise;
    }

    //
    // Find the favorite implants for the current user. Used to list
    // the implants selected by the current user on the favorites form.
    //
    function findFavoriteImplants(hospitalId, cptCategory, includeWriteIns, next) {

        next = next || angular.noop;

        // Build up filter for querying implants
        var qm = QMService.getInstance();
        qm.addEqualsQueryFilter("entityType", "IMPLANT");
        qm.addEqualsQueryFilter("organization", hospitalId);

        if ( cptCategory ) {
            qm.addEqualsQueryFilter("cptCategory", cptCategory);
        }

        // Build up sort order for querying implants
        buildProductSorts(qm, true);

        // We want to list all implants - set paginated to false
        qm.setPaginated(false);

        var query = qm.asQuery();
        query.writeIns = includeWriteIns;

        return FavoriteDAO.findFavoriteProducts(query, next).$promise;
    }

    //
    // Find all additional products for the current user/hospital - only
    // find active products sources (ie have not yet been retired)
    //
    function findActiveAdditionalProducts(hospitalId, cptCategory, productType, next) {

        next = next || angular.noop;

        // Build up filter for querying implants
        var qm = QMService.getInstance();
        qm.addEqualsQueryFilter("hospital", hospitalId);

        if ( cptCategory ) {
            qm.addEqualsQueryFilter("product.cptCategory", cptCategory);
        }

        // Search for all products with the specified product type (eg ANCILLARY)
        if ( productType ) {
            qm.addEqualsQueryFilter("product.productType", productType);
        }
        // Product type wasn't specified, search across all product types
        else {
            qm.addInQueryFilter("product.productType", PRODUCT_TYPE_ADDITIONAL_PRODUCTS);
        }

        // Build up sort order
        qm.addSort("manufacturer.name", true);
        qm.addSort("product.name", true);

        // We want to list all - set pagination to false
        qm.setPaginated(false);

        return ProductSourceDAO.findActiveProductSources(qm.asQuery(), next).$promise;
    }

    //
    // Find the favorite implants for the current user. Used to list
    // the implants selected by the current user on the favorites form.
    //
    function findFavoriteAdditionalProducts(hospitalId, cptCategory, productType, next) {

        next = next || angular.noop;

        // Build up filter for querying products
        var qm = QMService.getInstance();
        qm.addEqualsQueryFilter("organization", hospitalId);

        if ( cptCategory ) {
            qm.addEqualsQueryFilter("cptCategory", cptCategory);
        }

        // Search for favorites of the specified product type (eg ANCILLARY)
        if ( productType ) {
            qm.addEqualsQueryFilter("entityType", productType);
        }
        // Product type wasn't specified, search across all product types
        else {
            qm.addInQueryFilter("entityType", PRODUCT_TYPE_ADDITIONAL_PRODUCTS);
        }

        // Build up sort order
        qm.addSort("manufacturer.name", true);
        qm.addSort("product.name", true);

        // We want to list all - set pagination to false
        qm.setPaginated(false);

        return FavoriteDAO.findFavoriteProducts(qm.asQuery(), next).$promise;
    }

    //
    // Build up the sort order for products
    //
    function buildProductSorts(qm, implant) {

        var sorts = [];
        qm.addSort("manufacturer.name", true);

        if ( implant ) {
            qm.addSort("rep.firstName", true);
            qm.addSort("rep.lastName", true);
        }

        qm.addSort("product.name", true);

        return sorts;
    }

    //
    // Return the sortable value for the specified product
    //
    function getProductSortableValue(product) {

        var value = [];
        value.push(product.product.name);
        value.push(product.manufacturer.name);
        value.push(product.rep.firstName + " " + product.rep.lastName);

        return value.join("  ");
    }

    //
    // Determine sort order according to specified values
    //
    function sort(value0, value1) {

        // Values are identical - no change
        if ( value0 === value1 ) {
            return 0;
        }

        // Both values are alpha - do straight up comparison
        if ( value0 < value1 ) {
            return -1;
        }

        return 1;
    }
});

//
// Tray service
//

"use strict";

angular.module("mtApp").factory("TrayService", function TrayService(QMService, TrayDAO) {

    return {

        //
        // Find trays by the specified product ID
        //
        findTraysByProductId: function(productId, next) {

            next = next || angular.noop;

            // Build up filter for querying trays
            var qm = QMService.getInstance();
            qm.addEqualsQueryFilter("product", productId);

            // Build up sort order
            qm.addSort("name", true);

            // Set pagination to false
            qm.setPaginated(false);

            return TrayDAO.findActiveTrays(qm.asQuery(), next).$promise;
        },

        //
        // Match up list of possible trays with the selected trays on the specified implant -
        // called when displaying the tray confirmation popup or the tray print page
        //
        updateTrayConfirmationDetailsFromImplant: function(implant, trays) {

            // Setup map of tray ID to tray
            var traysById = {};
            for ( var i = 0 ; i < trays.length ; i++ ) {

                var tray = trays[i];
                traysById[tray._id] = tray;
            }

            // Add any "retired" trays that have been confirmed (and denormalized) on the case, but
            // not returned in the "active tray" array for this implant. Be sure to ignore write ins
            // when checking for retired trays (as write ins will also not be listed in the list of
            // active trays)
            if ( implant.confirmedTrayDetails ) {

                var confirmedTrays = implant.confirmedTrayDetails.trays;

                // Add any missing trays to the map
                _.each(confirmedTrays, function(tray) {

                    if ( tray.writeIn ) {
                        return;
                    }

                    var trayId = tray._id;
                    if ( !traysById[trayId] ) {

                        traysById[trayId] = tray;
                        trays.push(tray);
                    }
                });
            }

            // Match up implant trays and previously selected tray confirmation
            // values. Ignore tray if it was previously selected tray is a write in,
            // we'll just add it to the list of trays (no match up is required as it
            // wont be listed in the "core" list of trays for this implant)
            var writeIns = [];
            var confirmedTrayDetails = implant.confirmedTrayDetails;
            for ( i = 0 ; i < confirmedTrayDetails.trays.length ; i++ ) {

                var confirmedTray = confirmedTrayDetails.trays[i];

                // If tray was a write in, add it to the write in array (we'll
                // add them to the beginning of the array as a group)
                if ( confirmedTray.writeIn ) {
                    writeIns.push(confirmedTray);
                    continue;
                }

                // Otherwise, find the tray corresponding to the
                // previously confirmed tray
                var displayTray = traysById[confirmedTray._id];
                if ( !displayTray ) {
                    continue;
                }

                // Update tray (to be displayed in the details form) with the
                // saved detail
                displayTray.included = true;
                displayTray.confirmed = confirmedTray.confirmed;
                displayTray.source = confirmedTray.source;
            }

            // OK, now add write ins to beginning of trays
            for ( i = writeIns.length - 1 ; i >= 0 ; i-- ) {

                var writeIn = writeIns[i];
                writeIn.included = true;
                trays.unshift(writeIn);
            }
        }

    };
});

//
// User Session
// - Singleton, holds basic info of currently logged in user
//

'use strict';

angular.module("mtApp").service("UserSession", function () {

    this.user = {};

    //
    // Create user session
    //
    this.create = function (user) {

        angular.copy({
            _id: user._id,
            firstName: user.firstName,
            lastName: user.lastName,
            email: user.email,
            role: user.role,
            organizations: user.organizations,
            visibilityRights: user.visibilityRights || []
        }, this.user);
    };

    //
    // Destroy user session
    //
    this.destroy = function () {

        delete this.user._id;
        delete this.user.name;
        delete this.user.email;
        delete this.user.role;
        delete this.user.organizations;
        delete this.user.visibilityRights;
    };

    return this;
});
//
// User Service
// - Service for user-related CRUD, activate, deactivate, password etc related functionality
//

"use strict";

angular.module("mtApp").factory("UserService", function ($http, UserSession, PersonDAO) {

    return {

        //
        // Request password reset
        //
        requestResetPassword: function(email) {

            return PersonDAO.requestResetPassword({
                email:email
            }, function() {
                return true;
            }, function() {
                return false;
            }).$promise;
        },

        //
        // Reset user's password
        //
        resetPassword: function(forgotKey, password, passwordConfirm) {

            return PersonDAO.resetPassword({
                forgotKey: forgotKey,
                password: password,
                passwordConfirm: passwordConfirm
            }, function() {
                return true;
            }, function() {
                return false;
            }).$promise;
        }
    };

});

//
// This is a utility service 
// We can put any utility method here to be reused by other service or controller
// Example: buildQuery and buildQuerySort
// Not currently in-use

'use strict';

angular.module('mtApp').factory('UtilityService', function UtilityService() {

    return {
        // build query filter
        buildQueryFilter: buildQueryFilter,

        // build query sorter
        buildQuerySort: buildQuerySort,

        // build populate query
        buildQueryPopulates: buildQueryPopulates
    };

    //
    // PRIVATES
    //

    //
    // Build query filter query param
    // TODO(dave) repeated in other services
    //
    function buildQueryFilter(filterType, fieldName, value) {

        return {
            filterType: filterType,
            fieldName: fieldName,
            value: value
        };
    }

    //
    // Build sort order query param
    // TODO(dave) repeated in other services
    //
    function buildQuerySort(fieldName, asc) {

        return {
            fieldName: fieldName,
            asc: asc
        };
    }

    //
    // Build populate query param
    //
    function buildQueryPopulates(fieldName, childrenFieldNames) {

        return {
            fieldName: fieldName,
            childrenFieldNames: childrenFieldNames
        };
    }

});
/**
 * Service for date-time manipulation
 */

(function() {
    "use strict";

    var DateTimeService = function () {

        return {

            /**
             * Human readable 'last seen'
             *
             * @param {string|Date} lastActivity
             * @returns {string}
             */
            formatLastSeen: function(lastActivity) {

                if ( !lastActivity ) {
                    return "No activity";
                }

                var activityTime = new Date(lastActivity);
                activityTime = Math.floor(activityTime / 1000);
                var now = Math.floor(Date.now() / 1000);
                var tSince = now - activityTime;
                var lastSeen;

                if ( tSince < 60 ) {

                    lastSeen = "Just now";
                }
                else if ( tSince < 3600 ) {

                    var minutesAgo = Math.floor(tSince / 60);
                    lastSeen = (minutesAgo === 1) ? minutesAgo + " minute ago" : minutesAgo + " minutes ago";
                }
                else if ( tSince < 86400 ) {

                    var hoursAgo = Math.floor(tSince / 3600);
                    lastSeen = (hoursAgo === 1) ? hoursAgo + " hour ago" : hoursAgo + " hours ago";
                }
                else if ( tSince < 172800) {

                    lastSeen = "Yesterday";
                }
                else {

                    var daysAgo = Math.floor(tSince / 86400);
                    lastSeen = daysAgo + " days ago";
                }

                return lastSeen;
            }
        };
    };

    // Expos
    angular.module("mtApp").factory("DateTimeService", DateTimeService);
})();

"use strict";

angular.module("mtApp").factory("CommentService",  function (CommentDAO) {

	var CommentService = {};

    //
    //
    //
	CommentService.getCommentCaseById = function (id, next) {

		return CommentDAO.getCommentCaseById({id: id}, next).$promise;
	};

    //
    //
    //
	CommentService.createComment = function (id, data, next){

        CommentDAO.createComment({id: id}, data, next);
	};

	return CommentService;
});

//
// Query Model - contains filter, sort, offset, limit etc
// Singleton service returning new QueryBuilder object
//

"use strict";

angular.module("mtApp").factory("QMService", function(PAGINATION) {

    // Constants...
    var FILTER_TYPES = {
        EQUALS: "EQUALS",
        GT: "GT",
        IN: "IN",
        NOT: "NOT",
        OR: "OR"
    };

    // Function constructor for query builder object
    var QueryModel = function (entityKey) {

        this.paginated = true;
        this.paginationEntityKey = entityKey || "";

        this.queryParams = {};

        this.offset = null;
        this.limit = null;

        this.filters = [];

        this.sortable = true;
        this.sorts = [];

        this.populates = [];
    };

    //
    // Return all query values (filters, sorts, offset, limit etc) - used
    // when generating query object literals for $resource calls
    //
    QueryModel.prototype.asQuery = function() {

        var query = _.extend({
            filters: this.getFilters(),
            populates: this.getPopulates()
        }, this.queryParams);

        if ( this.sortable ) {
            query.sorts = this.getSorts();
        }

        if ( this.paginated ) {
            query.offset = this.getOffset();
            query.limit = this.getLimit();
        }

        return query;
    };

    //
    // Adding filters...
    //

    //
    // Add EQUALS query filter query param to the array of filters
    //
    QueryModel.prototype.addEqualsQueryFilter = function(fieldName, value) {

        var filter = this.buildEqualsQueryFilter(fieldName, value);
        this.getFilters().push(filter);
    };

    //
    // Add GT query filter query param to the array of filters
    //
    QueryModel.prototype.addGreaterThanQueryFilter = function(fieldName, value) {

        var filter = this.buildGreaterThanQueryFilter(fieldName, value);
        this.getFilters().push(filter);
    };

    //
    // Add IN query filter query param to the array of filters
    //
    QueryModel.prototype.addInQueryFilter = function(fieldName, value) {

        var filter = this.buildInQueryFilter(fieldName, value);
        this.getFilters().push(filter);
    };

    //
    // Add NOT query filter query param to the array of filters
    //
    QueryModel.prototype.addNotQueryFilter = function(fieldName, value) {

        var filter = this.buildNotQueryFilter(fieldName, value);
        this.getFilters().push(filter);
    };

    //
    // Add OR query filter query param to the array of filters
    //
    QueryModel.prototype.addOrQueryFilter = function(conditions) {

        this.getFilters().push({
            filterType: FILTER_TYPES.OR,
            conditions: conditions
        });
    };

    //
    // Building filters...
    //

    //
    // Add public method for building EQUALS filter
    //
    QueryModel.prototype.buildEqualsQueryFilter = function(fieldName, value) {

        return buildQueryFilter.call(this, FILTER_TYPES.EQUALS, fieldName, value);
    };

    //
    // Add public method for building GT filter
    //
    QueryModel.prototype.buildGreaterThanQueryFilter = function(fieldName, value) {

        return buildQueryFilter.call(this, FILTER_TYPES.GT, fieldName, value);
    };

    //
    // Add public method for building IN filter
    //
    QueryModel.prototype.buildInQueryFilter = function(fieldName, value) {

        return buildQueryFilter.call(this, FILTER_TYPES.IN, fieldName, value);
    };

    //
    // Add public method for building NOT filter
    //
    QueryModel.prototype.buildNotQueryFilter = function(fieldName, value) {

        return buildQueryFilter.call(this, FILTER_TYPES.NOT, fieldName, value);
    };

    //
    // Build populate query param
    //
    QueryModel.prototype.addPopulates = function(fieldName, childrenFieldNames) {

        this.populates.push({
            fieldName: fieldName,
            childrenFieldNames: childrenFieldNames
        });
    };

    //
    // Add query string parameter
    //
    QueryModel.prototype.addQueryParam = function (name, value) {

        this.queryParams[name] = value;
    };

    //
    // Add sort order
    //
    QueryModel.prototype.addSort = function (fieldName, asc) {

        this.sorts.push({
            fieldName: fieldName,
            asc: asc
        });
    };

    //
    // Return filters, return empty array if no filters
    // specified
    //
    QueryModel.prototype.getFilters = function() {

        return this.filters;
    };

    //
    // Get limit - if no limit, return default limit
    //
    QueryModel.prototype.getLimit = function () {

        // Return limit if it has been specified
        if ( this.limit ) {
            return this.limit;
        }

        // No limit has been specified. Check if an entity key has been
        // specified and if so, return the limit for this entity type
        if ( this.paginationEntityKey ) {
            return PAGINATION[this.paginationEntityKey].limit;
        }

        // Otherwise, just return the default limit
        return PAGINATION.limit;
    };

    //
    // Get offset - if no offset, return default offset
    //
    QueryModel.prototype.getOffset = function () {

        // Return offset if it has been specified
        if ( this.offset || this.offset === 0 ) {
            return this.offset;
        }

        // No offset has been specified. Check if an entity key has been
        // specified and if so, return the offset for this entity type
        if ( this.paginationEntityKey ) {
            return PAGINATION[this.paginationEntityKey].offset;
        }

        // Otherwise, just return the default offset
        return PAGINATION.offset;
    };

    //
    // Return all populates, return empty array if no populates specified
    //
    QueryModel.prototype.getPopulates = function() {

        return this.populates;
    };

    //
    // Return all sort orders, return empty array if no sort
    // orders specified
    //
    QueryModel.prototype.getSorts = function() {

        return this.sorts;
    };

    //
    // Set limit
    //
    QueryModel.prototype.setLimit = function (limit) {
        this.limit = limit;
    };

    //
    // Set offset
    //
    QueryModel.prototype.setOffset = function (offset) {
        this.offset = offset;
    };

    //
    // Set pagination to true/false
    //
    QueryModel.prototype.setPaginated = function(paginated) {

        this.paginated = paginated;
    };

    //
    // Returns true if result set is to be paginated
    //
    QueryModel.prototype.isPaginated = function() {

        return this.paginated;
    };

    //
    // Set sortable to true/false
    //
    QueryModel.prototype.setSortable = function(sortable) {

        this.sortable = sortable;
    };

    //
    // Returns true if result set is to sortable
    //
    QueryModel.prototype.isSortable = function() {

        return this.sortable;
    };

    //
    // PRIVATES
    //

    //
    // Build query filter query param
    //
    function buildQueryFilter(filterType, fieldName, value) {

        return {
            filterType: filterType,
            fieldName: fieldName,
            value: value
        };
    }

    //
    // FACTORY
    //

    //
    // Return new instance of QueryModel
    //
    return {
        getInstance: function (entityKey) {
            return new QueryModel(entityKey);
        }
    };
});

//
// Session Service
// - Resource for session-related functionality
//

'use strict';

angular.module('mtApp').factory('SessionDAO', function ($resource) {

    return $resource('/api/session/');
});

//
// User Service
// - Service
//

"use strict";

angular.module("mtApp").factory("PersonDAO", function ($resource) {
    return $resource("/api/people/:id", {
        id: "@id"
    }, {
        get: {
            method: "GET",
            params: {
                id:"me"
            }
        },
        findAllPeople: {
            method: "GET",
            url: "/api/user/people",
            isArray: true
        },
        findOrganizationByUserId: {
            method: "GET",
            url: "/api/people/:id/organization"
        },
        findPersonProfile: {
            method: "GET",
            url: "/api/people/:id/profile"
        },
        isFavoritesEnabled: {
            method: "GET",
            url: "/api/user/favorites"
        },
        requestResetPassword: {
            method: "POST",
            url: "/api/people/password/request-reset"
        },
        resetPassword: {
            method: "POST",
            url: "/api/people/password/reset"
        },
        updateUserEmailAlertsPreference: {
            method: "POST",
            url: "/api/email-alerts/preference"
        },
        updateUserFavoritesPreference: {
            method: "POST",
            url: "/api/favorites/preference"
        }
    });
});

//
// Cases Service
// - Service for case-related CRUD actions
//

"use strict";

angular.module("mtApp").factory("CaseDAO", function ($resource) {

    return $resource("/api/cases/:id", {
        id: "@id"
    }, {
        calculateBmiMetrics: {
            method: "GET",
            url: "/api/cases/bmi-metrics"
        },
        cancel: {
            method: "PUT",
            url: "/api/cases/:id/cancel"
        },
        close: {
            method: "PUT",
            url: "/api/cases/:id/close"
        },
        updateCase: {
            method: "PUT",
            url: "/api/cases/:id"
        },
        confirmCaseGeneral: {
            method: "PUT",
            url: "/api/cases/:id/confirm-case-general"
        },
        confirmImplantDelivery: {
            method: "PUT",
            url: "/api/cases/:id/confirm-implant-delivery"
        },
        confirmSterilizationDate: {
            method: "PUT",
            url: "/api/cases/:id/confirm-sterilization-date"
        },
        confirmTrayDetails: {
            method: "PUT",
            url: "/api/cases/:id/confirm-tray-details"
        },
        countRepUnconfirmedCases: {
            method: "GET",
            url: "/api/user/cases/count-unconfirmed-cases"
        },
        editCase: {
            method: "GET",
            url: "/api/cases/:id/edit"
        },
        findCasesByFavoriteSurgeons: {
            method: "GET",
            url: "/api/user/cases/favorite",
            isArray: true
        },
        findCasesByUserOrganizationSurgeons: {
            method: "GET",
            url: "/api/user/cases/organization",
            isArray: true
        },
        countCases: {
            method: "GET",
            url: "/api/user/cases/count"
        },
        countCasesByFavoriteSurgeons: {
            method : "GET",
            url: "/api/user/cases/favorite/count",
            isArray: false
        },
        countCasesByUserOrganizationSurgeons: {
            method: "GET",
            url: "/api/user/cases/organization/count"
        },
        showCase: {
            method: "GET",
            url: "/api/cases/:id/show"
        }
    });
});

//
// Cases Service
// - Service for case-related CRUD actions
//

'use strict';

angular.module('mtApp').factory("FavoriteDAO", function ($resource) {

    return $resource("/api/favorites/:id", {
        id: "@id"
    }, {
        findFavoriteProcedures: {
            method: "GET",
            url: "/api/favorites/procedures",
            isArray: true
        },
        findFavoriteProducts: {
            method: "GET",
            url: "/api/favorites/products",
            isArray: true
        },
        findFavoriteOrganizations: {
            method: "GET",
            url: "/api/favorites/organizations",
            isArray: true
        },
        findFavoritePeople: {
            method: "GET",
            url: "/api/favorites/people",
            isArray: true
        },
        updateUserFavoritesPreference: {
            method: "POST",
            url: "/api/favorites/preference"
        }
    });
});

//
// Organization DAO
// - Resource for org-related queries
//

'use strict';

angular.module('mtApp').factory("OrganizationDAO", function ($resource) {

    return $resource("/api/admin/organizations/:id", {
        id: "@id"
    }, {
        update: {
            method: "PUT"
        },
        countAllOrganizations: {
            method: "GET",
            url: "/api/admin/count/organizations",
            isArray: false
        },
        createHospitalGroup: {
            method: 'POST',
            url: '/api/admin/organization/hospitals',
            isArray: true
        },
        createPractice: {
            method: 'POST',
            url: '/api/admin/practices',
            isArray: false
        },
        editPractice: {
            method: 'GET',
            url: '/api/admin/practices/:id/edit',
            isArray: false
        },
        findAdminOrganizations: {
            method: "GET",
            url: "/api/admin/organizations",
            isArray: true
        },
        findAllOrganizations: {
            method: "GET",
            url: "/api/user/organizations",
            isArray: true
        },
        findHospitalsNotInGroup: {
            method: 'GET',
            url: '/api/admin/organization/hospitals',
            isArray: true
        },
        findOrganizationsAffiliatedTo: {
            method: "GET",
            url: "/api/admin/organizations/:id/affiliatedTo",
            isArray: true
        },
        findOrganizationById : {
            method: 'GET',
            url: '/api/user/organizations/:id',
            isArray: false
        },
        updateHospitalGroup: {
            method: 'PUT',
            url: '/api/admin/organization/hospitals/:id',
            isArray: false
        },
        updateOrganization: {
            method: "PUT",
            url: "/api/organizations/:id"
        },
        updatePractice: {
            method: 'PUT',
            url: '/api/admin/practices/:id',
            isArray: false
        }
    });
});

//
// Procedures DAO
//

"use strict";

angular.module("mtApp").factory("ProcedureDAO", function ($resource) {

    return $resource("/api/procedures/:id", {
        id: "@id"
    }, {
        findActiveProcedures: {
            method: "GET",
            url: "/api/user/procedures/active",
            isArray: false
        }
    });
});

//
// Lateralities service
//

angular.module('mtApp').factory("LocationDAO", function ($resource) {

    return $resource('/api/locations');
});
//
// Comment Service
// -
//

"use strict";

angular.module("mtApp").factory("CommentDAO", ["$resource", function ($resource) {
	return $resource("/api/cases/:id",
			{
                id:"@id"
            },
			{
				getCommentCaseById : {
					method: "GET",
					url: "/api/cases/:id/comments",
					isArray: true
				},
				createComment : {
					method: "POST",
					url: "/api/cases/:id/comments/new",
					isArray: false
				}
			}
		);
}]);

//
// Area DAO
//
"use strict";

angular.module("mtApp").factory("AreaDAO", function ($resource) {

    return $resource("/api/areas/:id", {
    }, {
        findAreaValuesByName: {
            method: "GET",
            url: "/api/areas/name",
            isArray: true
        },
        findAreaByUri: {
            method: "GET",
            url: "/api/areas/uri",
            isArray: true
        }
    });
});

//
// Product source DAO
//

"use strict";

angular.module("mtApp").factory("ProductSourceDAO", function ($resource) {

    return $resource("/api/productsources/:id", {
        id: "@id"
    }, {
        findActiveProductSources: {
            method: "GET",
            url: "/api/user/productsources/active",
            isArray: true
        }
    });
});

//
// Tray DAO
//

"use strict";

angular.module("mtApp").factory("TrayDAO", function ($resource) {

    return $resource("/api/user/trays/:id", {
        id: "@id"
    }, {
        findActiveTrays: {
            method: "GET",
            url: "/api/user/trays/active",
            isArray: true
        }
    });
});

//
// Constants for authentication-related events
//

angular.module("mtApp").constant("AUTH_EVENTS", {
    loginSuccess: 'auth-login-success',
    loginFailed: 'auth-login-failed',
    logoutSuccess: 'auth-logout-success',
    sessionTimeout: 'auth-session-timeout',
    notAuthenticated: 'auth-not-authenticated',
    notAuthorized: 'auth-not-authorized'
});
//
// Constants for user roles
//

angular.module("mtApp").constant("USER_ROLES", {
    admin: "ADMIN",
    user: "USER",
    rep: "REP",
    surgeon: "SURGEON",
    visitor: "VISITOR"
});
(function(){
	"use strict";

	var PAGINATION = {
		offset: 0,
		limit: 10,
        INACTIVE_CASE: {
            offset: 0,
            limit: 50
        },
        ACTIVE_CASE: {
            offset: 0,
            limit: 10
        },
        ADMIN: {
        	limit: 100
        }
	};

	angular.module("mtApp").constant("PAGINATION", PAGINATION);
})();

//
// Constants for user roles
//

angular.module("mtApp").constant("CPT_CATEGORIES", {
    neurosurgery: "NEUROSURGERY",
    orthopedic: "ORTHOPEDIC",
    spine: "SPINE",
    sportsMedicine: "SPORTS MEDICINE",
    cardiothoracic: "CARDIOTHORACIC"
});
//
// CPT Categories
//

(function(){

    "use strict";

	var CPT_CATEGORIES_ADMIN = [
		"ORTHOPEDIC",
		"NEUROSURGERY",
		"SPINE",
		"CARDIOTHORACIC"
	];

	angular.module("mtApp").constant("CPT_CATEGORIES_ADMIN", CPT_CATEGORIES_ADMIN);

})();

//
//
//

"use strict";

angular.module("mtApp").constant("ROUTES", {
    ERROR_400: "badRequest",
    ERROR_401: "notAuthenticated",
    ERROR_403: "notAuthorized",
    ERROR_404: "notFound",
    ERROR_422CODE: "error422WithMinorCode",
    ERROR_422: "error422",
    ERROR_500: "error500",
    LOGIN_ACTIVATE: "loginActivate",
    LOGIN_RESET: "loginReset",
    LOGIN : "login",
    LOGOUT: "logout",
    REQ_PASSSWORD_RESET: "requestPasswordReset",
    PASSWORD_RESET_SUCCESS: "requestPasswordResetSuccess",
    RESET_PASSWORD: "resetPassword",
    DISCLAIMER: "disclaimer",
    HOME: "home",
    CASES: "cases",
    CASES_ACTIVE: "cases.active",
    CASES_ACTIVE_SHOW: "cases.active.caseShow",
    CASES_FILTER: "cases.filter",
    CASES_MEDTEL_ID: "cases.medtelId",
    CASES_ARCHIVED: "cases.archived",
    CASE_NEW: "cases.new",
    CASE_SHOW: "caseShow",
    CASE_ACTIVITY: "caseShow.activity",
    CASE_EDIT: "caseEdit",
    CASE_CONFIRM: "caseConfirm",
    PRINT_TRAYS: "printTrays",
    PROFILE: "profile",
    PROFILE_INFO: "profile.info",
    PROFILE_EMAILS: "profile.emails",
    PROFILE_FAVORITES: "profile.favorites",
    PROFILE_FAVORITES_HOSPITAL: "profile.favorites.hospital",
    ADMIN: "admin",
    ADMIN_PROCEDURES: "admin.procedures",
    ADMIN_PROCEDURES_CREATE: "admin.procedureCreate",
    ADMIN_PROCEDURES_EDIT: "admin.procedureEdit",
    ADMIN_PRODUCT_INDEX: "admin.products",
    ADMIN_PRODUCT_CREATE: "admin.productCreate",
    ADMIN_PRODUCT_EDIT: "admin.productEdit",
    ADMIN_PRODUCT_SHOW: "admin.productShow",
    ADMIN_MANUFACTURER: "admin.manufacturers",
    ADMIN_MANUFACTURER_CREATE: "admin.manufacturersCreate",
    ADMIN_MANUFACTURER_EDIT: "admin.manufacturersEdit",
    ADMIN_HOSPITAL_GROUP_CREATE: "admin.hospitalGroupCreate",
    ADMIN_HOSPITAL_GROUP_EDIT: "admin.hospitalGroupEdit",
    ADMIN_HOSPITAL_GROUP_INDEX: "admin.hospitalGroups",
    ADMIN_REP_GROUPS: "admin.repGroups",
    ADMIN_REP_GROUP_SHOW: "admin.repGroupShow",
    ADMIN_HOSPITAL_INDEX: "admin.hospitals",
    ADMIN_HOSPITAL_CREATE: "admin.hospitalCreate",
    ADMIN_HOSPITAL_EDIT: "admin.hospitalEdit",
    ADMIN_PRACTICES: "admin.practices",
    ADMIN_PRACTICES_CREATE: "admin.practicesCreate",
    ADMIN_PRACTICES_EDIT: "admin.practicesEdit",
    ADMIN_SCHEDULERS: "admin.schedulers",
    ADMIN_SCHEDULERS_EDIT: "admin.schedulersNew",
    ADMIN_SCHEDULERS_CREATE: "admin.schedulercreate",
    ADMIN_PRACTICE_SCHEDULERS: "admin.practiceSchedulers",
    ADMIN_PRACTICE_SCHEDULERS_CREATE: "admin.practiceSchedulersCreate",
    ADMIN_PRACTICE_SCHEDULERS_EDIT: "admin.practiceSchedulersEdit",
    ADMIN_SURGEONS: "admin.surgeons",
    ADMIN_SURGEONS_CREATE: "admin.surgeonsCreate",
    ADMIN_SURGEONS_EDIT: "admin.surgeonsEdit",
    ADMIN_REPORTS: "admin.reports",
    ADMIN_REPS: "admin.reps",
    ADMIN_REPS_CREATE: "admin.repsCreate",
    ADMIN_REPS_EDIT: "admin.repsEdit",
    ADMIN_ZAPS: "admin.zaps"
});

//
// Store timezone values
//


'use strict';

angular.module('mtApp').constant('TIMEZONE', 
	{ zones: [
		{ name: 'Hawaii', value: 'Pacific/Honolulu'},
		{ name: 'Alaska', value: 'America/Anchorage'},
		{ name: 'Pacific Time (US & Canada)', value: 'America/Los_Angeles'},
		{ name: 'Arizona', value: 'America/Phoenix'},
		{ name: 'Mountain Time (US & Canada)', value: 'America/Denver'},
		{ name: 'Central Time (US & Canada)', value: 'America/Chicago'},
		{ name: 'Eastern Time (US & Canada)', value: 'America/New_York'}
		// { name: 'Indiana', value: 'NONE/Indiana'}
		]
	}
);
'use strict';

angular.module('mtApp')

  /**
   * Removes server error when user updates input
   */
  .directive('mongooseError', function () {
    return {
      restrict: 'A',
      require: 'ngModel',
      link: function(scope, element, attrs, ngModel) {
        element.on('keydown', function() {
          return ngModel.$setValidity('mongoose', true);
        });
      }
    };
  });
//
// Count down number of chars remaining
//

angular.module("mtApp").directive("ccCountDown", function() {

    return {

        restrict: "A",
        scope: {
            text: "=",
            totalChars: "@"
        },
        link: function(scope) {

            // Parse total chars as integer for calculations
            scope.totalChars = parseInt(scope.totalChars, 10);

            // Calculate chars remaining
            scope.charsRemaining = scope.totalChars;

            // Add watch on "text" in case someone does a sneaky update
            // of the input
            scope.$watch("text", function(newValue) {

                scope.charsRemaining = calculateCharsRemaining(scope.totalChars, newValue || "");
            });

        },
        template: "{{charsRemaining}}"
    };

    //
    // PRIVATES
    //

    //
    // Calculate the number of characters remaining
    //
    function calculateCharsRemaining(totalChars, text) {

        return totalChars - text.length;
    }
});
//
// CC clip - copy and paste functionality
//

angular.module("mtApp").directive("ccClip", function($window, $timeout) {

    return {

        restrict: "A",
        scope: {
            callback: "&"
        },
        link: function(scope, element, attrs) {

            // Set up copy functionality
            var clip = new ZeroClipboard(element[0], {
                moviePath: "/scripts/vendor/ZeroClipboard.swf",
                trustedDomains: ["*"],
                allowScriptAccess: "always"
            });

            // Listen for changes in scroll position - will need
            // to update position of Flash object that is backing
            // the button
            var timer;
            element.parent().parent().parent().bind("scroll", function() {
                $timeout.cancel(timer);
                timer = $timeout(function() {
                    reposition(clip);
                }, 100);
            });

            // Listen for changes in window size - will need
            // to update position of Flash object that is backing
            // the button
            angular.element($window).bind("resize", function() {
                $timeout.cancel(timer);
                timer = $timeout(function() {
                    reposition(clip);
                }, 100);
            });

            // Execute callback once copy is complete
            clip.on("complete", function() {

                if ( attrs.callback ) {
                    scope.$apply(scope.callback);
                }
            });
        }
    };

    //
    // PRIVATES
    //

    //
    // Reposition Flash object - required for when user has
    // resized the window or scrolled
    //
    function reposition(clip) {
        clip.reposition();
    };
});
//
// Date picker
//

angular.module("mtApp").directive("ccDatePicker", function() {

    return {

        restrict: "A",
        require: "?ngModel",
        scope: {

        },
        link: function(scope, element, attrs, ngModel) {

            // Must have ngModel to continue
            if ( !ngModel ) {
                return;
            }

            // Setup date picker options
            var options = {
                field: element[0],
                format: 'MM/DD/YYYY',
                minDate: new Date()
            };

            // Setup date picker
            var pikaday = new Pikaday(options);

            // Clean up!
            scope.$on("$destroy", function(){
                pikaday.destroy();
            });
        }
    };
});

//
// Handle toggle of drop down menu
//

angular.module("mtApp").directive("ccDropDown", function($document, CCEventUtils) {

    return {
        restrict: "A",
        link: function(scope, element) {

            // Find the drop down to display - should be sibling
            // to the clicked element
            var dropdown = element.parent().find("ul");

            // Define the close function
            var closeFn = function() {
                dropdown.removeClass("show");
            };

            var body = $document[0].body;
            element.on("click", function(event) {

                // Check if drop down is open and if so, allow event to
                // propagate...
                if ( dropdown.hasClass("show") ) {

                    // Close drop down and allow event to propagate
                    closeFn();

                    // Remove click listener on body
                    CCEventUtils.removeEventListener(body, "click", closeFn);
                }
                else {

                    CCEventUtils.captureEvent(event);

                    // Match width of menu to with of element
                    var width = element[0].offsetWidth;
                    dropdown.css("width", width + "px");

                    // Toggle drop down visibility
                    dropdown.toggleClass("show");

                    // Add click to body to close menu
                    CCEventUtils.addEventListener(body, "click", closeFn);
                }
            });

            // Clean up!
            scope.$on("$destroy", function() {

                element.off("click");
                CCEventUtils.removeEventListener(body, "click", closeFn);
            });

        }
    };
});

//
// Utils for event-related functionality
//

"use strict";

angular.module("mtApp").factory("CCEventUtils", function() {

    return {

        //
        // Attach event (cross browser)
        //
        addEventListener: function(el, eventName, callback) {

            if ( el.attachEvent ) {
                el.attachEvent("on" + eventName, callback);
            }
            else {
                el.addEventListener(eventName, callback, false);
            }
        },

        //
        // Cross-browser (down to IE9) capture of event
        //
        captureEvent: function(event) {

            if ( event.stopPropagation ) {
                event.stopPropagation();
            }
            else {
                event.cancelBubble();
            }

            event.preventDefault();
        },

        //
        // Remove event (cross browser)
        //
        removeEventListener: function(el, eventName, callback) {

            if ( el.detachEvent ) {
                el.detachEvent("on" + eventName, callback);
            }
            else {
                el.removeEventListener(eventName, callback, false);
            }
        }
    };
});

//
// Set focus on element, on load of element
//

angular.module("mtApp").directive("ccFocus", function($timeout) {

    return {
        restrict: "A",
        link: function(scope, element) {

            $timeout(function() {
                element[0].focus();
            }, 10);
        }
    };

});
//
// Select first and only value if set of all possible values is of size one
//

angular.module("mtApp").directive("ccSelectIfSingleton", function($filter) {

    return {

        restrict: "A",
        scope: {
        },
        link: function(scope, element, attrs) {

            //http://blog.benkuhl.com/2013/08/how-to-use-ng-options-in-a-custom-directive-for-a-dropdown/
        }
    };

    //
    // Privates
    //

});
//
// Trigger "dirty" bit in forms where fields are autofilled
// by browser
//

angular.module("mtApp").directive({
    ccSubmit:[
        "$parse",
        function ($parse) {
            return {
                priority:1,
                link: function(scope, element, attrs, ngModel) {

                    // Listen for submit event and populate fields
                    // from autofilled inputs
                    element.bind("submit", function(event) {

                        var inputs = element.find("input");

                        // For each input, set the value on the inputs ngModel controller
                        // to the current value of the input
                        for ( var i = 0 ; i < inputs.length ; i++ ) {

                            var input = angular.element(inputs[i]);
                            if ( input.attr("type") !== "checkbox" && input.attr("type") !== "radio" ) {
                                var value = input.val();
                                input.controller("ngModel").$setViewValue(value);
                            }
                        }

                        // Call function defined in the directive
                        var fn = $parse(attrs.ccSubmit);
                        fn(scope, {
                            $event: event
                        });
                    });
                }
            }
        }
    ]
});
//
// Build table with specified columns and rows
//

"use strict";

angular.module("mtApp").directive("ccMagicTable", function() {

    return {

        restrict: "A",
        scope: {
            capabilities: "=",
            columns: "=",
            editFn: "&",
            showConfirmRetireFn: "&",
            rows: "=",
            showFn: "&"
        },
        link: function(scope, element, attrs) {

            //
            // Return ID for row
            //
            scope.getIdValue = function(row) {

                var key = "";
                _.each(scope.columns, function(column) {

                    if ( column.idKey ) {
                        key = scope.getValue(row, column.fieldName);
                        return;
                    }
                });

                return key;
            };

            //
            // Deep resolve of specified value on object. For example,
            // value to be pulled from object may be "surgeon.organization.name".
            // This needs to be broken down in to: sugeon[organization][name].
            //
            scope.getValue = function(row, column) {
                return buildFilterableValue(row,column);
            };

            //
            // Edit the specified entity if there is an edit
            // function specified
            //
            scope.editEntity = function (id) {

                if ( attrs.editFn ) {

                    scope.editFn({
                        id: id
                    });
                }
            };

            //
            // Retire the specified entity if there is a retire
            // function specified
            //
            scope.showConfirmRetireEntity = function (id) {

                if ( attrs.showConfirmRetireFn ) {

                    scope.showConfirmRetireFn({
                        id: id
                    });
                }
            };

            //
            // Show the specified entity if there is an show
            // function specified
            //
            scope.showEntity = function (id) {

                if ( attrs.showFn ) {

                    scope.showFn({
                        id: id
                    });
                }
            };
        },
        templateUrl: "/views/templates/cc-magic-table.html"
    };

    //
    // PRIVATES
    //

    //
    // Deep resolve of specified value on object. For example,
    // value to be pulled from object may be "surgeon.organization.name".
    // This needs to be broken down in to: sugeon[organization][name].
    // TODO(dave) this is repeated in cc filters
    //
    function buildFilterableValue(obj, pathChunks) {

        if ( !(pathChunks instanceof Array) ) {
            pathChunks = pathChunks.split(".");
        }

        // If there is no nested paths in the
        // path (ie there is no ".", just return the
        // value
        if ( pathChunks.length === 1 ) {

            return obj[pathChunks[0]];
        }

        var childObj = obj[pathChunks.shift()];
        if ( !childObj ) {
            return "";
        }
        return buildFilterableValue(childObj, pathChunks);
    }
});

//
// Create model value in place
//

angular.module("mtApp").directive("ccCreateInPlace", function() {

    return {

        restrict: "A",
        scope: {
            fieldName: "@",
            maxLength: "@",
            model: "=",
            selectFn: "&",
            removeFn: "&"
        },
        link: function(scope, element, attrs) {

            // Set focus on element
            element.find("input")[0].focus();

            //
            // Handle click of check mark - set value on model
            //
            scope.setValue = function() {

                setValue(scope, attrs);
            };


            //
            // Handle key down event - set value on model
            // if key pressed was enter or tab
            //
            scope.checkComplete = function(event) {

                if ( event.keyCode === 13 || event.keyCode === 9 ) {

                    terminateEvent(event);

                    setValue(scope, attrs);
                }
            };

            //
            // Remove write in input
            //
            scope.cancelWriteIn = function() {

                if ( attrs.removeFn ) {
                    scope.removeFn();
                }
            };
        },
        templateUrl: "/views/templates/createinplace.html"
    };

    //
    // PRIVATES
    //

    function setValue(scope, attrs) {

        scope.model[scope.fieldName] = scope.writeInText;

        if ( attrs.selectFn ) {
            scope.selectFn();
        }
    }

    //
    // Prevent default and stop propagation of event
    //
    function terminateEvent(event) {

        if ( event ) {

            if ( event.stopPropagation ) {
                event.stopPropagation();
            }
            else {
                event.cancelBubble();
            }
            event.preventDefault();
        }
    }
});

//
// Typeahead input
// - Defines typeahead input where text is cleared from input after being
// selected from typeahead options.
//
// - Requires cc-typeahead directive for handling mouse and key events.
//

"use strict";

angular.module("mtApp").directive("ccTypeahead", function($document, $timeout) {

    return {

        restrict: "A",
        scope: {
            displayTextFn: "&",
            fieldName: "@",
            filterables: "@",
            inputId: "@",
            inputNotes: "=",
            items: "=",
            groupSize: "@",
            max: "@",
            required: "@",
            removeCallback: "&",
            selectCallback: "&",
            selectedItems: "=",
            selectedTextFn: "&",
            showOnFocus: "@",
            sortSelectedItemsFn: "&",
            submitted: "=",
            writeInRevertFn: "&",
            writeInUpdateFn: "&"
        },
        link: function(scope, element, attrs) {

            // Get handle on body, input and corresponding model controller
            var body = $document[0].body;
            var input = element.find("input");
            var ngModelController = input.controller("ngModel");

            // True if items/selected items have been completely initialized
            scope.selectedItemsTagged = false;

            // Setup "required" validation on selected items
            initValidityRequiredWatch(scope, ngModelController);

            // Setup groups for displaying selected items (used
            // to do selected items into groupings for each row),
            // mark selected items
            initSelectedItemsWatch(scope, attrs);

            // Setup watch for any changes in items array
            initItemsWatch(scope);

            //
            // Handle key press (for navigation through items, selecting items)
            //
            scope.navigate = function(event) {

                scope.selected = false;

                // Hide write in if there is any keypress in the main
                // typeahead input
                scope.writeIn = false;

                // Handle up arrow key
                var keyCode = event.keyCode;
                if ( keyCode === 38 ) {

                    handleUpKeyPress(event, scope);
                }
                // Handle down arrow key
                else if ( keyCode === 40 ) {

                    handleDownKeyPress(event, scope);
                }
                // Handle enter key or tab key
                else if ( event.keyCode === 13 || event.keyCode === 9 ) {

                    handleSelectKeyPress(event, scope);
                }
                // Handle escape
                else if ( event.keyCode === 27 ) {

                    scope.handleClear();
                }
            };

            //
            // Handle updates to input field - update validity
            // of model controller (want to catch "junk" input
            // that hasn't been matched to an item in the list)
            //
            scope.updateValidity = function(event) {

                // Ignore enter key - validitiy in this case is
                // handled by handleSelect function
                if ( event.keyCode === 13 || event.keyCode === 9 ) {

                    return;
                }

                // Set invalid if value is specified
                updateValiditySelected(input, ngModelController);
            };

            //
            // Handle select of item from menu options
            //
            scope.selectItem = function(selectedItem) {

                // Remove listener from body (we no longer need to
                // listen for click events to close the menu as an
                // item has been selected by the user and the menu
                // will automatically close)
                removeCloseMenuListener(scope, body);

                // If the selected item is a write in but
                // selected item is not marked as complete, set
                // the selected item to be the object backing the
                // write in and show the write in box
                if ( selectedItem.writeIn && !selectedItem.writeInCompleted ) {

                    scope.writeIn = selectedItem;

                    // Update the value of the typehead to display the full
                    // display text for the selected item
                    scope.searchCriteria = scope.selectedTextFn({
                        item: selectedItem
                    });

                    // Set focus on write in input
                    focusWriteIn(scope, element);
                }
                // Otherwise it's not a write in OR it is a write
                // in and the write in has been completed - proceed
                // as normal
                else {

                    // Clear menu and input
                    reset(scope, input, ngModelController);

                    // Clear (reference to) write in - the writeIn object
                    // determine the visibility of the write in input box,
                    // will only be set if user is currently adding a write in
                    scope.writeIn = null;

                    // Add selected item to list of selected items
                    scope.selectedItems.push(selectedItem);

                    // Call callback if specified
                    if ( attrs.selectCallback ) {
                        scope.selectCallback({
                            item: selectedItem
                        });
                    }

                    // Remove focus from input if typeahead is
                    // modelled similar to select box where options
                    // are shown on input
                    if ( scope.showOnFocus ) {
                        scope.focus = false;
                        input[0].blur();
                    }
                }
            };

            //
            // Handle remove of selected item
            //
            scope.removeItem = function(itemToRemove) {

                // Find the object in the item in the list
                var itemInList = _.find(scope.items, function(item) {
                    return item._id === itemToRemove._id;
                });

                // Remove item from list of selected items
                for ( var i = 0 ; i < scope.selectedItems.length ; i++ ) {

                    var item = scope.selectedItems[i];
                    if ( item._id === itemToRemove._id ) {
                        break;
                    }
                }
                scope.selectedItems.splice(i, 1);

                // Handle case where corresponding item was found in list.
                // It is possible item is not in list (eg if an item has been
                // deleted)
                if ( itemInList ) {

                    // If this is a write in, we need to revert it
                    // to it's original format
                    if ( itemInList.writeIn ) {

                        // Update flag to indicate write in
                        // has not been completed on for this option
                        itemInList.writeInCompleted = false;

                        // Call custom revert callback (eg to
                        // reset "name" to pre-write in value)
                        scope.writeInRevertFn({
                            item:itemInList
                        });
                    }

                    // Mark item as not selected (and therefore add item back back
                    // to items menu)
                    itemInList.selected = false;
                }

                // Group the selected items
                scope.selectedItemGroups = scope.selectedItems.chunk(parseInt(scope.groupSize, 10));

                // Call callback if specified
                if ( attrs.removeCallback ) {
                    scope.removeCallback({
                        item: itemToRemove,
                        index: i
                    });
                }
            };

            //
            // Clear current selection/current input
            //
            scope.handleClear = function() {

                // Reset current index
                scope.current = -1;

                // Clear menu and input
                reset(scope, input, ngModelController);

                // Remove focus from input if typeahead is
                // modelled similar to select box where options
                // are shown on input
                if ( scope.showOnFocus ) {
                    scope.focus = false;
                    input[0].blur();
                }
            };

            //
            // Determine how many characters are remaining in the typeahead
            //
            scope.getCharsRemaining = function() {

                var count = 200;
                if ( scope.writeInText ) {
                    count = 200 - scope.writeInText.length;
                }

                return count;
            };

            //
            // Close menu - called when click event occurs anywhere on page
            // except on the menu itself, or in the typeahead input
            //
            scope.closeMenu = function() {

                // Use timeout to get outside of Angular context - required
                // because close event can be triggered from either inside
                // the Angular context (eg when clicking on another typeahead
                // input and calling the handleFocus function) OR outside of
                // the Angular context (eg clicking outside of any typehead input).
                // We use timeout to prevent a "digest already in progress" error.
                $timeout(function() {
                    scope.$apply(function() {
                        reset(scope, input, ngModelController);
                        scope.focus = false;
                        scope.writeIn = null;
                        scope.writeInText = "";
                    });
                });

                // Remove click listener from body
                removeCloseMenuListener(scope, body);
            };

            //
            // Set focus to true, setup listener for click events
            // on body (to close typeahead menu)
            //
            scope.handleFocus = function() {

                // Set focus to true
                scope.focus = true;

                // Trigger all other typeahead menus to close
                var $body = angular.element(body);
                $body.triggerHandler("click");

                // Add click listener to body - we want to close
                // this typeahead menu if there is a click anywhere on
                // the page
                registerCloseMenuListener(scope, body);
            };

            //
            // Don't trigger close of menu if click is generated
            // from input (click handler has been set up on body
            // to close menu on click but we don't want to trigger
            // the close event if we're clicking inside the input)
            //
            scope.handleClick = function(event) {

                terminateEvent(event);
            };

            //
            // Determine if menu should be visible. Functionality is different
            // according to whether menu is to be displayed as soon as the
            // typeahead has focus OR after typeahead has focus and user has entered
            // search text
            //
            scope.isShowMenu = function() {

                // Do not show menu if there is currently a write in in progress
                if ( scope.writeIn ) {
                    return false;
                }

                // If show on focus and the input has focus and there are
                // filtered items, show menu
                if ( scope.showOnFocus && scope.focus && !!scope.filteredItems.length ) {
                    return true;
                }

                // If no show on focus and there is no search criteria and there
                // are no filtered items, show menu
                if ( scope.searchCriteria && !!scope.filteredItems.length ) {
                    return true;
                }

                return false;
            };


            //
            // Highlight item if it's the currently selected value
            //
            scope.isCurrent = function(index) {
                return scope.current === index;
            };

            //
            // Highlight item on mouseover
            //
            scope.setCurrent = function(index) {
                scope.current = index;
            };

            //
            // Returns true if we want to display the selected tags
            // one per row.
            //
            scope.isDisplaySingle = function() {

                return parseInt(scope.groupSize, 10) === 1;
            };

            //
            // Returns true if we want to display the selected tags
            // two per row
            //
            scope.isDisplayHalves = function() {

                return parseInt(scope.groupSize, 10) === 2;
            };

            //
            // Returns ture if we want to display the selected tags
            // four per row
            //
            scope.isDisplayQuarters = function() {

                return parseInt(scope.groupSize, 10) === 4;
            };

            //
            // Returns true if max number of items have been selected
            //
            scope.isMaxNumberSelected = function() {

                if ( attrs.max ) {
                    return scope.selectedItems.length === parseInt(attrs.max, 10);
                }

                return false;
            };

            //
            // Returns the selected text for the specified item
            //
            scope.getSelectedText = function(itemId) {

                // Find the item by ID
                var item = findItemById(scope, itemId);
                scope.selectedTextFn({item: item});
            };

            //
            // Handle completion of write in - update
            // write in backing object (if specified)
            //
            scope.completeWriteIn = function(event) {

                terminateEvent(event);

                // Write in text is required for completion
                if ( !scope.writeInText ) {
                    return;
                }

                // Call select callback (eg to update "name"
                // value with write in text)
                scope.writeInUpdateFn({
                    item: scope.writeIn,
                    text: scope.writeInText
                });

                // Clear write in text
                scope.writeInText = "";

                // Update selected item to indicate write in
                // is complete, then call select function
                scope.writeIn.writeInCompleted = true;
                scope.selectItem(scope.writeIn);
            };

            //
            // Remove write in option
            //
            scope.cancelWriteIn = function() {

                // Reset typeahead
                reset(scope, input, ngModelController);

                // Clear writeInCompleted flag on selected
                // write in item (this flag is used to determine
                // whether the write in value has been completed
                // and can be added to the list of selected items)
                scope.writeIn.writeInCompleted = false;

                // Reset write in related values on scope - do
                // this after a slight delay to allow reset of
                // typehead and void "flash" of open menu
                $timeout(function() {
                    scope.writeInText = null;
                    scope.writeIn = null;
                });
            };

            //
            // Complete write in if enter or tab key was pressed
            //
            scope.checkComplete = function(event) {

                // Handle enter key or tab key
                if (event.keyCode === 13 || event.keyCode === 9) {

                    scope.completeWriteIn();
                    event.preventDefault();
                }
            };
        },
        templateUrl: "/views/templates/typeahead.html"
    };

    //
    // PRIVATES
    //

    //
    // Sort and group the selected item for display
    //
    function updateSelectedItemsDisplay(scope, attrs) {

        // Sort selected items
        if ( attrs.sortSelectedItemsFn ) {

            scope.selectedItems.sort(function(item0, item1) {

                return scope.sortSelectedItemsFn({
                    item0: item0,
                    item1: item1
                });
            });
        }

        var groupSize = parseInt(scope.groupSize, 10);
        scope.selectedItemGroups = scope.selectedItems.chunk(groupSize);
    }

    //
    // Handle press of down key
    //
    function handleUpKeyPress(event, scope) {

        // Prevent default keyup action (ie moving cursor in input)
        preventDefault(event);

        // Determine the index of the last item in the list
        var lastIndex = scope.filteredItems.length - 1;

        // Determine the previous item to navigate to
        var previous = lastIndex;
        if ( scope.current || scope.current === 0 ) {
            previous = scope.current - 1;
        }

        // Check if we're at the beginning of the list.
        // If so, reset index (ie remove all highlighted
        // items and return focus to input)
        if ( scope.current === 0 ) {
            previous = null;
        }
        scope.setCurrent(previous);
    }

    //
    // Handle press of up key
    //
    function handleDownKeyPress(event, scope) {

        // Prevent default keydown action (ie moving cursor in input)
        preventDefault(event);

        // Determine the index of the last item in the list
        var lastIndex = scope.filteredItems.length - 1;

        // Determine the next item to navigate to
        var next = 0;
        if ( scope.current || scope.current === 0 ) {
            next = scope.current + 1;
        }

        // Check if we've fallen off the end of the list.
        // If so, reset index (ie remove all highlighted
        // items and return focus to input)
        if ( scope.current === lastIndex ) {
            next = null;
        }

        scope.setCurrent(next);
    }

    //
    // Handle press of enter key or tab key
    //
    function handleSelectKeyPress(event, scope) {

        // Prevent form submit in the case where the
        // enter key was hit
        preventDefault(event);

        // If there is only one item in the list, set the current
        // to be the first and only item in the list - this is
        // to setup automatic selection of the single item in the list
        if ( scope.filteredItems.length === 1 ) {
            scope.current = 0;
        }

        // Select the current item if there is one
        if ( scope.current || scope.current === 0) {

            scope.selectItem(scope.filteredItems[scope.current]);

            // Reset current
            scope.current = null;
        }
    }

    //
    // Initialize watch on selected items to update validity of input
    //
    function initValidityRequiredWatch(scope, ngModelController) {

        // Only add watch if value is required
        if ( !scope.required || scope.required === "false" ) {
            return;
        }

        // Add watch on selected items
        scope.$watch("selectedItems", function(newValue) {

            ngModelController.$setValidity("required", newValue && newValue.length > 0);

        }, true);
    }
    //
    // Setup "grouping" for displaying selected items, mark any items as
    // selected
    //
    function initSelectedItemsWatch(scope, attrs) {

        scope.selectedItemGroups = [];

        scope.$watch("selectedItems", function(newValue) {

            if ( !newValue ) {
                return;
            }

            // Watch for when selected items has been cleared - we will want
            // to also clear the groups, and set all options to visible
            if ( newValue.length === 0 ) {

                clearItemsAsSelected(scope);
                scope.selectedItemGroups = [];

            }
            // Otherwise watch for when selected items is set externally - we
            // will want to update the grouping/display of the selected items
            else {

                // If the items array has been set, mark selected
                // items in items array as selected
                if ( scope.items && scope.items.length ) {
                    tagItemsAsSelected(scope);
                }

                // Group the selected items
                updateSelectedItemsDisplay(scope, attrs);
            }
        }, true);
    }

    //
    // Init watch of selected items / all items - we need to mark
    // any selected items in the complete list of items as selected
    //
    function initItemsWatch(scope) {

        scope.$watch("items", function(newValue) {

            if ( !newValue ) {
                return;
            }

            // Don't try to mark the selected items if they have already been marked
            if ( scope.selectedItemsTagged || !scope.selectedItems || !scope.selectedItems.length ) {
                return;
            }

            // Iterate over the selected items and mark them!
            tagItemsAsSelected(scope);
        });
    }

    //
    // Reset typehead - clear search criteria and input
    //
    function reset(scope, input, ngModelController) {

        // Hide items menu by clearing filter
        // criteria
        scope.searchCriteria = "";

        // Set current
        scope.current = -1;

        // Clear input value
        input.val("");

        // Update validity
        updateValiditySelected(input, ngModelController);
    }

    //
    // Update validity of "selected" of typeahead - invalid if
    // user has entered "junk" text without selecting an option
    // from the typehead menu
    //
    function updateValiditySelected(input, ngModelController) {

        ngModelController.$setValidity("selected", !input.val());
    }

    //
    // Prevent default event action
    //
    function preventDefault(event) {

        if ( event.preventDefault ) {
            event.preventDefault();
        }
        else {
            event.returnValue = false;
        }
    }

    //
    // Return the item with the specified ID
    //
    function findItemById(scope, itemId) {

        for ( var i = 0 ; i < scope.items.length ; i++ ) {

            var itemToCheck = scope.items[i];
            if ( itemToCheck._id === itemId ) {
                return itemToCheck;
            }
        }

    }

    //
    // Focus cursor in write in input
    //
    function focusWriteIn(scope, element) {

        // Remove focus from typeahead
        scope.focus = false;

        // Find the inputs inside this directive
        var inputs = element.find("input");

        // At this point, we know there should be
        // two - the typeahead input and the write
        // in input.
        if ( inputs.length < 2 ) {
            return;
        }

        // Grab the last input (as this is the write in) and focus,
        // add timeout to ensure focus is executed after write in
        // input is updated from hidden to displayed
        $timeout(function() {
            inputs[1].focus();
        }, 250);
    }

    //
    // Prevent default and stop propagation of event
    //
    function terminateEvent(event) {

        if ( event ) {

            if ( event.stopPropagation ) {
                event.stopPropagation();
            }
            else {
                event.cancelBubble();
            }
            event.preventDefault();
        }
    }

    //
    // Register listener to the body that listens
    // for click events to trigger close of typeahead menu
    //
    function registerCloseMenuListener(scope, body) {

        var $body = angular.element(body);
        angular.element($body).on("click", scope.closeMenu);
    }

    //
    // Remove the listener from the body that listens
    // for click events to trigger the close of the
    // typeahead menu
    //
    function removeCloseMenuListener(scope, body) {

        var $body = angular.element(body);
        angular.element($body).off("click", scope.closeMenu);
    }

    //
    // Mark objects in items array as selected if they are also in the
    // selected items array
    //
    function tagItemsAsSelected(scope) {

        scope.selectedItemsTagged = true;

        // Map items by ID
        var itemsById = _.indexBy(scope.items, "_id");

        // Iterate over selected items, find the corresponding
        // item in the list and mark it as selected - this is to
        // get around the fact that the selected items may not always
        // have reference equality to the items in the items array
        for ( var i = 0 ; i < scope.selectedItems.length ; i++ ) {

            var selectedItem = scope.selectedItems[i];
            var itemInList = itemsById[selectedItem._id];

            if ( itemInList ) {
                itemInList.selected = true;
            }
        }
    }

    //
    // Untag all options - this may be required if selected items
    // are "reset" outside of the directive
    //
    function clearItemsAsSelected(scope) {

        _.each(scope.items, function(selectedItem) {

            selectedItem.selected = false;
        });
    }
});

//
// Date picker
//

angular.module("mtApp").directive("ccValidateNumber", function() {

    return {

        restrict: "A",
        require: "?ngModel",
        scope: {
        },
        link: function(scope, element, attrs, ngModelController) {
            // Must have ng model controller to continue
            if ( !ngModelController ) {
                return;
            }

            // Setup key up listener
            element.on("keyup", function() {
                handleKeyUp(scope, element, attrs, ngModelController);
            });
        }
    };

    //
    // PRIVATES
    //

    //
    //
    //
    function handleKeyUp(scope, element, attrs, ngModelController) {

        scope.$apply(function() {

            var value = element.val();
            if ( !value || value === "" ) {

                ngModelController.$setValidity("number", false);
            }
            else {
                ngModelController.$setValidity("number", isNumber(value));
            }
        });
    }

    //
    // Returns true if specified value is a number
    //
    function isNumber(value) {

        if ( !value ) {
            return true;
        }

        return !isNaN(parseFloat(value)) && isFinite(value);
    };
});
//
// Handle password and password confirm functionality
//
//

angular.module("mtApp").directive("ccPasswordConfirm", function() {

    return {
        restrict: "A",
        require: "ngModel",
        link: function(scope, element, attrs, ctrl) {

            // Find the form element
            var formEl = element.parent();
            while (formEl[0].tagName !== "FORM") {

                formEl = formEl.parent();

                if ( formEl[0].tagName === "BODY") {
                    break;
                }
            }

            var inputs = formEl[0].getElementsByTagName("input");
            var passwordInput;
            for ( var i = 0 ; i < inputs.length ; i++ ) {

                var input = inputs[i];
                var inputName = input.getAttribute("name");
                if ( inputName === "password" ) {
                    passwordInput = input;
                    break;
                }
            }

            // We must have a password input to continue
            if ( !passwordInput ) {
                return;
            }

            // Convert password input into angular element for easy
            // event listener registration etc
            passwordInput = angular.element(passwordInput);

            // Mark input as dirty if any keyup event causes
            // two input fields to not equal each other
            function handleKeyUp() {
                scope.$apply(function() {
                    if ( element.val() === passwordInput.val() ) {
                        ctrl.$setValidity("passwordMatch", true);
                    }
                    else {
                        ctrl.$setValidity("passwordMatch", false);
                    }

                });
            }
            element.on("keyup", handleKeyUp);
            passwordInput.on("keyup", handleKeyUp);
        }
    };

});
//
// Numbers only
// Restrict input type text to enter numbers only
// it also evaluates if max and min is provided
//

angular.module("mtApp").directive("ccNumbersOnly", function() {

    return {

        restrict: "A",
        require: "?ngModel",
        link: function(scope, element, attrs, ngModelController) {

            ngModelController.$parsers.push(function (inputValue) {

                // replace strings empty
                try {
                    var convertInput = inputValue.replace(/[^0-9]/g, '');  
                } catch(err){}
                if(!inputValue) {

                    if(attrs.max || attrs.min) {
                        ngModelController.$setValidity("max", true);
                        ngModelController.$setValidity("min", true);
                    }

                    return '';
                }

                if(convertInput !== inputValue) {

                    ngModelController.$setViewValue(convertInput);
                    ngModelController.$render();
                    
                } else {

                    inputValue = parseInt(inputValue, 10);
                    
                    if(attrs.max) {
                        var max = parseInt(attrs.max, 10);
                        ngModelController.$setValidity("max", (inputValue <= max || inputValue < 0) ? true : false);
                    }

                    if(attrs.min) {
                        var min = parseInt(attrs.min, 10);
                        ngModelController.$setValidity("min", (inputValue >= min || inputValue < 0) ? true : false);
                    }

                    return inputValue;
                }    

            });
        }
    };
});
//
// Pagination directive
//

(function() {

	"use strict";


	var pagination = function($state, PAGINATION) {

		return {
			restrict: "A",
			replace: true,
			scope: {
                items: "=",
                itemCount: "=",
                queryFn: "&",
                paginationKey: "@"
			},
			link: function (scope) {

                // Setup pagination state
                init(scope);

                // Show next page of results
                scope.next = function() {

                    // Calculate next offset and limit
                    scope.offset = scope.offset + PAGINATION[scope.paginationKey].limit;
                    paginate(scope);
                };

                // Show previous page of results
                scope.previous = function() {

                    // Calculate next offset and limit
                    scope.offset = scope.offset - PAGINATION[scope.paginationKey].limit;
                    paginate(scope);
                };

                //
                // Returns true if we're on the fist page
                //
                scope.isFirst = function() {

                    return scope.itemCountOnPage <= PAGINATION[scope.paginationKey].limit;
                };

                //
                // Returns true if we're on the last page
                //
                scope.isLast = function() {

                    return scope.itemCountOnPage >= scope.itemCount;
                };

                // Return the current page number
                scope.getPageNumber = function (offset) {

                    // If there are no items, there are no pages!
                    if ( !scope.items.length ) {
                        return "0";
                    }

                    return offset === 0 ? "1" : offset + 1;
                };

                // Return the display text (n to n of n)
                scope.getPaginationDisplayText = function() {

                    var text = [];
                    text.push(scope.getPageNumber(scope.offset));
                    text.push("to");
                    text.push(scope.itemCountOnPage);
                    text.push("of");
                    text.push(scope.itemCount);
                    return text.join(" ");
                };
			},
            templateUrl: function(element, attrs) {
                return attrs.templateUrl || "/views/templates/cc-pagination.html";
            }
		};

        //
        // Privates
        //

        //
        // Setup pagination state
        //
        function init(scope) {

            // Offset defaults to 0 (ie first page)
            scope.offset = 0;

            // Number of results per page
            scope.itemCountOnPage = scope.items.length;

            // Setup watch for items removed from list (eg deleted, canceled etc)
            scope.$on("update:remove", function (data) {

                // If we've removed the last item on the page and we're not on
                // the first page, decrement the total count and show the previous page
                if ( scope.items.length === 0 && !scope.isFirst() ) {

                    scope.itemCount--;

                    scope.previous();
                }
                // Otherwise, decrement the counts for the current page and reshow
                else {

                    scope.itemCountOnPage--;
                    scope.itemCount--;

                    paginate(scope);
                }
            });

            // Setup watch for reset of list (eg if list has been filtered)
            scope.$on("cc-pagination:reset", function () {

                scope.itemCount = scope.items.length;
                scope.itemCountOnPage = scope.items.length;
                scope.offset = 0;
            });

            // Setup watch for reset of list (eg for auto refresh of list)
            scope.$on("cc-pagination:refresh", function () {

                paginate(scope);
            });
        }

        //
        // Paginate according to updated offset/limit values
        //
        function paginate(scope) {

            scope.loading = true;

            scope.queryFn({
                pagination: {
                    offset: scope.offset
                },
                callback: function(items, count) {

                    scope.loading = false;

                    // Update the number of results on page
                    scope.itemCountOnPage = scope.offset + items.length;

                    // Update total count
                    scope.itemCount = count;

                    // If there are no items and we've got a total count greater than 0
                    // and we're not on the first page, paginate to the previous page. This
                    // can occur if we're reloading the current page (eg on an auto refresh)
                    // but an item has "fallen out"
                    if ( !items.length && scope.offset > 0 && count > 0 ) {
                        scope.previous();
                    }
                }
            });
        }
	};

	angular.module("mtApp").directive("ccPagination", pagination);
})();

//
//	Filter by Id directive

(function() {
	'use strict';

	var ccFilterId = function() {
		return {
			restrict: 'A',
			replace: true,
			scope: {
                clearFn: "&",
				filterFn: "&",
                specifiedMedtelId: "="
			},
			link: function (scope) {

                //
			    // Filter by Medtell ID. When text is empty go back to active case
			    // reload current state.
                //
			    scope.handleKeyUp = function (event) {

                    if ( scope.medtelId && !/^\d+$/.test(scope.medtelId) ) {
                        return;
                    }

                    var keyCode = event.keyCode;
                    if ( keyCode === 13 ) {

                        filter(scope);
                    }
                    else {

                        // If there is no Medtel ID specified, clear
                        // the filter
                        if ( !scope.medtelId ) {

                            clear(scope);
                        }
                    }
			    };
			},
			templateUrl: '/views/templates/cc-filter-id.html'
		};

        //
        // PRIVATES
        //

        //
        // Execute filter...
        //
        function filter(scope) {

            // Don't attempt to filter until we have at least
            // four characters
            if ( scope.medtelId.toString().length < 4 ) {
                return;
            }
            scope.filterFn({
                medtelId: scope.medtelId
            });
        }

        //
        // Clear filter
        //
        function clear(scope) {

            scope.clearFn();
        }

	};
	angular.module('mtApp').directive('ccFilterId', ccFilterId);
})();
//
// Ignore and restrict user to input |^ characters
// and replace it with space
//

angular.module("mtApp").directive("ccIgnoreCharacters", function() {

    return {
    	// sets directive to attribute
        restrict: "A",

        // requires the ngModelController
        require: "ngModel",

        link: function(scope, element, attrs, ngModelController) {
        	// check if ngmodelController is present on the element
        	if(!ngModelController) {
        		return;
        	}

        	// parse and detect the characters
        	// replace it with space
            ngModelController.$parsers.push(function (inputValue) {
                var cleanStr = '';
                if (inputValue) {
                	cleanStr = inputValue.replace(/(\||\^)/g, '');
                	if (cleanStr !== inputValue){
                		ngModelController.$setViewValue(cleanStr);
                    	ngModelController.$render();
                	}
                }
            	return cleanStr;	
            });
        }
    };
});
//
// CC print - trigger print on load of element
//

angular.module("mtApp").directive("ccPrint", function($window, $timeout) {

    return {

        restrict: "A",
        link: function() {

            $timeout(function() {
                $window.print();
            }, 500);
        }
    };

});
//
// Generates table for listing products.
//
// @param products Expecting a homogeneous array of product sources (eg of type IMPLANT, ANCILLARY,
// MONITORING or BONE_GRAFT)
//

"use strict";


angular.module("mtApp").directive("ccProductsourceLister", function() {

	return {
		restrict: "A",
		scope: {
            listProductsFn: "&",
            listRepsFn: "&",
            organization: "=",
			products: "=",
            productTypeDisplayName: "@"
		},
        transclude: true,
        link: function(scope) {

            // Set flag to indicate if we're dealing with a
            // list of implants (to determine which columns to show).
            if ( scope.products.length ) {

                var first = scope.products[0];
                if ( first.product.productType === "IMPLANT" ) {

                    scope.implant = true;
                }
            }
        },
		templateUrl: "/views/templates/cc-admin-productsource-index.html"
	};
});

//
// Generates list of products.
//
// @param products Expecting a homogeneous array of product sources (eg of type IMPLANT, ANCILLARY,
// MONITORING or BONE_GRAFT)
//
//

"use strict";


angular.module("mtApp").directive("caseProductsourceLister", function(ProductSourceService) {

    return {
        restrict: "A",
        scope: {
            products: "=",
            productTypeDisplayName: "@"
        },
        transclude: true,
        link: function(scope) {

            /**
             * @returns {String} Display text for specified product according to
             * the product's type
             */
            scope.getProductSourceDisplayText = function(productSource) {

                var implantText = [];

                var category = productSource.product.category;
                if ( category === "FIXATION" ) {
                    implantText.push("Fixation: ");
                }
                else if ( category === "INTERBODY" ) {
                    implantText.push("Interbody: ");
                }

                implantText.push(productSource.product.name);

                if ( productSource.product.productType === "IMPLANT" ) {

                    implantText.push("/");
                    implantText.push(productSource.rep.firstName);
                    implantText.push(productSource.rep.lastName + ",");
                    implantText.push(productSource.manufacturer.name);
                }

                return implantText.join(" ");
            };
        },
        templateUrl: "/views/templates/mt-case-productsource-lister.html"
    };
});

//
// Vertebrae selector
//

"use strict";

angular.module("mtApp").directive("mtVertebraeSelector", function() {

    return {

        restrict: "A",
        scope: {
            inputIdStem: "@",
            modelFrom: "=",
            modelTo: "="
        },
        link: function(scope) {

            // Create array of vertebrae values
            createVertebraeOptions(scope);

            //
            // Setup watch on "to" box - need to do this for when "to" box
            // has a default value (eg on edit)
            //
            scope.$watch("modelTo", function() {

                // Setup "to" drop down..
                scope.updateToOptions();
            });

            //
            // Update options or "to" box
            //
            scope.updateToOptions = function() {

                // Clear "to" value if there is no "from" value
                if ( !scope.modelFrom ) {
                    scope.modelTo = "";
                    return;
                }

                // Otherwise, generate values for "to" drop down

                // Find the index of the selected
                var vertebra;
                for ( var i = 0 ; i < scope.vertebraeFrom.length ; i++ ) {

                    vertebra = scope.vertebraeFrom[i];
                    if ( vertebra === scope.modelFrom ) {
                        break;
                    }
                }

                // Splice the "to" array to after the index of the
                // selected "from" value
                scope.vertebraeTo = scope.vertebraeFrom.slice(i + 1, scope.vertebraeFrom.length);

                // If there is a previously selected "to" value which is no longer
                // in the update "to" array, clear the "to" value
                var inRange = false;
                for ( var j = 0 ; j < scope.vertebraeTo.length ; j++ ) {

                    vertebra = scope.vertebraeTo[j];
                    if ( vertebra === scope.modelTo ) {
                        inRange = true;
                        break;
                    }
                }

                if ( !inRange ) {
                    scope.modelTo = "";
                }
            };
        },
        templateUrl: "/views/templates/mt-vertebrae-selector.html"
    };

    //
    // PRIVATES
    //

    //
    // Create array of vertebrae values to be used in drop
    // down
    //
    function createVertebraeOptions(scope) {

        scope.vertebraeFrom = ["", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "T1", "T2", "T3",
            "T4", "T5", "T6", "T7", "T8","T9", "T10", "T11", "T12", "L1", "L2", "L3", "L4", "L5", "S1", "S2", "S3", "S4", "S5", "ILIUM"];
    }

});

//
// Filter procedures by CPT code and description
//
// @param items The array of items to filter
// @param query The value to filter the items by
// @param filterables Array of properties on items to filter on
//

angular.module("ccFilters", []).filter("ccObjectFilter", function() {

    return function(items, query, filterables) {

        // Return all items if there is no query to filter by
        if ( !query ) {
            return items;
        }

        // Split filterables into an array (eg code,description into
        // [code,description])
        filterables = filterables.split(",");

        if ( angular.isUndefined(query) ) {
            return items;
        }

        query = angular.lowercase(query);
        var matches = [];

        angular.forEach(items, function(item) {

            // Calculate value to filter on for this item
            var toFilter = [];
            angular.forEach(filterables, function(property) {

                toFilter.push(buildFilterableValue(item, property));
            });

            var stringToFilter = toFilter.join(" ").toLowerCase();
            if ( stringToFilter.indexOf(query) >= 0 ) {
                matches.push(item);
            }
        });

        return matches;
    };

    //
    // PRIVATES
    //

    //
    //
    //
    function buildFilterableValue(obj, pathChunks) {

        if ( !(pathChunks instanceof Array) ) {
            pathChunks = pathChunks.split(".");
        }

        // If there is no nested paths in the
        // path (ie there is no ".", just return the
        // value
        if ( pathChunks.length === 1 ) {
            return obj[pathChunks[0]];
        }

        var childObj = obj[pathChunks.shift()];
        if ( !childObj ) {
            return "";
        }
        return buildFilterableValue(childObj, pathChunks);
    }
}).filter('ccCheckRole', function (AuthService) {

    return function(items, role) {

        var filtered = [];
        angular.forEach(items, function(item) {

            if ( AuthService.isAuthorized(item.role) ) {
                filtered.push(item);
            }
        });

        return filtered;
    }

});

/*!
 * zeroclipboard
 * The Zero Clipboard library provides an easy way to copy text to the clipboard using an invisible Adobe Flash movie, and a JavaScript interface.
 * Copyright 2012 Jon Rohan, James M. Greene, .
 * Released under the MIT license
 * http://jonrohan.github.com/ZeroClipboard/
 * v1.1.7
 */(function() {
    "use strict";
    var _getStyle = function(el, prop) {
        var y = el.style[prop];
        if (el.currentStyle) y = el.currentStyle[prop]; else if (window.getComputedStyle) y = document.defaultView.getComputedStyle(el, null).getPropertyValue(prop);
        if (y == "auto" && prop == "cursor") {
            var possiblePointers = [ "a" ];
            for (var i = 0; i < possiblePointers.length; i++) {
                if (el.tagName.toLowerCase() == possiblePointers[i]) {
                    return "pointer";
                }
            }
        }
        return y;
    };
    var _elementMouseOver = function(event) {
        if (!ZeroClipboard.prototype._singleton) return;
        if (!event) {
            event = window.event;
        }
        var target;
        if (this !== window) {
            target = this;
        } else if (event.target) {
            target = event.target;
        } else if (event.srcElement) {
            target = event.srcElement;
        }
        ZeroClipboard.prototype._singleton.setCurrent(target);
    };
    var _addEventHandler = function(element, method, func) {
        if (element.addEventListener) {
            element.addEventListener(method, func, false);
        } else if (element.attachEvent) {
            element.attachEvent("on" + method, func);
        }
    };
    var _removeEventHandler = function(element, method, func) {
        if (element.removeEventListener) {
            element.removeEventListener(method, func, false);
        } else if (element.detachEvent) {
            element.detachEvent("on" + method, func);
        }
    };
    var _addClass = function(element, value) {
        if (element.addClass) {
            element.addClass(value);
            return element;
        }
        if (value && typeof value === "string") {
            var classNames = (value || "").split(/\s+/);
            if (element.nodeType === 1) {
                if (!element.className) {
                    element.className = value;
                } else {
                    var className = " " + element.className + " ", setClass = element.className;
                    for (var c = 0, cl = classNames.length; c < cl; c++) {
                        if (className.indexOf(" " + classNames[c] + " ") < 0) {
                            setClass += " " + classNames[c];
                        }
                    }
                    element.className = setClass.replace(/^\s+|\s+$/g, "");
                }
            }
        }
        return element;
    };
    var _removeClass = function(element, value) {
        if (element.removeClass) {
            element.removeClass(value);
            return element;
        }
        if (value && typeof value === "string" || value === undefined) {
            var classNames = (value || "").split(/\s+/);
            if (element.nodeType === 1 && element.className) {
                if (value) {
                    var className = (" " + element.className + " ").replace(/[\n\t]/g, " ");
                    for (var c = 0, cl = classNames.length; c < cl; c++) {
                        className = className.replace(" " + classNames[c] + " ", " ");
                    }
                    element.className = className.replace(/^\s+|\s+$/g, "");
                } else {
                    element.className = "";
                }
            }
        }
        return element;
    };
    var _getDOMObjectPosition = function(obj) {
        var info = {
            left: 0,
            top: 0,
            width: obj.width || obj.offsetWidth || 0,
            height: obj.height || obj.offsetHeight || 0,
            zIndex: 9999
        };
        var zi = _getStyle(obj, "zIndex");
        if (zi && zi != "auto") {
            info.zIndex = parseInt(zi, 10);
        }

        // CC edit - start
        var rect = currentElement.getBoundingClientRect();
        info.top = rect.top;
        info.left = rect.left;
        // CC edit - end

        return info;
    };
    var _noCache = function(path) {
        return (path.indexOf("?") >= 0 ? "&" : "?") + "nocache=" + (new Date).getTime();
    };
    var _vars = function(options) {
        var str = [];
        if (options.trustedDomains) {
            if (typeof options.trustedDomains === "string") {
                str.push("trustedDomain=" + options.trustedDomains);
            } else {
                str.push("trustedDomain=" + options.trustedDomains.join(","));
            }
        }
        return str.join("&");
    };
    var _inArray = function(elem, array) {
        if (array.indexOf) {
            return array.indexOf(elem);
        }
        for (var i = 0, length = array.length; i < length; i++) {
            if (array[i] === elem) {
                return i;
            }
        }
        return -1;
    };
    var _prepGlue = function(elements) {
        if (typeof elements === "string") throw new TypeError("ZeroClipboard doesn't accept query strings.");
        if (!elements.length) return [ elements ];
        return elements;
    };
    var ZeroClipboard = function(elements, options) {
        if (elements) (ZeroClipboard.prototype._singleton || this).glue(elements);
        if (ZeroClipboard.prototype._singleton) return ZeroClipboard.prototype._singleton;
        ZeroClipboard.prototype._singleton = this;
        this.options = {};
        for (var kd in _defaults) this.options[kd] = _defaults[kd];
        for (var ko in options) this.options[ko] = options[ko];
        this.handlers = {};
        if (ZeroClipboard.detectFlashSupport()) _bridge();
    };
    var currentElement, gluedElements = [];
    ZeroClipboard.prototype.setCurrent = function(element) {
        currentElement = element;
        this.reposition();
        if (element.getAttribute("title")) {
            this.setTitle(element.getAttribute("title"));
        }
        this.setHandCursor(_getStyle(element, "cursor") == "pointer");
    };
    ZeroClipboard.prototype.setText = function(newText) {
        if (newText && newText !== "") {
            this.options.text = newText;
            if (this.ready()) this.flashBridge.setText(newText);
        }
    };
    ZeroClipboard.prototype.setTitle = function(newTitle) {
        if (newTitle && newTitle !== "") this.htmlBridge.setAttribute("title", newTitle);
    };
    ZeroClipboard.prototype.setSize = function(width, height) {
        if (this.ready()) this.flashBridge.setSize(width, height);
    };
    ZeroClipboard.prototype.setHandCursor = function(enabled) {
        if (this.ready()) this.flashBridge.setHandCursor(enabled);
    };
    ZeroClipboard.version = "1.1.7";
    var _defaults = {
        moviePath: "ZeroClipboard.swf",
        trustedDomains: null,
        text: null,
        hoverClass: "zeroclipboard-is-hover",
        activeClass: "zeroclipboard-is-active",
        allowScriptAccess: "sameDomain"
    };
    ZeroClipboard.setDefaults = function(options) {
        for (var ko in options) _defaults[ko] = options[ko];
    };
    ZeroClipboard.destroy =  function() {
        ZeroClipboard.prototype._singleton.unglue(gluedElements);
        var bridge = ZeroClipboard.prototype._singleton.htmlBridge;
        bridge.parentNode.removeChild(bridge);
        delete ZeroClipboard.prototype._singleton;
    };
    ZeroClipboard.detectFlashSupport = function() {
        var hasFlash = false;
        try {
            if (new ActiveXObject("ShockwaveFlash.ShockwaveFlash")) {
                hasFlash = true;
            }
        } catch (error) {
            if (navigator.mimeTypes["application/x-shockwave-flash"]) {
                hasFlash = true;
            }
        }
        return hasFlash;
    };
    var _bridge = function() {
        var client = ZeroClipboard.prototype._singleton;
        var container = document.getElementById("global-zeroclipboard-html-bridge");
        if (!container) {
            var html = '      <object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" id="global-zeroclipboard-flash-bridge" width="100%" height="100%">         <param name="movie" value="' + client.options.moviePath + _noCache(client.options.moviePath) + '"/>         <param name="allowScriptAccess" value="' + client.options.allowScriptAccess + '"/>         <param name="scale" value="exactfit"/>         <param name="loop" value="false"/>         <param name="menu" value="false"/>         <param name="quality" value="best" />         <param name="bgcolor" value="#ffffff"/>         <param name="wmode" value="transparent"/>         <param name="flashvars" value="' + _vars(client.options) + '"/>         <embed src="' + client.options.moviePath + _noCache(client.options.moviePath) + '"           loop="false" menu="false"           quality="best" bgcolor="#ffffff"           width="100%" height="100%"           name="global-zeroclipboard-flash-bridge"           allowScriptAccess="always"           allowFullScreen="false"           type="application/x-shockwave-flash"           wmode="transparent"           pluginspage="http://www.macromedia.com/go/getflashplayer"           flashvars="' + _vars(client.options) + '"           scale="exactfit">         </embed>       </object>';
            container = document.createElement("div");
            container.id = "global-zeroclipboard-html-bridge";
            container.setAttribute("class", "global-zeroclipboard-container");
            container.setAttribute("data-clipboard-ready", false);
            container.style.position = "absolute";
            container.style.left = "-9999px";
            container.style.top = "-9999px";
            container.style.width = "15px";
            container.style.height = "15px";
            container.style.zIndex = "9999";
            container.innerHTML = html;
            document.body.appendChild(container);
        }
        client.htmlBridge = container;
        client.flashBridge = document["global-zeroclipboard-flash-bridge"] || container.children[0].lastElementChild;
    };
    ZeroClipboard.prototype.resetBridge = function() {
        this.htmlBridge.style.left = "-9999px";
        this.htmlBridge.style.top = "-9999px";
        this.htmlBridge.removeAttribute("title");
        this.htmlBridge.removeAttribute("data-clipboard-text");
        _removeClass(currentElement, this.options.activeClass);
        currentElement = null;
        this.options.text = null;
    };
    ZeroClipboard.prototype.ready = function() {
        var ready = this.htmlBridge.getAttribute("data-clipboard-ready");
        return ready === "true" || ready === true;
    };
    ZeroClipboard.prototype.reposition = function() {
        if (!currentElement) return false;
        var pos = _getDOMObjectPosition(currentElement);
        this.htmlBridge.style.top = pos.top + "px";
        this.htmlBridge.style.left = pos.left + "px";
        this.htmlBridge.style.width = pos.width + "px";
        this.htmlBridge.style.height = pos.height + "px";
        this.htmlBridge.style.zIndex = pos.zIndex + 1;
        this.setSize(pos.width, pos.height);
    };
    ZeroClipboard.dispatch = function(eventName, args) {
        ZeroClipboard.prototype._singleton.receiveEvent(eventName, args);
    };
    ZeroClipboard.prototype.on = function(eventName, func) {
        var events = eventName.toString().split(/\s/g);
        for (var i = 0; i < events.length; i++) {
            eventName = events[i].toLowerCase().replace(/^on/, "");
            if (!this.handlers[eventName]) this.handlers[eventName] = func;
        }
        if (this.handlers.noflash && !ZeroClipboard.detectFlashSupport()) {
            this.receiveEvent("onNoFlash", null);
        }
    };
    ZeroClipboard.prototype.addEventListener = ZeroClipboard.prototype.on;
    ZeroClipboard.prototype.off = function(eventName, func) {
        var events = eventName.toString().split(/\s/g);
        for (var i = 0; i < events.length; i++) {
            eventName = events[i].toLowerCase().replace(/^on/, "");
            for (var event in this.handlers) {
                if (event === eventName && this.handlers[event] === func) {
                    delete this.handlers[event];
                }
            }
        }
    };
    ZeroClipboard.prototype.removeEventListener = ZeroClipboard.prototype.off;
    ZeroClipboard.prototype.receiveEvent = function(eventName, args) {
        eventName = eventName.toString().toLowerCase().replace(/^on/, "");
        var element = currentElement;
        switch (eventName) {
            case "load":
                if (args && parseFloat(args.flashVersion.replace(",", ".").replace(/[^0-9\.]/gi, "")) < 10) {
                    this.receiveEvent("onWrongFlash", {
                        flashVersion: args.flashVersion
                    });
                    return;
                }
                this.htmlBridge.setAttribute("data-clipboard-ready", true);
                break;
            case "mouseover":
                _addClass(element, this.options.hoverClass);
                break;
            case "mouseout":
                _removeClass(element, this.options.hoverClass);
                this.resetBridge();
                break;
            case "mousedown":
                _addClass(element, this.options.activeClass);
                break;
            case "mouseup":
                _removeClass(element, this.options.activeClass);
                break;
            case "datarequested":
                var targetId = element.getAttribute("data-clipboard-target"), targetEl = !targetId ? null : document.getElementById(targetId);
                if (targetEl) {
                    var textContent = targetEl.value || targetEl.textContent || targetEl.innerText;
                    if (textContent) this.setText(textContent);
                } else {
                    var defaultText = element.getAttribute("data-clipboard-text");
                    if (defaultText) this.setText(defaultText);
                }
                break;
            case "complete":
                this.options.text = null;
                break;
        }
        if (this.handlers[eventName]) {
            var func = this.handlers[eventName];
            if (typeof func == "function") {
                func.call(element, this, args);
            } else if (typeof func == "string") {
                window[func].call(element, this, args);
            }
        }
    };
    ZeroClipboard.prototype.glue = function(elements) {
        elements = _prepGlue(elements);
        for (var i = 0; i < elements.length; i++) {
            if (_inArray(elements[i], gluedElements) == -1) {
                gluedElements.push(elements[i]);
                _addEventHandler(elements[i], "mouseover", _elementMouseOver);
            }
        }
    };
    ZeroClipboard.prototype.unglue = function(elements) {
        elements = _prepGlue(elements);
        for (var i = 0; i < elements.length; i++) {
            _removeEventHandler(elements[i], "mouseover", _elementMouseOver);
            var arrayIndex = _inArray(elements[i], gluedElements);
            if (arrayIndex != -1) gluedElements.splice(arrayIndex, 1);
        }
    };
    if (typeof module !== "undefined") {
        module.exports = ZeroClipboard;
    } else if (typeof define === "function" && define.amd) {
        define(function() {
            return ZeroClipboard;
        });
    } else {
        window.ZeroClipboard = ZeroClipboard;
    }
})();
//
// Test controller
//

"use strict";

angular.module("mtApp").controller("TestController", function ($scope, TestService) {

    //
    // Delete all cases
    //
    $scope.deleteCases = function() {

        TestService.deleteCases();
    };

    //
    // Reset favorites for current user
    //
    $scope.resetUserFavorites = function() {

        TestService.resetUserFavorites();
    };

    //
    // Reset all visibility rights
    //
    $scope.resetVisibilityRights = function() {

        TestService.resetVisibilityRights();
    };
});

//
// Test service
//

"use strict";

angular.module("mtApp").factory("TestService", function TestService(TestDAO) {

    return {

        //
        // Delete cases
        //
        deleteCases: function() {

            TestDAO.deleteCases();
        },

        //
        // Reset favorites for current user
        //
        resetUserFavorites: function() {

            TestDAO.resetUserFavorites();
        },

        //
        // Reset all visibility rights
        //
        resetVisibilityRights: function() {

            TestDAO.resetVisibilityRights();
        }

    };

});

//
// Test DAO
//

"use strict";

angular.module("mtApp").factory("TestDAO", function ($resource) {
    return $resource("/api/test", {
        id: "@id"
    }, {
        deleteCases: {
            method: "POST",
            url: "/api/test/delete-cases"
        },
        resetUserFavorites: {
            method: "POST",
            url: "/api/test/reset-user-favorites"
        },
        resetVisibilityRights: {
            method: "POST",
            url: "/api/test/reset-visibility-rights"
        }
    });
});
